"""
Whether you call it a wallet, monetary account, payment account or bank account, the notion of account is fundamental at Swan. All payment flows necessarily go through an account.
"""
type Account {
  """Unique identifier of an account"""
  id: ID!

  """Unique account number"""
  number: AccountNumber!

  """Account name"""
  name: String!

  """Account holder"""
  holder: AccountHolder!

  """Cash account type"""
  cashAccountType: CashAccountType!

  """Country of the account"""
  country: AccountCountry!

  """Payment level"""
  paymentLevel: PaymentLevel!

  """
  Bank Identifier Code
  Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited`
  """
  BIC: BIC!

  """
  International Bank Account Number
  Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited`
  """
  IBAN: IBAN

  """Currency"""
  currency: Currency!

  """`true` if the main IBAN refuses all Sepa Direct Debit received"""
  blockSDD: Boolean

  """Status of the account"""
  statusInfo: AccountStatusInfo!

  """Partnership status"""
  partnershipStatusInfo: PartnershipStatusInfo

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  List of Virtual IBAN
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  virtualIbanEntries(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String
  ): VirtualIBANEntryConnection!

  """
  List of account membership for this account
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  memberships(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: MembershipsFilterInput

    """an order you can apply to your list of connections"""
    orderBy: AccountMembershipOrderByInput
  ): AccountMembershipConnection!

  """`true`if a consent is required to fetch new transactions"""
  requiredConsentToFetchNewTransactions: Boolean!

  """Language used for account statements"""
  language: AccountLanguage!

  """Legal representative account membership"""
  legalRepresentativeMembership: AccountMembership!

  """
  Type of the account : EMoney if account holder has not finished the KYC requirements, PaymentService otherwise
  """
  paymentAccountType: PaymentAccountType!

  """Date of the account going from eMoney to PaymentService"""
  upgradedAt: DateTime

  """Link to the account's bank details"""
  bankDetails: String

  """
  A list of invoices of an account.
  The list is ordered by creation date (from newest to oldest)
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  invoices(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 10

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String
  ): InvoiceConnection
}

"""Account Closed status information"""
type AccountClosedStatus implements AccountStatusInfo {
  """Account status (always Closed for type AccountClosedStatus)"""
  status: AccountStatus!

  """Reason why the account is suspended"""
  reason: String! @deprecated(reason: "Use `reasonInfo` instead.")

  """Reason why the account is currently closed"""
  reasonInfo: CloseAccountStatusReason!
  closedAt: DateTime!
  closingAt: DateTime!
}

"""Account Closing status information"""
type AccountClosingStatus implements AccountStatusInfo {
  """Account status (always Closing for type AccountClosingStatus)"""
  status: AccountStatus!

  """Reason why the account is suspended"""
  reason: String! @deprecated(reason: "Use `reasonInfo` instead.")

  """Reason why the account is currently in closing"""
  reasonInfo: CloseAccountStatusReason!
  closingAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type AccountConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """AccountEdge list"""
  edges: [AccountEdge!]!
}

"""
Refers to the country of the account. It will determine the country code of the local IBAN of the account.

Available Account Country: CCA3
"""
enum AccountCountry {
  """French account with a French IBAN, starting with FR."""
  FRA

  """German account with a German IBAN, starting with DE."""
  DEU

  """Spanish account with a Spanish IBAN, starting with ES."""
  ESP

  """Dutch account with a Dutch IBAN, starting with DU."""
  NLD

  """
  Italian account with an Italian IBAN, starting with IT (Coming Soon, not supported yet).
  """
  ITA
}

"""Implements the Relay Edge interface"""
type AccountEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The account"""
  node: Account!
}

enum AccountFundingLimitsReachedReason {
  """Account Holder instant funding limit exceeded"""
  InstantFundingLimitExceededRejection

  """Account Holder funding limit exceeded"""
  FundingLimitExceededRejection

  """Project instant funding limit exceeded"""
  ProjectInstantFundingLimitExceededRejection

  """Project funding limit exceeded"""
  ProjectFundingLimitExceededRejection

  """Global instant funding limit exceeded"""
  GlobalInstantFundingLimitExceededRejection

  """Global funding limit exceeded"""
  GlobalFundingLimitExceededRejection

  """Insufficient funds rejection"""
  InsufficientFundsRejection
}

"""
The account holder is the person who owns the money stored in the account. The account holder can be one of your customers, whether it is a natural person or a legal person, or quite simply you.
"""
type AccountHolder {
  """Unique identifier of the account holder."""
  id: ID!

  """
  Verification status.
  *Banking regulations require financial institutions such as Swan to know and verify their customers in order to comply with their anti-money laundering and terrorist financing obligations. In banking jargon, we talk about KYC (Know Your Customers) procedure*
  """
  verificationStatus: VerificationStatus!

  """Account holder verification Status information."""
  verificationStatusInfo: AccountHolderVerificationStatusInfo!

  """Account holder type information."""
  info: AccountHolderInfo!

  """Account holder status information."""
  statusInfo: AccountHolderStatusInfo

  """Residency address."""
  residencyAddress: AddressInfo!

  """Created date."""
  createdDate: DateTime!

  """Updated date."""
  updatedDate: DateTime!

  """
  List of accounts owned by the account holder.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  accounts(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """an order you can apply to your list of connections"""
    orderBy: AccountOrderByInput
  ): AccountConnection!

  """
  List of supporting document collection for an account holder
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  supportingDocumentCollections(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """When the list of supporting document collections needs to be filtered"""
    filters: SupportingDocumentCollectionFilterInput
  ): SupportingDocumentCollectionConnection!

  """
  List of funding limit settings change request for an account holder
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  fundingLimitSettingsChangeRequests(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String
  ): FundingLimitSettingsChangeRequestConnection!

  """Account holder onboarding"""
  onboarding: Onboarding

  """
  A list of Payment Mandates for an account holder.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  paymentMandates(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value updatedAt desc)
    """
    orderBy: PaymentMandateOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: PaymentMandateFiltersInput
  ): PaymentMandateConnection
}

"""Account Holder Canceled Status Information"""
type AccountHolderCanceledStatusInfo implements AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!

  """Reason why the account holder is suspended."""
  reason: String!
}

type AccountHolderCompanyInfo implements AccountHolderInfo {
  """Account holder type (always Company for type AccountHolderCompanyInfo)"""
  type: AccountHolderType!

  """Name of the company."""
  name: String!

  """
  Registration number of the company (for example, Système d'Identification du Répertoire des ENtreprises [SIREN] in France, ...).
  - Length must be from 0 to 50 characters.
  """
  registrationNumber: String

  """Registration date of the company."""
  companyRegistrationDate: Date

  """Legal form of the company (SAS, SCI, SASU, ...)."""
  companyType: CompanyType

  """Business activity."""
  businessActivity: BusinessActivity!

  """
  Business activity description.
  This must be 1024 characters long maximum.
  """
  businessActivityDescription: String!

  """Estimated monthly payment volume (euro)."""
  monthlyPaymentVolume: MonthlyPaymentVolume!

  """
  The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
  
  The ultimate beneficiary is :
  - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
  - either the natural person (s) who exercise, by other means, a power of control of the company;
  """
  individualUltimateBeneficialOwners: [IndividualUltimateBeneficialOwner!]!

  """
  Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT
  """
  vatNumber: String

  """Tax Identification Number"""
  taxIdentificationNumber: String

  """Legal representative personal address"""
  legalRepresentativePersonalAddress: AddressInformation
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)).
"""
type AccountHolderConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """AccountHolderEdge list"""
  edges: [AccountHolderEdge!]!
}

"""Implements the Relay Edge interface."""
type AccountHolderEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The account holder"""
  node: AccountHolder!
}

"""Account Holder Enabled Status Information"""
type AccountHolderEnabledStatusInfo implements AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!
}

"""Filters that can be applied when listing account holders"""
input AccountHolderFilterInput {
  """Filter by birth date"""
  birthDate: String

  """
  Filter by registration number of the company
  (for example, Système d'Identification du Répertoire des ENtreprises [SIREN] in France, ...).
  
  - Length must be from 0 to 50 characters.
  """
  registrationNumber: String

  """Filter by status"""
  status: [AccountHolderStatus!]

  """Filter by type"""
  types: [AccountHolderType!]

  """Filter by verification status"""
  verificationStatus: [VerificationStatus!]

  """
  Search string to look for
  
  Search will be performed in following fields:
   - First name
   - Last name
   - Company name
   - ID
  """
  search: String

  """
  Search by first name
  
  @deprecated(reason: "use `search` instead")
  """
  firstName: String

  """
  Search by last name
  
  @deprecated(reason: "use `search` instead")
  """
  lastName: String
}

"""Individual account holder."""
type AccountHolderIndividualInfo implements AccountHolderInfo {
  """
  Account holder type (always Individual for type AccountHolderIndividualInfo).
  """
  type: AccountHolderType!

  """Account Holder's first name and last name."""
  name: String!

  """Employment status of the account holder (regulatory questions)."""
  employmentStatus: EmploymentStatus!

  """Monthly income of the account holder (regulatory questions)."""
  monthlyIncome: MonthlyIncome!

  """User of the individual account holder."""
  user: User!

  """Tax Identification Number"""
  taxIdentificationNumber: String
}

"""Account holder types."""
interface AccountHolderInfo {
  """Account holder type"""
  type: AccountHolderType!

  """Account holder name"""
  name: String!
}

"""Rejection returned when the Account Holder was not found"""
type AccountHolderNotFoundRejection implements Rejection {
  message: String!
}

type AccountHolderNotStartedVerificationStatusInfo implements AccountHolderVerificationStatusInfo {
  """Verification Status of the account holder."""
  status: VerificationStatus!
}

"""
Field we can use when ordering that can be applied when listing account holders
"""
enum AccountHolderOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing account holders"""
input AccountHolderOrderByInput {
  field: AccountHolderOrderByFieldInput
  direction: OrderByDirection
}

type AccountHolderPendingVerificationStatusInfo implements AccountHolderVerificationStatusInfo {
  """Verification Status of the account holder."""
  status: VerificationStatus!

  """ISO Date string at which the account holder status was set to Pending"""
  pendingAt: DateTime!
}

type AccountHolderRefusedVerificationStatusInfo implements AccountHolderVerificationStatusInfo {
  """Verification Status of the account holder."""
  status: VerificationStatus!

  """ISO Date string at which the account holder status was set to Refused"""
  refusedAt: DateTime!

  """Reason for which the account holder was refused"""
  reason: String!
}

"""Account holder status."""
enum AccountHolderStatus {
  """When the account holder is enabled."""
  Enabled

  """When the account holder is suspended."""
  Suspended

  """When the account holder is canceled."""
  Canceled
}

"""Account Holder Status Information"""
interface AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!
}

"""Account Holder Suspended Status Information"""
type AccountHolderSuspendedStatusInfo implements AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!

  """Reason why the account holder is suspended."""
  reason: String!
}

"""Account holder type"""
enum AccountHolderType {
  """Individual (Natural person)"""
  Individual

  """Company (Legal person)"""
  Company
}

"""Account Holder Verification Status Information"""
interface AccountHolderVerificationStatusInfo {
  """Verification Status of the account holder."""
  status: VerificationStatus!
}

type AccountHolderVerifiedVerificationStatusInfo implements AccountHolderVerificationStatusInfo {
  """Verification Status of the account holder."""
  status: VerificationStatus!

  """ISO Date string at which the account holder status was set to Verified"""
  verifiedAt: DateTime!
}

type AccountHolderWaitingForInformationVerificationStatusInfo implements AccountHolderVerificationStatusInfo {
  """Verification Status of the account holder."""
  status: VerificationStatus!
  verificationRequirements: [VerificationRequirement!]!

  """@deprecated(reason: "Use `waitingForInformationAt` instead")"""
  WaitingForInformationAt: DateTime! @deprecated

  """
  ISO Date string at which the account holder status was set to WaitingForInformation
  """
  waitingForInformationAt: DateTime!
}

"""Language: ISO 639-1 language code"""
enum AccountLanguage {
  de
  en
  fr
  it
  nl
  es
  pt
  fi
}

"""
An account membership represents the rights of a user for a given account.

*Each account is administered by an account membership having the capacity of legal representative. He has the possibility of delegating rights on this account to other users.*
"""
type AccountMembership {
  """Unique identifier of an account membership"""
  id: ID!

  """email"""
  email: String!

  """user of this account membership"""
  user: User

  """
  `true` if this account membership having the capacity of the legal representative of the account holder.
  """
  legalRepresentative: Boolean!

  """
  `true` if this account membership can view account balances and transactions history
  """
  canViewAccount: Boolean!

  """`true` if this account membership can add or canceled beneficiaries"""
  canManageBeneficiaries: Boolean!

  """`true` if this account membership can initiate credit transfers"""
  canInitiatePayments: Boolean!

  """
  `true` if this account membership can invite, update, suspend or resume memberships
  """
  canManageAccountMembership: Boolean!

  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean!

  """status of the account membership"""
  statusInfo: AccountMembershipStatusInfo!

  """Unique identifier of the account of the account membership"""
  accountId: ID!

  """account of the account membership"""
  account: Account

  """Periodic Spending limit list"""
  spendingLimits: [SpendingLimit!]

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  version of the account membership started from '1' and incremented at every updates
  """
  version: String!

  """Residency address of the member"""
  residencyAddress: AddressInfo

  """Tax Identification Number of the member"""
  taxIdentificationNumber: String

  """List of accepted identification level"""
  acceptedIdentificationLevels: [IdentificationLevel]!

  """Recommended identification level"""
  recommendedIdentificationLevel: IdentificationLevel!

  """
  Indicate if the identity bound to the account membership has required identification level
  """
  hasRequiredIdentificationLevel: Boolean

  """Disabled date"""
  disabledAt: DateTime

  """Language of the account membership"""
  language: AccountLanguage
}

"""when a user is bound with the error to the account membership"""
type AccountMembershipBindingUserErrorStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always BindingUserError for type AccountMembershipBindingUserErrorStatusInfo)
  """
  status: AccountMembershipStatus!

  """
  `true` if the first name of the bound user doesn't match with the invitation
  """
  firstNameMatchError: Boolean!

  """
  `true` if the email of the bound user doesn't match with the invitation
  """
  emailVerifiedMatchError: Boolean!

  """`true` if Swan hasn't verified the user's identity"""
  idVerifiedMatchError: Boolean!

  """
  `true` if the last name of the bound user doesn't match with the invitation
  """
  lastNameMatchError: Boolean!

  """
  `true` if the phone number of the bound user doesn't match with the invitation
  """
  phoneNumberMatchError: Boolean!

  """
  `true` if the birth date of the bound user doesn't match with the invitation
  """
  birthDateMatchError: Boolean!

  """restricted to a user"""
  restrictedTo: RestrictedTo!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type AccountMembershipConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """AccountMembershipEdge list"""
  edges: [AccountMembershipEdge!]!
}

"""when the user has to consent to invite a new account membership"""
type AccountMembershipConsentPendingStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always ConsentPending for type AccountMembershipConsentPendingStatusInfo)
  """
  status: AccountMembershipStatus!

  """The consent required to invite this account membership"""
  consent: Consent!

  """restricted to a user"""
  restrictedTo: RestrictedTo!
}

"""when the account membership is disabled"""
type AccountMembershipDisabledStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always Disabled for type AccountMembershipDisabledStatusInfo)
  """
  status: AccountMembershipStatus!

  """reason why the account membership is disabled"""
  reason: String!
}

"""Implements the Relay Edge interface"""
type AccountMembershipEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The account membership"""
  node: AccountMembership!
}

"""when the account membership is enabled"""
type AccountMembershipEnabledStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always Enabled for type AccountMembershipEnabledStatusInfo)
  """
  status: AccountMembershipStatus!
}

"""
when a new account membership is invited and there is no user bound yet
"""
type AccountMembershipInvitationSentStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always InvitationSent for type AccountMembershipInvitationSentStatusInfo)
  """
  status: AccountMembershipStatus!

  """restricted to a user"""
  restrictedTo: RestrictedTo!
}

"""
Field we can use when ordering that can be applied when listing account memberships
"""
enum AccountMembershipOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing account memberships"""
input AccountMembershipOrderByInput {
  field: AccountMembershipOrderByFieldInput
  direction: OrderByDirection
}

"""Filters that can be applied when listing account memberships"""
input AccountMembershipsFilterInput {
  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean

  """Can the user initiate payments on this account"""
  canInitiatePayments: Boolean

  """Can the user manage account membership"""
  canManageAccountMembership: Boolean

  """Can the user manage beneficiaries"""
  canManageBeneficiaries: Boolean

  """Can the user view account"""
  canViewAccount: Boolean

  """Account memberships status/statuses we're looking for"""
  status: [AccountMembershipStatus!]

  """
  Search by email
  
  @deprecated(reason: "use `search` instead")
  """
  email: String

  """
  Search by first name
  
  @deprecated(reason: "use `search` instead")
  """
  firstName: String

  """
  Search by last name
  
  @deprecated(reason: "use `search` instead")
  """
  lastName: String

  """
  Search string to look for
  
  Search will be performed in following fields:
   - First name
   - Last name
   - Email
   - ID
  """
  search: String

  """Filter by account"""
  accountId: String
}

"""AccountMembership enabled"""
enum AccountMembershipStatus {
  """when the consent to invite the account membership is pending"""
  ConsentPending

  """when the account membership is invited"""
  InvitationSent

  """when the user bound with errors to the account membership"""
  BindingUserError

  """when the account membership is enabled"""
  Enabled

  """when the account membership is suspended"""
  Suspended

  """when the account membership is disabled"""
  Disabled
}

"""here are the different account membership status:"""
interface AccountMembershipStatusInfo {
  """AccountMembership status"""
  status: AccountMembershipStatus!
}

"""when the account membership is suspended"""
type AccountMembershipSuspendedStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always Suspended for type AccountMembershipSuspendedStatusInfo)
  """
  status: AccountMembershipStatus!

  """reason why the account membership is suspended"""
  reason: String!
}

"""Thrown when an related account is not eligible to the feature"""
type AccountNotEligibleRejection implements Rejection {
  message: String!
}

"""
Rejection returned if the account was not found or if the user does not have the rights to know that the card exists
"""
type AccountNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Swan account number"""
scalar AccountNumber

"""Account Opened status information"""
type AccountOpenedStatus implements AccountStatusInfo {
  """Account status (always Opened for type AccountOpenedStatus)"""
  status: AccountStatus!
}

"""Fields that can be used when ordering accounts"""
enum AccountOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing accounts"""
input AccountOrderByInput {
  field: AccountOrderByFieldInput
  direction: OrderByDirection
}

enum AccountStatus {
  """When the account is opened"""
  Opened

  """When the account is suspended"""
  Suspended

  """When the account is currently closing"""
  Closing

  """When the account is closed"""
  Closed
}

interface AccountStatusInfo {
  """Account status"""
  status: AccountStatus!
}

"""Account Suspended status information"""
type AccountSuspendedStatus implements AccountStatusInfo {
  """Account status (always Suspended for type AccountSuspendedStatus)"""
  status: AccountStatus!

  """Reason why the account is suspended"""
  reason: String! @deprecated(reason: "Use `reasonInfo` instead.")

  """Reason why the account is currently suspend"""
  reasonInfo: SuspendAccountStatusReason!
}

"""Account Verification"""
interface AccountVerification {
  """Creation date of the account verification"""
  createdAt: DateTime!

  """Unique identifier of the Account Verification"""
  id: ID!

  """Account Verification Status Information"""
  statusInfo: AccountVerificationStatusInfo!

  """Last update date of the account verification"""
  updatedAt: DateTime!
}

"""
Rejection returned when the external account has already been rejected.

In such a case, contact Swan directly to resolve the situation for this specific account holder.
"""
type AccountVerificationAlreadyRejectedRejection implements Rejection {
  message: String!
}

"""Account Verification Status"""
enum AccountVerificationStatus {
  """
  We are waiting for the end user to send a credit transfer from his external iban to any Swan owned iban
  """
  PendingVerification

  """
  We could not automatically match the external iban based on last received transfer.
  Manuel review process is underway
  """
  PendingReview

  """Account has been verified"""
  Verified

  """Account verification has been rejected"""
  Rejected
}

"""Account Verification Status Information"""
interface AccountVerificationStatusInfo {
  """Account verification status"""
  status: AccountVerificationStatus!
}

"""
Rejection returned when the Account Verification is not in the expected status
"""
type AccountVerificationWrongStatusRejection implements Rejection {
  message: String!
}

type ActiveMerchantPaymentLinkStatusInfo implements MerchantPaymentLinkStatusInfo {
  status: MerchantPaymentLinkStatus!

  """
  The date when the payment link expires.
  By default the payment link expires 120 days after it was created.
  """
  expiresAt: DateTime!
}

"""Address Information"""
type Address {
  """address line 1"""
  addressLine1: String

  """addressLine2"""
  addressLine2: String

  """city"""
  city: String

  """postal code (max 10 characters)"""
  postalCode: String

  """state"""
  state: String

  """country"""
  country: CCA3
}

"""Address information."""
type AddressInfo {
  """Address line 1."""
  addressLine1: String

  """Address line 2."""
  addressLine2: String

  """City."""
  city: String

  """Postal code."""
  postalCode: String

  """State."""
  state: String

  """Country."""
  country: CCA3
}

"""Address"""
type AddressInformation {
  """Address"""
  addressLine1: String!

  """Address"""
  addressLine2: String

  """City"""
  city: String!

  """Country"""
  country: CCA3!

  """Postal code"""
  postalCode: String!

  """State"""
  state: String
}

"""Address"""
input AddressInformationInput {
  """Address"""
  addressLine1: String

  """Address"""
  addressLine2: String

  """City"""
  city: String

  """Country"""
  country: CCA3!

  """Postal code"""
  postalCode: String

  """State"""
  state: String
}

"""Address Information"""
input AddressInput {
  """address line 1 (max 100 characters)"""
  addressLine1: String

  """address line 2 (max 100 characters)"""
  addressLine2: String

  """city (max 100 characters)"""
  city: String

  """postal code (max 10 characters)"""
  postalCode: String

  """state (max 100 characters)"""
  state: String

  """country code"""
  country: CCA3!
}

type AllowedValue {
  key: String!
  name: String!
}

"""Amount with its currency"""
type Amount {
  """currency"""
  currency: Currency!

  """value of the amount"""
  value: AmountValue!
}

"""Amount with its currency"""
input AmountInput {
  """value of the amount"""
  value: AmountValue!

  """currency"""
  currency: Currency!
}

"""
The amount given with fractional digits, where fractions must be compliant to the currency definition. Up to 14 significant figures. Negative amounts are signed by minus. The decimal separator is a dot.

Example: Valid representations for EUR with up to two decimals are:

1056
5768.2
-1.50
5877.78
"""
scalar AmountValue

type AmountWithCurrency {
  value: AmountValue!
  currency: Currency!
}

"""Approved Funding Limit"""
type ApprovedFundingLimit {
  """Requested amount settings for the instant funding limit"""
  instantFundingLimit: FundingLimitAmount!

  """Requested amount settings for the funding limit"""
  fundingLimit: FundingLimitAmount!
}

scalar AuditId

"""A method used to authenticate a user"""
type Authenticator {
  """
  Operating System parsed from the user agent (eg AIX, Amiga OS, Android, Arch, Bada, BeOS, BlackBerry, ...)
  """
  os: String

  """
  Device Brand parsed from the user agent (eg: Acer, Alcatel, Amazon, Apple, ...)
  """
  brand: String

  """Device Model parsed from the user agent"""
  model: String

  """Type of authenticator"""
  type: AuthenticatorType!

  """Raw user agent"""
  userAgent: String

  """Accept-Language header used during registration"""
  acceptLanguage: String
  status: AuthenticatorStatus!
}

enum AuthenticatorStatus {
  """
  The user must send their basic personal info (firstname, name, birthdate)
  before the status can switch to Enabled
  """
  WaitingForUserInfo

  """
  The user must go through the verification (reinit) process
  Once verified, the status will switch to Enabled
  """
  WaitingForVerification

  """
  The user must go through customer support for verification (reinit)
  Once verified, the status will switch to Enabled
  """
  WaitingForCustomerSupportVerification

  """The authenticator can be used eg. to sign requests or call our apis"""
  Enabled

  """
  The authenticator was canceled because the user disconnected
  or they created a new authenticator - this status is final
  """
  Canceled

  """The authenticator was suspended - this status is final"""
  Suspended

  """
  This authenticator is not verified and the user hasn't validated any authentication factor.
  """
  WaitingForAuthentication
}

enum AuthenticatorType {
  """A Swan web authenticator"""
  SwanWeb

  """Deprecated: swan authenticator"""
  Swan
}

scalar AuthorizationId

"""Rejection returned if the status account is not valid"""
type BadAccountStatusRejection implements Rejection {
  id: String!
  message: String!
}

type BadRequestRejection implements Rejection {
  message: String!
}

"""Basic Physical Card Info"""
type BasicPhysicalCardInfo {
  """Physical Card expiration date  with MM/YY string format"""
  expiryDate: String

  """Offline Spending limit defined by Swan"""
  offlineSpendingLimit: Amount!

  """Masked Card Number"""
  cardMaskedNumber: String!

  """Custom Options"""
  customOptions: PhysicalCardCustomOptions!

  """Unique identifier present on physical card"""
  identifier: String

  """`true` if physical card is expired"""
  isExpired: Boolean!
}

"""Bank Identifier Code"""
scalar BIC

type Branding {
  projectId: String
  name: String!
  logoUri: String
  accentColor: String
  customConsentSubdomain: String
}

type BrowserConsent implements DetailedConsent {
  id: ID!
  projectId: String
  accountId: String
  requireSCA: Boolean!
  status: ConsentStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  startedAt: DateTime
  expiredAt: DateTime
  acceptedAt: DateTime
  refusedAt: DateTime
  canceledAt: DateTime
  consentResponses: [ConsentResponse!]!
  purpose: DetailedConsentPurpose!
  serviceToHook: String!
  consentOperations: [ConsentOperation!]!
  env: EnvType!
  identityId: String!
  userId: String
  state: String
  branding: Branding!
  operationsSHA256HexDigest: String
  consentUrl: String!
  redirectUrl: String!
  allowsServerConsent: Boolean!
  challenge: String
  channelName: String
}

type BrowserMultiConsent implements DetailedConsent {
  id: ID!
  projectId: String
  accountId: String
  requireSCA: Boolean!
  status: ConsentStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  startedAt: DateTime
  expiredAt: DateTime
  acceptedAt: DateTime
  refusedAt: DateTime
  canceledAt: DateTime
  consentResponses: [ConsentResponse!]!
  purpose: DetailedConsentPurpose!
  consentOperations: [ConsentOperation!]!
  env: EnvType!
  identityId: String!
  userId: String
  state: String
  branding: Branding!
  operationsSHA256HexDigest: String
  aggregatedPurposesWithOperations: [PurposeWithOperations!]!
  consentUrl: String!
  redirectUrl: String!
  allowsServerConsent: Boolean!
  challenge: String
  channelName: String
}

"""Business activity."""
enum BusinessActivity {
  AdministrativeServices
  Agriculture
  Arts
  BusinessAndRetail
  Construction
  Education
  ElectricalDistributionAndWaterSupply
  FinancialAndInsuranceOperations
  Health
  Housekeeping
  InformationAndCommunication
  LodgingAndFoodServices
  ManufacturingAndMining
  Other
  PublicAdministration
  RealEstate
  ScientificActivities
  Transportation
}

"""
Describes an identification level for the process associated to this identification that has been cancelled by the end-user
"""
type CanceledIdentificationLevelStatusInfo {
  """Always set to `Cancelled`"""
  status: SwanIdentificationStatus!
}

"""Capital deposit case for a company."""
type CapitalDepositCase {
  """Unique identifier of a capital deposit case."""
  id: String!

  """List of the company’s shareholders."""
  shareholders: [Shareholder!]!

  """Amount of the capital deposit."""
  totalCapitalDepositAmount: Amount!

  """Name of the company."""
  companyName: String!

  """Onboarding information of the company."""
  companyOnboarding: Onboarding

  """Unique identifier of the company account."""
  companyAccountId: String

  """Status of the capital deposit case."""
  status: CapitalDepositCaseStatus!

  """Documents to provide to fulfill the capital deposit case."""
  documents: [CapitalDepositDocument!]!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!
}

"""
Rejection returned if the capital deposit case cannot be canceled in its current state
"""
type CapitalDepositCaseCanNotBeCanceledRejection implements Rejection {
  id: String!
  message: String!
}

"""Rejection returned if the capital deposit case cannot be found"""
type CapitalDepositCaseCanNotBeFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""
Implements the Relay Connection interface, used to paginate list of elements ([Learn More](https://docs.swan.io/api/pagination))
"""
type CapitalDepositCaseConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """CapitalDepositCaseEdge list"""
  edges: [CapitalDepositCaseEdge!]!
}

"""Implements the Relay Edge interface"""
type CapitalDepositCaseEdge implements Edge {
  """
  Opaque identifier pointing to this capital deposit case node in the pagination mechanism
  """
  cursor: String!

  """The CapitalDepositCase"""
  node: CapitalDepositCase!
}

"""Filters that can be applied when listing capital deposit cases"""
input CapitalDepositCaseFiltersInput {
  """
  Search string to look for
  
  Search will be performed in following fields:
   - Company shareholder's name
   - Individual shareholder's first name
   - Individual shareholder's last name
   - Company name
   - ID
  """
  search: String

  """Filter by status"""
  status: [CapitalDepositCaseStatus!]
}

"""
Field we can use when ordering that can be applied when listing capital deposit cases
"""
enum CapitalDepositCaseOrderByFieldInput {
  id
  createdAt
  updatedAt
}

"""Order that can be applied when listing capital deposit cases"""
input CapitalDepositCaseOrderByInput {
  field: CapitalDepositCaseOrderByFieldInput
  direction: OrderByDirection
}

"""Status of a capital deposit case."""
enum CapitalDepositCaseStatus {
  """
  Technical state when the mutation to create a new capital deposit case is called.
  """
  Initiated

  """
  A new capital deposit case is created and Swan is waiting for the required information to be provided and each shareholder to wire their share of share capital.
  """
  WaitingForRequirements

  """
  Swan is waiting for the notary to provide the Share Deposit Certificate.
  """
  WaitingForShareDepositCertificate

  """Swan is waiting for you to provide the Register Extract."""
  WaitingForRegisterExtract

  """
  Swan is waiting for the notary to wire the share capital on the account of the company being registered.
  """
  WaitingForNotaryTransfer

  """The capital deposit case is completed."""
  Completed

  """The capital deposit case is canceled."""
  Canceled
}

"""Document provided for a capital deposit case."""
type CapitalDepositDocument {
  """Unique identifier of a document."""
  id: String!

  """Type of the document."""
  type: CapitalDepositDocumentType!

  """
  Url to download the document, null if it has not already been uploaded.
  """
  downloadUrl: String

  """Date when the last version of the document has been uploaded."""
  uploadedAt: Date

  """Status of the document."""
  status: CapitalDepositDocumentStatus! @deprecated(reason: "use statusInfo.status")

  """Status info of the document."""
  statusInfo: CapitalDepositDocumentStatusInfo!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Information about capital deposit case."""
  relatedCapitalDepositCase: CapitalDepositCase

  """Information about shareholder."""
  relatedShareholder: Shareholder
}

"""
Rejection returned if the document from a capital deposit case cannot be uploaded in its context
@deprecated(reason: "use `CapitalDepositDocumentCanNotBeUploadedRejection` instead")
"""
type CapitalDepositDocumentCanNotBeUploaded implements Rejection {
  id: String!
  message: String!
}

"""
Rejection returned if the document from a capital deposit case cannot be uploaded in its context
"""
type CapitalDepositDocumentCanNotBeUploadedRejection implements Rejection {
  id: String!
  message: String!
}

"""Capital Deposit Document with Pending status"""
type CapitalDepositDocumentPendingStatusInfo implements CapitalDepositDocumentStatusInfo {
  """Pending"""
  status: CapitalDepositDocumentStatus!
}

"""Capital Deposit Document with Refused status"""
type CapitalDepositDocumentRefusedStatusInfo implements CapitalDepositDocumentStatusInfo {
  """Refused"""
  status: CapitalDepositDocumentStatus!

  """Reason for the rejection."""
  reasonCode: DocumentReasonCode!
}

"""Status of the Capital Deposit Case"""
enum CapitalDepositDocumentStatus {
  """Document is not uploaded yet."""
  Pending

  """Document has been uploaded but not verified by Swan yet."""
  Uploaded

  """Document has been uploaded and verified by Swan."""
  Validated

  """Document has been refused by Swan, it must be uploaded again."""
  Refused
}

"""Status info of the document."""
interface CapitalDepositDocumentStatusInfo {
  """Status of the document."""
  status: CapitalDepositDocumentStatus!
}

"""Type of the document."""
enum CapitalDepositDocumentType {
  """Legal document required for company’s formation."""
  ArticlesOfIncorporation

  """Commercial registry extract issued within the last 3 months."""
  RegisterExtract

  """Can be either passport, national id card or resident permit."""
  ProofOfIdentity

  """
  Document submitted to your tax bureau at the end of the last business period.
  """
  CorporateIncomeTaxReturn

  """
  Can be a utility bill (water, electricity or gas), a telephone bill or a rental receipt. The document must have been issued within the last 3 months.
  """
  ProofOfIndividualAddress

  """
  Lease agreement in the name of the business or Proof of Individual Address if the company is hosted by one of the legal representative.
  """
  CompanyLeaseAgreement

  """
  Created by the Notary, it certifies the capital of the company to have been deposited with the appropriate share for each shareholder.
  """
  CapitalShareDepositCertificate

  """Signed power of attorney document to give the power to act on behalf."""
  PowerOfAttorney
}

"""Capital Deposit Document with Uploaded status"""
type CapitalDepositDocumentUploadedStatusInfo implements CapitalDepositDocumentStatusInfo {
  """Uploaded"""
  status: CapitalDepositDocumentStatus!
}

"""Capital Deposit Document with Validated status"""
type CapitalDepositDocumentValidatedStatusInfo implements CapitalDepositDocumentStatusInfo {
  """Validated"""
  status: CapitalDepositDocumentStatus!
}

"""Card authorization operation type"""
enum CardAuthorizationOperationType {
  AtmWithdrawal
  CashBackPayment
  Credit
  InStoreWithdrawal
  Payment
  QuasiCash
  TokenizationRequest
}

enum CardAuthorizationOutcome {
  Accepted
  AccountClosed
  AccountSuspended
  AmountInvalid
  AtmWithdrawalAmountLimitExceeded
  AtmWithdrawalNumberLimitExceeded
  CanceledByCardHolder
  CardExpired
  CardNotActivated
  CardNumberInvalid
  CardOutOfOrder
  CardPermanentlyBlocked
  CardSuspended
  CardHolderVerificationMethodMissing
  CardUnknown
  ChipCryptogramControlRefusal
  ContactlessAmountLimitExceeded
  ContactlessCumulativeAmountLimitExceeded
  DigitalCardDeactivated
  DigitalCardEnrollmentInvalid
  DigitalCardRefusal
  DigitalCardSuspended
  DigitalCardTokenInvalid
  DoNotHonor
  DomesticTransactionNotAllowed
  FraudRossAndersonRefusal
  InconsistentEmvAmount
  InPersonTransactionsNotAuthorized
  InvalidAuthorizationResponse
  InvalidExpirationDate
  InvalidPinAttemptsExceeded
  InvalidSecurityNumber
  MagstripeNotSupported
  MerchantNotFound
  MerchantShouldResubmitAuthorization
  MissingExpirationDate
  MiscellaneousReason
  PartialCancelation
  PartialApproval
  PinInvalid
  PinRequired
  SchemeAccountConversionError
  SchemeStandInRefusal
  SchemeTransactionBlockingRefusal
  SecurityViolation
  SoftDecline
  SwanTechnicalErrorOccurred
  SwanTimeout
  TerminalVerificationResultsInvalid
  ThreeDsError
  TransactionAmountLimitExceeded
  TransactionCurrencyIncorrect
  TransactionDuplicated
  TransactionInvalid
  TransactionNotAllowed
  TransactionNotAuthorizedForCardHolder
  UnableToDetectTransactionEnvironment
}

enum CardAuthorizationReleaseReason {
  """Authorization expired"""
  Expired

  """Authorization manually released by Swan"""
  ManuallyReleased

  """Authorization released by the merchant"""
  MerchantReleased
}

enum CardAuthorizationType {
  Classic
  PreAuthorization
  DataRequest
}

"""COMING SOON"""
type CardMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve

  """Reason of rejection when the status is Rejected"""
  rejectReason: MerchantPaymentMethodCardRejectReason
}

"""
Rejection returned if the card was not found or if the user does not have the rights to know that the account exists
"""
type CardNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

type CardPaymentMandate implements PaymentMandate {
  """Unique identifier of the Payment Mandate"""
  id: ID!

  """Custom name of the mandate"""
  name: String

  """Account Holder information"""
  accountHolder: AccountHolder!

  """The card associated to this mandate"""
  card: ExternalCard!

  """Creation date of the Payment Mandate"""
  createdAt: DateTime!

  """Last Update date of the Payment Mandate"""
  updatedAt: DateTime!

  """
  Date of the the last transaction executed for the concerned Payment Mandate
  """
  executedAt: DateTime

  """Expiry date of the Payment Mandate"""
  expiredAt: Date

  """Payment Mandate status information"""
  statusInfo: PaymentMandateStatusInfo!
}

enum CardPaymentMandateCategory {
  Consumer
  Commercial
}

enum CardPaymentMandateScheme {
  Visa
  Mastercard
  CartesBancaires
}

enum CardPaymentMandateType {
  Credit
  Debit
  Prepaid
  Charge
  Deferred
}

"""Location where the card should be printed from"""
enum CardPrintingHub {
  France
  Spain
}

scalar CardToken

enum CardTransactionCategory {
  InStore
  eCommerce
  eCommerceWith3DS
  Withdrawal
  Other
}

"""Type of card"""
enum CardType {
  Physical
  Virtual
}

"""Cash account type (Always Current)"""
enum CashAccountType {
  """When the account is a current account."""
  Current
  CashPayment
  Charges
  CashIncome
  Commission
  ClearingParticipantSettlementAccount
  LimitedLiquiditySavingsAccount
  Loan
  MarginalLending
  MoneyMarket
  NonResidentExternal
  Overdraft
  OverNightDeposit
  OtherAccount
  Settlement
  Salary
  Savings
  Tax
  TransactingAccount
  CashTrading
}

"""Country code alpha 2 (ISO 3166)"""
scalar CCA2

"""Country code alpha 3 (ISO 3166)"""
scalar CCA3

"""CheckMerchantPaymentMethod"""
type CheckMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

"""List of Check return reasons"""
enum CheckReturnReasonCodeEnum {
  AccountClosed
  CheckBlocked
  CheckOutdated
  DebtorDeceased
  EndorsementMissingOrInvalid
  Fraudulent
  InsufficientFunds
  LegalOrBankDecision
  MandatoryReferenceMissingOnCheck
  SignatureInvalid
  SwanTechnicalErrorOccurred
  TransactionDuplicated
}

"""
Define a reason with a message and a specific type for closing account action
"""
type CloseAccountReason implements Reason {
  type: CloseAccountReasonType!
  message: String
}

"""Specific type for closing account action"""
enum CloseAccountReasonType {
  """Compliance Reason"""
  ComplianceReason

  """Partner Reason"""
  PartnerReason

  """Inactivity"""
  Inactivity

  """Capital Deposit Reason"""
  CapitalDepositReason
}

"""
Union between PartnerCloseAccountReasonType and InternalCloseAccountReason
"""
union CloseAccountStatusReason = CloseAccountReason

"""Company shareholder info."""
type CompanyShareholder {
  """Whether the shareholder is an individual or a company."""
  type: ShareholderType!

  """Company name."""
  name: String!
}

"""Type of company."""
enum CompanyType {
  Association
  Company
  HomeOwnerAssociation
  Other
  SelfEmployed
}

"""Complete Address Information"""
input CompleteAddressInput {
  """address line 1 (max 38 characters)"""
  addressLine1: String!

  """address line 2 (max 38 characters)"""
  addressLine2: String

  """city (max 30 characters)"""
  city: String!

  """postal code (max 10 characters)"""
  postalCode: String!

  """state (max 30 characters)"""
  state: String

  """country code"""
  country: CCA3!
}

"""Complete Address Information with a contact"""
input CompleteAddressWithContactInput {
  """address line 1 (max 38 characters)"""
  addressLine1: String!

  """address line 2 (max 38 characters)"""
  addressLine2: String

  """city (max 30 characters)"""
  city: String!

  """postal code (max 10 characters)"""
  postalCode: String!

  """state (max 30 characters)"""
  state: String

  """country code"""
  country: CCA3!

  """contact first name"""
  firstName: String!

  """contact last name"""
  lastName: String!

  """contact phone number"""
  phoneNumber: PhoneNumber!

  """contact company name (max 38 characters)"""
  companyName: String
}

type CompletedMerchantPaymentLinkStatusInfo implements MerchantPaymentLinkStatusInfo {
  status: MerchantPaymentLinkStatus!

  """The time when the customer completed the payment."""
  completedAt: DateTime!
}

"""
Relay Connection type, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
interface Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """Edge list"""
  edges: [Edge!]!
}

"""
Some sensitive operation at Swan, such as initiating a payment, require consent
"""
type Consent {
  """unique identifier of the consent"""
  id: ID!

  """`true` if the consent requires a Strong Customer Authentication"""
  requireSCA: Boolean!

  """status of the consent"""
  status: ConsentStatus!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime

  """date when the `consentUrl` was request the first time"""
  startedAt: DateTime

  """date when the consent expire"""
  expiredAt: DateTime

  """purpose of the consent"""
  purpose: ConsentPurpose!

  """Redirect the user to this URL to start the consent flow"""
  consentUrl: String!

  """When the consent flow is finished the user is redirected to this URL"""
  redirectUrl: String!

  """userId who initiated the consent"""
  userId: String!

  """user who initiated the consent"""
  user: User

  """unique hash of the consent"""
  challenge: String

  """date when the consent is accepted"""
  acceptedAt: DateTime

  """date when the consent is refused"""
  refusedAt: DateTime

  """date when the consent is canceled"""
  canceledAt: DateTime
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type ConsentConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ConsentEdge list"""
  edges: [ConsentEdge!]!
}

"""Implements the Relay Edge interface"""
type ConsentEdge implements Edge {
  """
  Opaque identifier pointing to this consent node in the pagination mechanism
  """
  cursor: String!

  """The consent"""
  node: Consent!
}

type ConsentOperation {
  props: [ConsentOperationProperty!]
}

type ConsentOperationProperty {
  name: ConsentOperationPropertyName!
  value: String!
}

enum ConsentOperationPropertyName {
  Account
  AccountFrom
  AccountHolderName
  AccountTo
  AllowedIpAddresses
  Amount
  BeneficiaryName
  BirthDate
  BookedDate
  CardDesignURL
  CardHolderName
  CardNumber
  CardOption
  CreditorAddress
  CreditorIdentifier
  CreditorName
  CurrencyExchangeQuoteDurationInBusinessHours
  CurrencyExchangeTargetAmount
  CurrencyExchangeTotalAmount
  DebtorBankName
  DebtorIban
  DebtorName
  DeliveryAddress
  Email
  ExchangeRate
  FirstName
  From
  Iban
  Label
  LastName
  MandateLegalNotice
  MandateReference
  MandateScheme
  MandateSequenceType
  Merchant
  MerchantIdentifier
  Option
  Permissions
  PhoneNumber
  PublicKey
  SignatureDate
  SpendingLimit
  To
  YourAccountNumber
}

"""Purpose of a consent"""
enum ConsentPurpose {
  """when accepting the partnership conditions"""
  AcceptPartnershipConditions

  """when inviting a new account membership"""
  AddAccountMembership

  """when adding several account memberships"""
  AddAccountMemberships

  """when adding a beneficiary"""
  AddBeneficiary

  """when adding a virtual card"""
  AddCard

  """when adding multiple cards"""
  AddCards

  """when adding a digital card"""
  AddDigitalCard

  """when activating a physical card"""
  ActivatePhysicalCard

  """when closing an account"""
  CloseAccount

  """when initiating a credit transfer"""
  InitPayment

  """when requesting to print physical card"""
  PrintPhysicalCard

  """when resuming an account membership"""
  ResumeAccountMembership

  """when resuming a physical card"""
  ResumePhysicalCard

  """when scheduling a standing order"""
  ScheduleStandingOrder

  """when updating an account membership"""
  UpdateAccountMembership

  """when updating a card"""
  UpdateCard

  """when updating a server consent project settings"""
  UpdateServerConsentProjectSettings

  """when viewing card confidential of a virtual card"""
  ViewCardNumbers

  """when requesting to view physical card PIN"""
  ViewPhysicalCardPin

  """when enabling a mandate"""
  EnableMandate

  """when adding a payment direct debit mandate"""
  AddDirectDebitPaymentMandate

  """when initiating a funding request"""
  InitiateFundingRequest

  """when initiating an instant funding request"""
  InitiateInstantFundingRequest

  """when initiating an international credit transfer"""
  InitiateInternationalCreditTransfer

  """when the consent is a multiple consent"""
  ConsentToMultipleConsents

  """when returning a transaction for direct debit"""
  ReturnTransactionForDirectDebit

  """when returning a transaction for international credit transfer"""
  ReturnTransactionForInternationalCreditTransfer
}

type ConsentResponse {
  identityId: ID!
  originIdentityId: ID!
  authenticatorId: ID!
  idVerified: Boolean!
  provider: AuthenticatorType!
  credentialTypeUsed: CredentialType!
  macAddress: String!
  ipAddress: String!
  respondedAt: DateTime
}

"""Status of a consent"""
enum ConsentStatus {
  """when the user accepted"""
  Accepted

  """when the user refused"""
  CustomerRefused

  """when the operation is committing"""
  OperationCommitting

  """
  when the user credentials were refused
  @deprecated this status has never been used and will be removed in the following months
  """
  CredentialRefused @deprecated

  """when the consent is created"""
  Created

  """when the consentUrl has been requested"""
  Started

  """when the consent is expired"""
  Expired

  """when something went wrong"""
  Failed

  """when the user or the project decided to cancel the consent"""
  Canceled
}

type CouldNotFindCapitalDepositCaseRejection implements Rejection {
  id: String!
  message: String!
}

type CouldNotFindCapitalDepositDocumentRejection implements Rejection {
  id: String!
  message: String!
}

type CouldNotRejectCapitalDepositDocumentRejection implements Rejection {
  id: String!
  message: String!
}

type CouldNotUpdateCapitalDepositDocumentStatusRejection implements Rejection {
  id: String!
  message: String!
}

type CouldNotUploadCapitalDepositDocumentRejection implements Rejection {
  id: String!
  message: String!
}

"""Create sandbox identification input payload."""
input CreateSandboxIdentificationInput {
  userId: String!
  process: IdentificationProcess!
  levels: IdentificationLevelStatusesInput!
  errorReasons: [IdentificationInvalidReason!]
}

"""Union of success payload and possible rejections"""
union CreateSandboxIdentificationPayload = CreateSandboxIdentificationSuccessPayload | UserNotFoundRejection | ForbiddenRejection | InvalidIdentificationLevelsRejection | InvalidIdentificationErrorReasonsRejection

"""Success payload type"""
type CreateSandboxIdentificationSuccessPayload {
  """Created sandbox identification"""
  sandboxIdentification: SandboxIdentification!
}

"""Sandbox user input payload."""
input CreateSandboxUserInput {
  """First name"""
  firstName: String!

  """Last name"""
  lastName: String!

  """List of first names"""
  allFirstNames: [String!]

  """Birth date"""
  birthDate: Date!

  """
  [Alpha-3 birth country representation](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  """
  birthCountryCCA3: CCA3

  """
  [Alpha-3 nationality representation](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  Ex: FRA for french nationality
  """
  nationalityCCA3: CCA3!

  """
  Saves you considerable time during the development phase,
  by automatically allowing consent,
  removing the need to repeatedly get consent.
  """
  autoConsent: Boolean!
}

"""Union of success payload and possible rejections"""
union CreateSandboxUserPayload = CreateSandboxUserSuccessPayload | NationalityNotFoundRejection | ForbiddenRejection

"""Success payload type"""
type CreateSandboxUserSuccessPayload {
  """Creates a sandbox user"""
  sandboxUser: SandboxUser!
}

enum CredentialType {
  Pin
  FaceId
  TouchId
}

enum CreditTransferMode {
  InstantWithoutFallback
  InstantWithFallback
  Regular
}

"""currency code alpha 3 (ISO 4217)"""
scalar Currency

type Customer {
  """
  A customer id present in a third-party system.
  Alows to link a customer to a payment link and by extension, to a Merchant Payment.
  """
  externalCustomerId: String
  name: String
  iban: String
}

"""Date with YYYY-MM-DD format"""
scalar Date

type DateField implements Field {
  example: String
  key: String!
  name: String!
  required: Boolean!
  validationRegex: String
}

"""
Date time (ISO 8601 with time information)
ex: 2021-04-12T16:28:22.867Z
"""
scalar DateTime

"""Rejection returned when the Debtor is closed"""
type DebtorAccountClosedRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the Debtor does not belong to the same project as the creditor
"""
type DebtorAccountNotAllowedRejection implements Rejection {
  message: String!
}

"""Input of to delete a sandbox user"""
input DeleteSandboxUserInput {
  """Id of the sandbox user to delete"""
  id: String!
}

"""Union of the success payload and possible rejections"""
union DeleteSandboxUserPayload = DeleteSandboxUserSuccessPayload | ForbiddenRejection | LastSandboxUserCannotBeDeletedRejection | SandboxUserNotFoundRejection

type DeleteSandboxUserSuccessPayload {
  """Success flag"""
  success: Boolean!
}

interface DetailedConsent {
  id: ID!
  projectId: String
  requireSCA: Boolean!
  status: ConsentStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  startedAt: DateTime
  expiredAt: DateTime
  acceptedAt: DateTime
  refusedAt: DateTime
  canceledAt: DateTime
  consentResponses: [ConsentResponse!]!
  purpose: DetailedConsentPurpose!
  consentOperations: [ConsentOperation!]!
  env: EnvType!
  identityId: String! @deprecated(reason: "use userId, which can be null in the oAuth2 consent case")
  userId: String
  state: String
  branding: Branding!
  operationsSHA256HexDigest: String
  challenge: String
}

"""Purpose of a consent"""
enum DetailedConsentPurpose {
  """when accepting the partnership conditions"""
  AcceptPartnershipConditions

  """when inviting a new account membership"""
  AddAccountMembership

  """when adding several account memberships"""
  AddAccountMemberships

  """when adding a beneficiary"""
  AddBeneficiary

  """when adding a virtual card"""
  AddCard

  """when adding multiple cards"""
  AddCards

  """when adding a digital card"""
  AddDigitalCard

  """when activating a physical card"""
  ActivatePhysicalCard

  """when closing an account"""
  CloseAccount

  """when initiating a credit transfer"""
  InitPayment

  """when requesting to print physical card"""
  PrintPhysicalCard

  """when resuming an account membership"""
  ResumeAccountMembership

  """when resuming a physical card"""
  ResumePhysicalCard

  """when scheduling a standing order"""
  ScheduleStandingOrder

  """when updating an account membership"""
  UpdateAccountMembership

  """when updating a card"""
  UpdateCard

  """when viewing card confidential of a virtual card"""
  ViewCardNumbers

  """when requesting to view physical card PIN"""
  ViewPhysicalCardPin

  """to update server consent settings on project"""
  UpdateServerConsentProjectSettings

  """when enabling a mandate"""
  EnableMandate

  """when adding a payment direct debit mandate"""
  AddDirectDebitPaymentMandate

  """when initiating a funding request"""
  InitiateFundingRequest

  """when initiating an instant funding request"""
  InitiateInstantFundingRequest

  """when initiating an international credit transfer"""
  InitiateInternationalCreditTransfer

  """if the consent is a multiple consent"""
  ConsentToMultipleConsents

  """when returning a transaction for direct debit"""
  ReturnTransactionForDirectDebit

  """when returning a transaction for international credit transfer"""
  ReturnTransactionForInternationalCreditTransfer

  """
  if the consent originates from a oauth2 flow, the purpose should be determined from its scopes
  """
  OAuth2

  """if the consent originates from a 3DS flow"""
  ThreeDsPayment
}

"""Input to decide on digitalization"""
input DigitalizationInput {
  """The card id to provision"""
  cardId: String!

  """Type of card"""
  cardType: CardType!

  """Response from swan to the provisioning request"""
  provisioningResponse: ProvisioningResponse!

  """Type of card"""
  responseChannel: ResponseChannel!

  """Wallet Provider (ApplePay, GooglePay ...)"""
  walletProvider: WalletProviderType
}

"""Direct Debit Account Verification"""
type DirectDebitAccountVerification implements AccountVerification {
  """Creation date of the account verification"""
  createdAt: DateTime!

  """IBAN of the account to cross check with account holder information"""
  iban: IBAN!

  """Unique identifier of the Account Verification"""
  id: ID!

  """Account Verification Status Information"""
  statusInfo: AccountVerificationStatusInfo!

  """Last update date of the account verification"""
  updatedAt: DateTime!
}

"""StatusInfo when funding limit settings has been disabled"""
type DisabledFundingLimitSettingsStatusInfo implements FundingLimitSettingsStatusInfo {
  status: FundingLimitSettingsStatus!
  reason: String!
}

"""EnabledMerchantPaymentMethodStatusInfo"""
type DisabledMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method disabled date"""
  disabledAt: Date!
}

"""DisabledMerchantProfileStatusInfo"""
type DisabledMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  disabledAt: Date!
}

"""Rejection returned if the document cannot be found"""
type DocumentCanNotBeFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Rejection returned if the document cannot be rejected"""
type DocumentCanNotBeRejectedRejection implements Rejection {
  id: String!
  message: String!
}

"""Retrieved document extracted from the identity verification"""
interface DocumentFile {
  downloadUrl: String!
}

"""From which side the document picture was taken"""
enum DocumentFileSide {
  SideA
  SideB
  BothSides
  Unknown
}

"""Rejection returned if the document-parent link is missing"""
type DocumentParentLinkMissingRejection implements Rejection {
  id: String!
  message: String!
}

"""Reason code of the document."""
enum DocumentReasonCode {
  """Company name in document doesn’t match our records"""
  CompanyNameMismatch

  """Declared amount in document doesn’t match the amount received"""
  DeclaredAmountMismatch

  """Document must be dated less than 3 months ago"""
  ExpiredDocument

  """Address in document doesn’t match our records"""
  InvalidAddress

  """Default value when none of the other values is appropriate"""
  InvalidDocument

  """Some information is missing"""
  InvalidOrMissingData

  """Missing identity document of accommodation provider"""
  MissingAccommodationProviderId

  """
  Missing identity document and proof of accommodation from accommodation provider
  """
  MissingAccommodationProviderIdLetter

  """Missing proof of accommodation from accommodation provider"""
  MissingAccommodationProviderLetter

  """Document cannot be accepted for the requested document type"""
  UnacceptableDocument

  """Accommodation provider's identity document must be in full color"""
  ProviderColorIdDocumentRequired

  """
  Document must be signed, either by hand or electronically with certification
  """
  MissingSignature

  """Document is damaged or in poor condition"""
  BadDocumentQuality

  """Only part of the document was provided"""
  FullDocumentRequired

  """Missing accommodation provider's proof of address"""
  MissingProviderProofOfAddress

  """Missing accommodation provider's proof of address and ID document"""
  MissingProviderProofOfAddressAndIdDocument

  """Power of attorney must be provided to Swan"""
  PowerOfAttorneyToSwanRequired

  """Missing company domiciliation statement"""
  MissingCompanyDomiciliationStatement

  """The signature is not handwritten or electronically certified"""
  HandwrittenOrCertifiedElectronicSignatureRequired
}

"""The type of the document"""
enum DocumentType {
  IdCard
  Passport
  ResidencePermit
  DriversLicense
  Face
  Report
}

"""The document corresponding to a driver's license"""
type DriversLicenseDocument {
  """Unique identifier of the driver's license document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """List of the associated files"""
  files: [DriversLicenseDocumentFile!]!
}

"""The file associated to the driver's license document"""
type DriversLicenseDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!

  """From which side the deiver's license's picture was taken"""
  side: DocumentFileSide!
}

"""
Edge type containing the node and cursor. The node is not defined in the interface because generic is not supported by GraphQL
but all implementation contains its own node property according to the paginated type.
"""
interface Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

scalar EmailAddress

"""Employment status."""
enum EmploymentStatus {
  Craftsman
  Employee
  Entrepreneur
  Farmer
  Manager
  Practitioner
  Retiree
  ShopOwner
  Student
  Unemployed
}

"""StatusInfo when the funding limit settings is enabled"""
type EnabledFundingLimitSettingsStatusInfo implements FundingLimitSettingsStatusInfo {
  status: FundingLimitSettingsStatus!
}

"""EnabledMerchantPaymentMethodStatusInfo"""
type EnabledMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method enabled date"""
  enabledAt: Date!
}

"""EnabledMerchantProfileStatusInfo"""
type EnabledMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  enabledAt: Date!
}

type EndorseSandboxUserDummyRejection implements Rejection {
  message: String!
}

"""Input of the sandbox user you want to be logged as"""
input EndorseSandboxUserInput {
  """Sandbox user ID"""
  id: String!
}

"""Union of the success payload and possible rejections"""
union EndorseSandboxUserPayload = EndorseSandboxUserSuccessPayload | ForbiddenRejection | SandboxUserNotFoundRejection

"""Success payload type"""
type EndorseSandboxUserSuccessPayload {
  sandboxUser: SandboxUser!
}

type EnrichedTransactionInfo {
  """Well formatted merchant name"""
  enrichedMerchantName: String

  """URL of the merchant logo"""
  logoUrl: String

  """Merchant category"""
  category: MerchantCategory

  """Merchant subcategory"""
  subcategory: MerchantSubCategory

  """Merchant country"""
  country: CCA3

  """Merchant city"""
  city: String

  """Merchant address"""
  address: String

  """Merchant location longitude"""
  longitude: String

  """Merchant location latitude"""
  latitude: String

  """Merchant postal code"""
  postalCode: String

  """Is merchant a subcription"""
  isSubscription: Boolean

  """Transaction carbon footprint in micrograms of CO2 emitted"""
  carbonFootprint: String

  """Merchant email"""
  contactEmail: String

  """Merchant phone"""
  contactPhone: String

  """Merchant website"""
  contactWebsite: String
}

enum EnvType {
  Live
  Sandbox
}

"""
Describes an identification level for the process associated to this identification that has expired and is no longer considered valid
"""
type ExpiredIdentificationLevelStatusInfo {
  """Always set to `Expired`"""
  status: SwanIdentificationStatus!

  """When this identification level expired"""
  expiredAt: Date!
}

type ExpiredMerchantPaymentLinkStatusInfo implements MerchantPaymentLinkStatusInfo {
  status: MerchantPaymentLinkStatus!

  """
  The date when the payment link expired.
  By default the payment link expires 120 days after it was created.
  """
  expiredAt: DateTime!
}

type ExternalCard {
  """The card scheme"""
  scheme: CardPaymentMandateScheme!

  """The local card scheme"""
  localScheme: CardPaymentMandateScheme

  """deprecated: The card type"""
  cardType: CardPaymentMandateType @deprecated(reason: "The cardType field is deprecated, use the type field instead")

  """The card type"""
  type: CardPaymentMandateType

  """The card category"""
  category: CardPaymentMandateCategory

  """The card's bank country"""
  country: CCA2

  """The card's last digits"""
  lastDigits: String!

  """The card's first 6 digits - Bank Identification Number"""
  bin: String!

  """The card's expiry date"""
  expiryDate: String
}

"""The document corresponding to a face photo"""
type FacePhotoDocument {
  """
  Unique identifier of the face photo document. For privacy reasons, no temporary download url is exposed for this document
  """
  id: String!

  """The type of the document"""
  type: DocumentType!
}

type FailedThreeDs {
  status: ThreeDsStatus!
  reason: String!
  code: String!
}

interface Field {
  key: String!
  name: String!
  required: Boolean!
}

enum FieldValidationError {
  Missing
}

enum FNCIResult {
  PositiveGreen
  IrregularRed
  IrregularOrange
  IrregularWhite
}

type ForbiddenRejection implements Rejection {
  message: String!
}

type FundingLimit {
  """Maximum Funding Amount authorized"""
  amount: Amount!

  """Funding Amount that has already been used during the interval"""
  funding: Amount

  """Interval in number of calendar days where the limit is applied"""
  rollingDays: Int!
}

"""Funding Limit Amount"""
type FundingLimitAmount {
  """The amount settings"""
  amount: Amount!
}

"""Funding Limit Amount Input"""
input FundingLimitAmountInput {
  """The amount settings"""
  amount: AmountInput!
}

"""Rejection returned when the Account Holder Funding has been exceeded"""
type FundingLimitExceededRejection implements Rejection {
  message: String!
}

type FundingLimitSettings {
  """Instant funding limit"""
  instantFundingLimit: InstantFundingLimit

  """Periodic funding limit"""
  fundingLimit: FundingLimit

  """Related change request"""
  fundingLimitSettingsChangeRequest: FundingLimitSettingsChangeRequest

  """Status of the resource"""
  statusInfo: FundingLimitSettingsStatusInfo!
}

"""Funding Limit Settings Change Request"""
type FundingLimitSettingsChangeRequest {
  """Unique identifier of a funding limit settings change request"""
  id: ID!

  """Requested amount settings for the instant funding limit"""
  instantFundingLimit: FundingLimitAmount!

  """Requested amount settings for the funding limit"""
  fundingLimit: FundingLimitAmount!

  """
  Approved amount settings for the the instant funding limit and the funding limit
  """
  approved: ApprovedFundingLimit

  """Status of the request"""
  statusInfo: FundingLimitSettingsChangeRequestStatusInfo!

  """Date of creation"""
  createdAt: Date

  """Date of last update"""
  updatedAt: Date
}

"""
StatusInfo when funding limit settings change request has been approved
"""
type FundingLimitSettingsChangeRequestApprovedStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
  reason: String!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type FundingLimitSettingsChangeRequestConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """FundingLimitSettingsChangeRequestEdge list"""
  edges: [FundingLimitSettingsChangeRequestEdge!]!
}

"""Implements the Relay Edge interface"""
type FundingLimitSettingsChangeRequestEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The FundingLimitSettingsChangeRequest"""
  node: FundingLimitSettingsChangeRequest!
}

"""
Filters that can be applied when listing funding limit settings change requests
"""
input FundingLimitSettingsChangeRequestFiltersInput {
  """Filter by IDs"""
  id: [String!]

  """Filter by status"""
  status: [FundingLimitSettingsChangeRequestStatus!]
}

type FundingLimitSettingsChangeRequestNotFoundRejection implements Rejection {
  message: String!
}

"""
Field we can use when ordering that can be applied when listing funding limit settings change requests
"""
enum FundingLimitSettingsChangeRequestOrderByFieldInput {
  id
  createdAt
  updatedAt
}

"""
Order that can be applied when listing funding limit settings change requests
"""
input FundingLimitSettingsChangeRequestOrderByInput {
  field: FundingLimitSettingsChangeRequestOrderByFieldInput
  direction: OrderByDirection
}

"""StatusInfo when funding limit settings change request is pending"""
type FundingLimitSettingsChangeRequestPendingStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
}

"""
StatusInfo when funding limit settings change request has been rejected
"""
type FundingLimitSettingsChangeRequestRefusedStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
  reason: String!
}

"""Funding Limit Settings Change Request Status"""
enum FundingLimitSettingsChangeRequestStatus {
  """When the request is in waiting for information"""
  WaitingForInformation

  """When the request is in pending"""
  Pending

  """When the request is approved"""
  Approved

  """When the request is refused"""
  Refused
}

"""
Object containing details about funding limit settings change request status
"""
interface FundingLimitSettingsChangeRequestStatusInfo {
  """Current limit settings change request status."""
  status: FundingLimitSettingsChangeRequestStatus!
}

type FundingLimitSettingsChangeRequestStatusNotAllowedRejection implements Rejection {
  message: String!
}

"""
StatusInfo when funding limit settings change request is waiting for more information
"""
type FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
}

"""Possible values for funding limit settings status"""
enum FundingLimitSettingsStatus {
  """When the funding limit settings is enabled"""
  Enabled

  """When the funding limit settings is suspended"""
  Suspended

  """When the funding limit settings is disabled"""
  Disabled
}

"""Object containing details about funding limit settings status"""
interface FundingLimitSettingsStatusInfo {
  """Current funding limit settings."""
  status: FundingLimitSettingsStatus!
}

"""Funding Source"""
interface FundingSource {
  """ID of the Funding Source"""
  id: ID!

  """Name of the Funding Source"""
  name: String

  """Funding Source status information"""
  statusInfo: FundingSourceStatusInfo!

  """Created date"""
  createdAt: DateTime!

  """Last updated date"""
  updatedAt: DateTime!
}

type FundingSourceNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Funding Source Statuses"""
enum FundingSourceStatus {
  Pending
  Enabled
  Canceled
  Rejected
  Suspended
}

"""Funding Source status information"""
interface FundingSourceStatusInfo {
  """Funding Source Pending status"""
  status: FundingSourceStatus!
}

"""
Rejection returned when the Funding Source is not in the expected status
"""
type FundingSourceWrongStatusRejection implements Rejection {
  message: String!
  currentStatus: FundingSourceStatus!
  expectedStatus: FundingSourceStatus!
}

"""GenerateCheckInput"""
input GenerateCheckInput {
  fnciResult: FNCIResult
}

union GenerateCheckPayload = GenerateCheckSuccessPayload | InternalErrorRejection

"""GenerateCheckSuccessPayload"""
type GenerateCheckSuccessPayload {
  """
  31-character unique identifier.
  CMC7 is composed of 3 sections (check number (7 char.), check issuing bank code (12 char.), check holder account number (12 char.)).
  Combined with RLMC key, it  allows the check traceability.
  """
  cmc7: String!

  """
  2-digit key used to check the integrity of the CMC7 line.
  Combined with CMC7 line, it allows the check traceability.
  """
  rlmcKey: String!
}

"""Rejection returned when the Global Funding has been exceeded"""
type GlobalFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the Global Instant Funding limit has been exceeded
"""
type GlobalInstantFundingLimitExceededRejection implements Rejection {
  message: String!
}

scalar HexColorCode

"""International Bank Account Number"""
scalar IBAN

"""Rejection returned when the IBAN is not reachable"""
type IBANNotReachableRejection implements Rejection {
  message: String!
}

"""Rejection returned when the IBAN is not valid"""
type IBANNotValidRejection implements Rejection {
  message: String!
}

"""Virtual IBAN Status"""
enum IBANStatus {
  """When the virtual IBAN accept to receive Sepa payments"""
  Enabled

  """When the virtual IBAN refuse definitely to receive Sepa payments"""
  Canceled

  """When the virtual IBAN refuse temporarily to receive Sepa payments"""
  Suspended
}

"""The document corresponding to an ID card"""
type IdCardDocument {
  """Unique identifier of the ID card document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """The date at which the ID card was issued"""
  issueDate: Date

  """The date at which the ID card expires"""
  expiryDate: Date

  """Machine-readable zone code of the ID card"""
  mrz: String

  """Number of the ID card"""
  number: String

  """List of the associated files"""
  files: [IdCardDocumentFile!]!
}

"""The file associated to the ID card document"""
type IdCardDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!

  """From which side the ID card's picture was taken"""
  side: DocumentFileSide!
}

"""
The identification represents an ongoing identification process or its result
"""
type Identification {
  """Unique identifier of the identification"""
  id: String!

  """Creation date of the identification"""
  createdAt: DateTime!

  """Last update date of the identification"""
  updatedAt: DateTime!

  """The global status of the identification"""
  status: SwanIdentificationStatus!

  """The process that was used for this identification"""
  process: IdentificationProcess!

  """
  The status and results associated to the available identification processes
  """
  levels: IdentificationLevelStatusesInfo!

  """
  The available documents related to the identification (id doc, selfie, report...)
  """
  documents: [IdentificationDocument!]

  """
  The identity document type used for the current identification (passport, id card ...)
  """
  identityDocumentType: IdentityDocumentType
}

"""
Fields we can use when ordering that can be applied when listing identifications
"""
type IdentificationConnection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """IdentificationEdge list"""
  edges: [IdentificationEdge!]!
}

"""Union representing all the possible identification document types"""
union IdentificationDocument = IdCardDocument | PassportDocument | ResidencePermitDocument | DriversLicenseDocument | FacePhotoDocument | ReportDocument

"""Implements the Relay Edge interface"""
type IdentificationEdge implements Edge {
  """The identification entry"""
  node: Identification!

  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

"""
If requested by sending the right parameters to the initial oauth2 url,
it contains the identification level that is requested to be fulfilled
after the oauth2 consent by starting the right identification.

QES => use the `startFourthlineExpertIdVerificationIdentification` mutation

Expert => use the `startUbbleExpertIdVerificationIdentification` mutation

PVID => use the `startUbblePvidIdVerificationIdentification` mutation

Auto => use query `recommendedIdentificationFlow` to let Swan recommend the best flow and level for a user
"""
enum IdentificationFlowLevel {
  Auto
  Expert
  PVID
  QES
}

"""The various reasons that can lead to an invalid identification level"""
enum IdentificationInvalidReason {
  """Face must be fully present in the photo"""
  AbsentOrIncompleteFace

  """Applicant used a device that has been technically altered / modified"""
  AlteredDevice

  """Light on actual document is insufficient"""
  BadDocumentLighting

  """
  Something about the document is damaged (could be as tiny as a bent corner)
  """
  DamagedDocument

  """Expiry date of document has passed"""
  ExpiredDocument

  """Attempt to commit fraud detected"""
  FraudDetected

  """
  Video quality isn’t sufficient or video is missing required information
  """
  InadequateVideo

  """Lighting on applicant’s face is insufficient"""
  InsufficientApplicantLighting

  """Applicant isn’t meeting movement requirements"""
  InsufficientApplicantLiveness

  """Internet connection quality is insufficient"""
  InsufficientConnectionQuality

  """Video of document doesn’t meet movement requirements"""
  InsufficientDocumentLiveness

  """Document is blurry or otherwise distorted"""
  InsufficientDocumentReadability

  """Face is blurry or otherwise distorted"""
  InsufficientFaceReadability

  """Video is blurry or otherwise distorted"""
  InsufficientVideoReadability

  """There was a technical error"""
  InternalError

  """Address is not valid or accepted"""
  InvalidAddress

  """Identification data is invalid or missing"""
  InvalidOrMissingData

  """Applicant seems to be doing verification against their will"""
  InvoluntaryIdentification

  """Geolocation data is required but not available"""
  MissingGeolocationData

  """Applicant appears on unacceptable news list"""
  NegativeNewsHit

  """Applicant’s identity does not match the expected ID info"""
  NonMatchingIdentity

  """Applicant presented a duplicate of the document (digital or paper)"""
  NonOriginalDocument

  """Applicant appears on a sanctions list"""
  SanctionListHit

  """Applicant required to provide a second document"""
  SecondDocumentRequired

  """There was a technical error with the electronic signature process"""
  TechnicalSignatureError

  """The time to complete the signature timed out"""
  TimeoutSignatureFlow

  """Document not on list of acceptable document types"""
  UnacceptableDocument

  """Applicant is under the minimum required age"""
  UnderageApplicant
}

"""Possible value for the field IdentificationLevel"""
enum IdentificationLevel {
  """Human identity verification"""
  Expert

  """Identity verification with Qualified Electronic Signature"""
  QES

  """Identity verification with PVID"""
  PVID
}

"""Identification levels"""
type IdentificationLevels {
  PVID: Boolean!
  QES: Boolean!
  expert: Boolean!
}

"""
The status and results associated to the available identification processes
"""
type IdentificationLevelStatusesInfo {
  """The status and results associated to the expert level"""
  expert: IdentificationLevelStatusInfo!

  """
  The status and results associated to the Qualified Electronic Signature level
  """
  qes: IdentificationLevelStatusInfo!

  """
  The status and results associated to the Remote Identity Verification Service level
  """
  pvid: IdentificationLevelStatusInfo!
}

input IdentificationLevelStatusesInput {
  expert: SwanIdentificationStatus
  pvid: SwanIdentificationStatus
  qes: SwanIdentificationStatus
}

"""
Union representing all the possible statuses: not supported, not started, pending, valid, invalid, cancelled, expired
Each variant contains its relevant data, for example invalid contains a `reason` field, expired contains an `expiredAt` field, valid contains a `documents` field
"""
union IdentificationLevelStatusInfo = NotSupportedIdentificationLevelStatusInfo | NotStartedIdentificationLevelStatusInfo | StartedIdentificationLevelStatusInfo | PendingIdentificationLevelStatusInfo | ValidIdentificationLevelStatusInfo | InvalidIdentificationLevelStatusInfo | CanceledIdentificationLevelStatusInfo | ExpiredIdentificationLevelStatusInfo

"""Process of the identification"""
enum IdentificationProcess {
  """Identity verified by an expert"""
  Expert

  """
  Identity verified by an expert and a Qualified Electronic Signature has been done
  """
  QES

  """
  Identity verified by an expert with a Remote Identity Verification Service
  """
  PVID
}

"""The type of the identity document"""
enum IdentityDocumentType {
  IdCard
  Passport
  ResidencePermit
  DriversLicense
}

"""Input to decide on digitalization"""
input InAPpDigitalizationInput {
  """The ID of a InApp Pending DigitalCard"""
  digitalCardId: String!

  """Response from swan to the provisioning request"""
  provisioningResponse: ProvisioningResponse!

  """Type of card"""
  responseChannel: ResponseChannel!
}

enum IncomingCheckRejectionReasonCodeEnum {
  BeneficiaryMissingOrIncorrect
  DateMissing
  DateInvalid
  EndorsementMissing
  InvalidOrMissingAmount
  SignatureMissing
  DebtorNameMissing
  AmountMismatch
  CheckReceivedLate
  CheckNotReceived
}

enum IncomingInternalDirectDebitRejectionReasonCodeEnum {
  AccountClosed
  InsufficientFunds
  ReasonNotSpecifiedByDebtor
}

enum IncomingInternalDirectDebitReturnReasonCodeEnum {
  ReasonNotSpecifiedByBank
  ReasonNotSpecifiedByDebtor
  RefundRequestedByDebtor
  RegulatoryReason
}

"""Reason codes for returning an incoming international transfer"""
enum IncomingInternationalCreditTransferReturnReasonCode {
  BeneficiaryAccountBlocked
  BeneficiaryAccountClosed
  BeneficiaryAccountUnknown
  BeneficiaryDeceased
  ReasonNotSpecifiedByBank
  ReasonNotSpecifiedByBeneficiary
  RegulatoryReason
  TransactionDuplicated
  TransactionOnAccountTypeNotAllowed
}

"""Inputs for SEPA credit transfer"""
input IncomingSepaCreditTransferInput {
  """Credit transfer amount input"""
  amount: AmountInput!

  """Creditor address input"""
  creditorAddress: AddressInput

  """
  Creditor IBAN. Your Swan IBAN if you want to receive a credit transfer in your Swan account
  """
  creditorIban: IBAN!

  """Creditor name"""
  creditorName: String!

  """Debtor address input"""
  debtorAddress: AddressInput

  """Debtor IBAN. It should be a valid IBAN"""
  debtorIban: IBAN!

  """Debtor name"""
  debtorName: String!

  """
  SEPA end to end reference. This information can't be updated once it's persisted.
  """
  endToEndId: SepaReference

  """Displayed label in Swan account"""
  label: String

  """
  Indicates that the transfer is received as an instant SEPA Credit transfer
  """
  isInstant: Boolean
}

enum IncomingSepaDirectDebitRejectionReasonCodeEnum {
  AccountClosed
  InsufficientFunds
  ReasonNotSpecifiedByDebtor
}

enum IncomingSepaDirectDebitReturnReasonCodeEnum {
  AccountClosed
  InsufficientFunds
  ReasonNotSpecifiedByDebtor
}

"""Rejection returned if the transaction was of incorrect type"""
type IncorrectTransactionTypeRejection implements Rejection {
  message: String!
}

"""Individual shareholder info."""
type IndividualShareholder {
  """Whether the shareholder is an individual or a company."""
  type: ShareholderType!

  """First name of the shareholder."""
  firstName: String!

  """Last name of the shareholder."""
  lastName: String!

  """Birth date of the shareholder."""
  birthDate: String!

  """CCA3 code for the country of nationality of the shareholder."""
  nationality: CCA3!
}

"""
Individual Ultimate Beneficial Owner
You need to describe the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company.
Please describe the company (s) that owns the company that wishes to open an account, when an individual holds in fine more than 25%
"""
type IndividualUltimateBeneficialOwner {
  """individual first name"""
  firstName: String

  """individual last name"""
  lastName: String

  """individual birth date"""
  birthDate: DateTime

  """individual birth city"""
  birthCity: String

  """individual birth city postal code"""
  birthCityPostalCode: String

  """individual birth country code"""
  birthCountryCode: CCA3

  """Information relating to the type of the UBO"""
  info: IndividualUltimateBeneficialOwnerInfo!

  """Individual beneficial owner Tax or Identification Number"""
  taxIdentificationNumber: String

  """Individual beneficial owner residency Address"""
  residencyAddress: AddressInformation

  """Individual beneficial owner title (Mr/Ms)"""
  title: TitleEnum

  """Ultimate beneficial owner's identity document details"""
  identityDocumentDetails: UBOIdentityDocumentDetails
}

"""Define the type of the UBO"""
interface IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!
}

input IndividualUltimateBeneficialOwnerInput {
  """
  Individual beneficial owner first name. Length must be from 0 to 100 characters
  """
  firstName: String

  """
  Individual beneficial owner last name. Length must be from 0 to 100 characters
  """
  lastName: String

  """Individual birth date. Must be a valid date in the YYYY/MM/DD format"""
  birthDate: String

  """Individual birth city. Length must be from 0 to 100 characters"""
  birthCity: String

  """
  Individual birth city postal code. Length must be from 0 to 50 characters
  """
  birthCityPostalCode: String

  """Individual birth country code"""
  birthCountryCode: CCA3

  """Define UBO is an Indirect Owner"""
  indirect: Boolean

  """Define UBO is a Direct Owner"""
  direct: Boolean

  """
  Total of capital (in percentage, ex: 50 = 50%). Must be between 1 and 100.
  """
  totalCapitalPercentage: Float

  """Define UBO is a Legal Representative"""
  type: IndividualUltimateBeneficialOwnerTypeEnum

  """Individual beneficial owner Tax or Identification Number"""
  taxIdentificationNumber: String

  """Individual beneficial owner residency address"""
  residencyAddress: ResidencyAddressInput

  """Individual ultimate beneficial owner title (Mr/Ms)"""
  title: TitleEnum

  """Ultimate beneficial owner's identity document details"""
  identityDocumentDetails: UBOIdentityDocumentDetailsInput
}

"""Individual Ultimate beneficial owner nature"""
enum IndividualUltimateBeneficialOwnerTypeEnum {
  """The Beneficial Owner is the representant legal"""
  LegalRepresentative

  """The Beneficial Owner have shares"""
  HasCapital

  """Other"""
  Other
}

"""Individual Ultimate Beneficial Owner Type Has Capital"""
type IndividualUltimateBeneficialOwnerTypeHasCapital implements IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!

  """Define UBO is an Indirect Owner"""
  indirect: Boolean

  """Define UBO is an Direct Owner"""
  direct: Boolean

  """Total of capital (in percentage, ex: 50 = 50%)"""
  totalCapitalPercentage: Float
}

"""Individual Ultimate Beneficial Owner Type Legal Representative"""
type IndividualUltimateBeneficialOwnerTypeLegalRepresentative implements IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!
}

"""Individual Ultimate Beneficial Owner Type Other"""
type IndividualUltimateBeneficialOwnerTypeOther implements IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!
}

type InstantFundingLimit {
  """Maximum Instant Funding Amount authorized"""
  amount: Amount!

  """Instant Funding Amount that has already been used"""
  funding: Amount
}

"""
Rejection returned when the Account Holder Instant Funding limit has been exceeded
"""
type InstantFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""Rejection returned when the Available balance is insufficient"""
type InsufficientFundsRejection implements Rejection {
  message: String!
}

"""InternalDirectDebitB2BMerchantPaymentMethod"""
type InternalDirectDebitB2BMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

interface InternalDirectDebitMandate {
  """
  Unique identifier of the internal received direct debit mandate, generated by Swan
  """
  id: ID!
}

"""InternalDirectDebitStandardMerchantPaymentMethod"""
type InternalDirectDebitStandardMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

"""Rejection returned on unexpected server error"""
type InternalErrorRejection implements Rejection {
  message: String!
}

"""Payment direct debit mandate for Internal"""
type InternalPaymentDirectDebitMandate implements InternalDirectDebitMandate & PaymentDirectDebitMandate & PaymentMandate {
  """Unique identifier of the Internal Direct Debit Payment Mandate"""
  id: ID!

  """Unique reference of the Internal Direct Debit Payment Mandate"""
  reference: String!

  """Internal Direct Debit Payment Mandate scheme"""
  scheme: InternalPaymentMandateScheme!

  """Internal Direct Debit Payment Mandate status information"""
  statusInfo: PaymentMandateStatusInfo!

  """Internal Direct Debit Payment Mandate sequence"""
  sequence: PaymentMandateSequence!

  """Internal Direct Debit Payment Mandate PDF document URL"""
  mandateDocumentUrl: String!

  """Internal Direct Debit Payment Mandate debtor information"""
  debtor: InternalPaymentMandateDebtor!

  """Internal direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """Internal Direct Debit Payment Mandate creditor information"""
  creditor: InternalPaymentMandateCreditor!

  """Signature date of the Internal Direct Debit Payment Mandate"""
  signatureDate: Date

  """Creation date of the Internal Direct Debit Payment Mandate"""
  createdAt: DateTime!

  """Last Update date of the Internal Direct Debit Payment Mandate"""
  updatedAt: DateTime!

  """
  Date of the the last transaction executed for the concerned Internal Direct Debit Payment Mandate
  """
  executedAt: DateTime

  """Expiry date of the Internal Direct Debit Payment Mandate"""
  expiredAt: Date

  """Account Holder information"""
  accountHolder: AccountHolder!

  """Language that will be used to produce the mandate PDF document"""
  language: String!

  """Custom name of the mandate"""
  name: String
}

type InternalPaymentMandateCreditor implements PaymentMandateCreditor {
  """Internal Direct Debit Payment Mandate creditor UUID"""
  id: ID!

  """Internal Direct Debit Payment Mandate Creditor Idenfier"""
  identifier: ID!

  """Internal Direct Debit Payment Mandate creditor name"""
  name: String!

  """Internal Direct Debit Payment Mandate creditor address"""
  address: Address!
}

type InternalPaymentMandateDebtor implements PaymentMandateDebtor {
  """Internal Direct Debit Payment Mandate debtor name"""
  name: String!

  """Internal Direct Debit Payment Mandate debtor e-mail"""
  email: String!

  """Internal Direct Debit Payment Mandate debtor country"""
  country: CCA3!

  """
  Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries
  """
  address: Address

  """
  Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries
  """
  accountId: ID
}

enum InternalPaymentMandateScheme {
  """Internal Direct Debit Standard"""
  InternalDirectDebitStandard

  """Internal Direct Debit B2B"""
  InternalDirectDebitB2b
}

"""Received direct debit mandate for SEPA"""
type InternalReceivedDirectDebitMandate implements ReceivedDirectDebitMandate & InternalDirectDebitMandate {
  """
  Unique identifier of the received internal direct debit mandate, generated by Swan
  """
  id: ID!

  """Version of the received internal direct debit mandate"""
  version: String!

  """Creation date of the received internal direct debit mandate"""
  createdAt: DateTime!

  """Last Update date of the received internal direct debit mandate"""
  updatedAt: DateTime!

  """Received internal direct debit Unique Mandate Reference (UMR)"""
  reference: String!

  """Received internal direct debit mandate scheme"""
  scheme: InternalReceivedDirectDebitMandateScheme!

  """Received internal direct debit mandate sequence"""
  sequence: InternalReceivedDirectDebitMandateSequence!

  """Received internal direct debit creditor"""
  creditor: InternalReceivedDirectDebitMandateCreditor!

  """Received internal direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """
  Date of the last internal direct debit transaction executed for the concerned received internal direct debit mandate
  """
  executedAt: DateTime

  """Date of signature of the received internal direct debit mandate"""
  signatureDate: Date

  """
  Expiry date of the received internal direct debit mandate, computed automatically (36 months from the executedAt date)
  """
  expiredAt: Date

  """
  Mandate status information of the received internal direct debit mandate
  """
  statusInfo: ReceivedDirectDebitMandateStatusInfo!

  """Account of the received internal direct debit mandate debtor"""
  account: Account

  """Iban of the received internal direct debit mandate debtor"""
  iban: IBAN!

  """Mandate name"""
  name: String
}

"""Internal received direct debit mandate creditor"""
type InternalReceivedDirectDebitMandateCreditor {
  """Creditor identifier"""
  identifier: String!

  """Name of the creditor"""
  name: String!

  """Address of the creditor"""
  address: Address!
}

"""Received internal direct debit mandate scheme"""
enum InternalReceivedDirectDebitMandateScheme {
  """
  When the received internal direct debit mandate can only be used for internal B2B direct debit transactions
  """
  InternalDirectDebitB2b

  """
  When the received internal direct debit mandate can only be used for internal Standard direct debit transactions
  """
  InternalDirectDebitStandard
}

"""Internal received direct debit mandate sequence"""
enum InternalReceivedDirectDebitMandateSequence {
  """
  When the authorisation is given once by the Debtor to collect only one single internal direct debit
  """
  OneOff

  """
  When the authorisation by the Debtor can be used for regular internal direct debits initiated by the Creditor
  """
  Recurrent
}

"""Rejection returned on invalid argument error"""
type InvalidArgumentRejection implements Rejection {
  message: String!
  code: InvalidArgumentRejectionCode!
  fields: [InvalidArgumentRejectionField!]!
}

enum InvalidArgumentRejectionCode {
  INVALID_INPUT
}

type InvalidArgumentRejectionField {
  name: String!
  errors: [String!]!
}

type InvalidIdentificationErrorReasonsRejection implements Rejection {
  message: String!
}

type InvalidIdentificationLevelsRejection implements Rejection {
  message: String!
}

"""
Describes an invalid identification level for the process associated to this identification, and the invalid reason can be accessed
"""
type InvalidIdentificationLevelStatusInfo {
  """Always set to `Invalid`"""
  status: SwanIdentificationStatus!

  """The reasons why this identification level is invalid"""
  reasons: [IdentificationInvalidReason!]
}

"""Rejection returned if phone number is not well formatted"""
type InvalidPhoneNumberRejection implements Rejection {
  message: String!
}

"""Invoice"""
type Invoice {
  """unique id"""
  id: ID!

  """account id"""
  accountId: ID!

  """name of the invoice"""
  name: String!

  """type of the invoice"""
  type: InvoiceType!

  """status of the invoice"""
  status: InvoiceStatus!

  """due amount"""
  amount: Amount!

  """temporary public url on which the file can be accessible"""
  url: String

  """date at which the link will not be useable anymore"""
  expiresAt: DateTime

  """starting date of the billing window"""
  openingDate: DateTime!

  """ending date of the billing window"""
  closingDate: DateTime!

  """creation date"""
  createdAt: DateTime!

  """last update date"""
  updatedAt: DateTime!
}

"""Please see the Connection interface"""
type InvoiceConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Int!
  edges: [InvoiceEdge!]!
}

"""Please see the Edge interface"""
type InvoiceEdge implements Edge {
  node: Invoice!
  cursor: String!
}

"""The different statuses of invoice"""
enum InvoiceStatus {
  Failed
  NotPaid
  Paid
  PaymentDue
  Pending
  Voided
}

enum InvoiceType {
  Invoice
  RefundNote
}

"""
Rejection returned when you try to delete the last sandbox user.
At least one sandbox user should be present
"""
type LastSandboxUserCannotBeDeletedRejection implements Rejection {
  """Rejection message"""
  message: String!

  """Sandbox user ID"""
  userId: String!
}

"""Mandate amendment input"""
input MandateAmendment {
  """Previous SEPA creditor identifier"""
  previousCreditorIdentifier: SepaCreditorIdentifier

  """Previous SEPA debtor identifier"""
  previousDebtorIban: IBAN

  """Previous mandate reference"""
  previousMandateReference: SepaReference
}

"""Banking fee which could add manually"""
enum ManualBankingFee {
  """Drafting a circulation letter for a legal entity holder"""
  CirculationLetterDraftingFee

  """Drafting a confirmation letter for a legal entity holder"""
  ConfirmationLetterDraftingFee

  """Improper use of the account"""
  ImproperUseOfAccount

  """
  Processing of judicial or administrative seizures, notice to third party holders
  """
  ProcessingJudicialOrAdministrativeSeizure

  """SEPA creditor identifier request"""
  SepaCreditorIdentifierRequest

  """Intervention fee for managing unauthorized overdrafts"""
  UnauthorizedOverdraft
}

"""Filters that can be applied when listing account memberships"""
input MembershipsFilterInput {
  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean

  """Can the user initiate payments on this account"""
  canInitiatePayments: Boolean

  """Can the user manage account membership"""
  canManageAccountMembership: Boolean

  """Can the user manage beneficiaries"""
  canManageBeneficiaries: Boolean

  """Can the user view account"""
  canViewAccount: Boolean

  """Account memberships status/statuses we're looking for"""
  status: [AccountMembershipStatus!]

  """
  Search by email
  
  @deprecated(reason: "use `search` instead")
  """
  email: String

  """
  Search by first name
  
  @deprecated(reason: "use `search` instead")
  """
  firstName: String

  """
  Search by last name
  
  @deprecated(reason: "use `search` instead")
  """
  lastName: String

  """
  Search string to look for
  
  Search will be performed in following fields:
   - First name
   - Last name
   - Email
   - ID
  """
  search: String
}

input Merchant {
  """Merchant city"""
  city: String = "PARIS"

  """Merchant code"""
  code: String = "0000"

  """Merchant country"""
  country: CCA3 = "FRA"

  """Merchant ID"""
  id: String = "SWAN01"

  """Merchant name"""
  name: String = "SWAN"

  """Merchant postal Code"""
  postalCode: String = "75010"
}

"""
The different balances of the payment. Use this to understand in details what actions have been taken on the payment and what actions can be taken moving forward.
"""
type MerchantBalance {
  """The amount that can be canceled on this payment"""
  availableToCancel: Amount!

  """The amount that can be captured on this payment"""
  availableToCapture: Amount!

  """The amount that can be refunded on this payment"""
  availableToRefund: Amount!

  """The amount authorised"""
  totalAuthorized: Amount!

  """The amount canceled"""
  totalCanceled: Amount!

  """The amount captured"""
  totalCaptured: Amount!

  """The amount disputed"""
  totalDisputed: Amount!

  """The amount refunded"""
  totalRefunded: Amount!
}

"""Rejection returned when the Merchant Card Payment is declined"""
type MerchantCardPaymentDeclinedRejection implements Rejection {
  message: String!
}

enum MerchantCategory {
  Culture
  Entertainment
  Finance
  Groceries
  HealthAndBeauty
  HomeAndUtilities
  Other
  ProfessionalServices
  PublicAdministrations
  Restaurants
  Shopping
  Software
  Transport
  Travel
}

type MerchantPayment {
  """unique identifier of a merchant payment"""
  id: ID!

  """status information"""
  statusInfo: MerchantPaymentStatusInfo!

  """amount"""
  amount: Amount!

  """unique identifier of the payment mandate associated to the payment"""
  paymentMandateId: ID!

  """unique identifier of the payment link associated to the payment"""
  paymentLinkId: ID

  """unique identifier of the merchant profile associated to the payment"""
  merchantProfileId: ID!

  """unique identifier of the payment method associated to the payment"""
  paymentMethodId: ID!
  balance: MerchantBalance!

  """Label"""
  label: String
  reference: String

  """
  an arbitrary identifier that was defined by you when you created this payment
  """
  externalReference: String

  """The billing address associated to the payment"""
  billingAddress: Address
  threeDS: ThreeDS

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Authorized date"""
  authorizedAt: DateTime

  """Canceled date"""
  canceledAt: DateTime

  """Captured date"""
  capturedAt: DateTime

  """Rejected date"""
  rejectedAt: DateTime

  """Refunded date"""
  refundedAt: DateTime

  """Disputed date"""
  disputedAt: DateTime
}

"""Merchant Payment status authorized"""
type MerchantPaymentAuthorized implements MerchantPaymentStatusInfo {
  """status of the merchant payment"""
  status: MerchantPaymentStatus!
}

"""Merchant Payment status captured"""
type MerchantPaymentCaptured implements MerchantPaymentStatusInfo {
  """status of the merchant payment"""
  status: MerchantPaymentStatus!
}

type MerchantPaymentConnection implements Connection {
  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """Edge list"""
  edges: [MerchantPaymentEdge!]!

  """Total number of element in the list"""
  totalCount: Int!
}

type MerchantPaymentEdge implements Edge {
  node: MerchantPayment!

  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

input MerchantPaymentFiltersInput {
  """To filter on some Merchant Payment Link Status (all if empty)"""
  status: [MerchantPaymentStatus!]

  """To filter on some Merchant Payment Method Type (all if empty)"""
  paymentMethod: [MerchantPaymentMethodType!]

  """To filter after a createdAt value"""
  isAfterCreatedAt: DateTime

  """To filter before a createdAt value"""
  isBeforeCreatedAt: DateTime

  """To filter on some text occurrences (words or ids)"""
  search: String
  amountSmallerThan: AmountValue
  amountGreaterThan: AmountValue
}

"""Merchant Payment status initiated"""
type MerchantPaymentInitiated implements MerchantPaymentStatusInfo {
  """status of the merchant payment"""
  status: MerchantPaymentStatus!
}

type MerchantPaymentLink {
  """Merchant payment link's unique ID."""
  id: String!

  """ID of the related project"""
  projectId: ID!

  """The URL at which the customer can complete the payment."""
  url: String!

  """The merchant payment link status."""
  statusInfo: MerchantPaymentLinkStatusInfo!

  """The Merchant Profile to link this Payment Link to"""
  merchantProfile: MerchantProfile!

  """Amount to be paid to successfully complete the payment."""
  amount: Amount!

  """
  Merchant Website URL to redirect the user to when the payment is completed.
  """
  redirectUrl: String

  """URL to redirect the user to if they cancel their payment"""
  cancelRedirectUrl: String

  """
  Controls if the payment mandate created from this payment link is for one-time use or can be reused
  This is applicable for card and SEPA Direct Debit payment methods only.
  """
  sequence: PaymentMandateSequence!

  """
  The customer billing Address
  These fields should be completed also to pre-fill a SEPA direct debit mandate.
  
  We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes
  """
  billingAddress: Address

  """
    A date that reflects the time at which the user asked the transaction to be executed.
  For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
  For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
  
  Default value means that the execution will be as soon as possible
  """
  requestedExecutionAt: DateTime

  """
  Any string that you want to be attached to this payment link.
  Usually something to help you reference the link in an external system.
  """
  externalReference: String

  """
  Optional field intended to provide a way for you to include a reference number or code.
  The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different.
  """
  reference: String

  """
  The language used for the payment page.
  Default is the browser's language, or English if not available.
  """
  language: String

  """
  Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page.
  """
  label: String

  """
   We will use the information specified here to prefill the payment link fields
  depending on the payment method the end user chooses.
  Keep in mind that your end customer will be able to edit these fields.
  """
  customer: Customer

  """
  List of payment methods IDs enabled for this payment link.
  If the array is empty Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit)
  """
  paymentMethods: [MerchantPaymentMethod!]!
  createdAt: DateTime!
}

type MerchantPaymentLinkConnection implements Connection {
  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """Edge list"""
  edges: [MerchantPaymentLinkEdge!]!

  """Total number of element in the list"""
  totalCount: Int!
}

type MerchantPaymentLinkEdge implements Edge {
  node: MerchantPaymentLink!

  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

input MerchantPaymentLinkFiltersInput {
  """To filter on some Merchant Payment Link Status (all if empty)"""
  status: [MerchantPaymentLinkStatus!]

  """To filter after a createdAt value"""
  isAfterCreatedAt: DateTime

  """To filter before a createdAt value"""
  isBeforeCreatedAt: DateTime

  """To filter on some text occurrences (words or ids)"""
  search: String

  """
  To filter payment links having an amount smaller than the given criteria
  """
  amountSmallerThan: AmountValue

  """
  To filter payment links having an amount greater than the given criteria
  """
  amountGreaterThan: AmountValue
}

enum MerchantPaymentLinkOrderByFieldInput {
  createdAt
  label
  url
}

input MerchantPaymentLinkOrderByInput {
  field: MerchantPaymentLinkOrderByFieldInput
  direction: OrderByDirection
}

enum MerchantPaymentLinkStatus {
  """Customers can still use the merchant payment link to pay."""
  Active

  """The merchant payment link is expired."""
  Expired

  """The customer completed the payment."""
  Completed
}

interface MerchantPaymentLinkStatusInfo {
  status: MerchantPaymentLinkStatus!
}

"""Base object for the different Payment Methods available"""
interface MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

"""The different rejection reasons for a CardMerchantPaymentMethod"""
enum MerchantPaymentMethodCardRejectReason {
  SwanRefused
  UnsupportedBusiness
  SwanTechnicalErrorOccurred
}

"""Rejection returned when the Merchant Payment Method is not active"""
type MerchantPaymentMethodNotActiveRejection implements Rejection {
  paymentMethodIds: [String!]
  message: String!
}

enum MerchantPaymentMethodRejectReason {
  SwanRefused
  UnsupportedBusiness
  SwanTechnicalErrorOccurred
}

"""The different statuses a MerchantPaymentMethod can have"""
enum MerchantPaymentMethodStatus {
  PendingReview
  Enabled
  Rejected
  Disabled
  Suspended
}

"""The payment method status information"""
interface MerchantPaymentMethodStatusInfo {
  """Merchant Payment Method Status"""
  status: MerchantPaymentMethodStatus!
}

"""The different statuses a MerchantPaymentMethod can have"""
enum MerchantPaymentMethodType {
  InternalDirectDebitStandard
  InternalDirectDebitB2b
  SepaDirectDebitCore
  SepaDirectDebitB2b
  Check
  Card
}

interface MerchantPaymentMethodUpdateRequest {
  id: ID!
}

type MerchantPaymentMethodWrongStatusRejection implements Rejection {
  message: String!
}

enum MerchantPaymentOrderByFieldInput {
  label
  createdAt
  externalReference
  status
  amount
}

input MerchantPaymentOrderByInput {
  field: MerchantPaymentOrderByFieldInput
  direction: OrderByDirection
}

"""Merchant Payment status rejected"""
type MerchantPaymentRejected implements MerchantPaymentStatusInfo {
  """status of the merchant payment"""
  status: MerchantPaymentStatus!

  """rejected reason"""
  reason: String!
}

"""Merchant Payment status"""
enum MerchantPaymentStatus {
  Initiated
  Authorized
  Captured
  Rejected
}

"""Merchant Payment Status Information"""
interface MerchantPaymentStatusInfo {
  """status of the merchant payment"""
  status: MerchantPaymentStatus!
}

"""Merchant Profile"""
type MerchantProfile {
  """The Merchant Profile ID"""
  id: ID!

  """The Account ID this Merchant Profile is linked to"""
  accountId: ID!

  """
  Business name of the merchant, i.e. name that will be displayed on debtors' bank statements
  """
  merchantName: String!

  """Url of the merchant's website"""
  merchantWebsite: String

  """Url of the merchant's logo"""
  merchantLogoUrl: String

  """The status of the merchant profile"""
  statusInfo: MerchantProfileStatusInfo!

  """
  Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
  """
  productType: ProductType!

  """Expected annual activity volumes for all payment method"""
  expectedMonthlyPaymentVolume: Amount!

  """Payment Methods associated"""
  merchantPaymentMethods: [MerchantPaymentMethod!]

  """Updates Requested associated"""
  requestedMerchantProfileUpdates: [RequestMerchantProfileUpdate!] @deprecated

  """Update Requested associated"""
  requestMerchantProfileUpdate: RequestMerchantProfileUpdate

  """expected average basket value."""
  expectedAverageBasket: Amount!

  """
  Your accent color, used in white label interfaces.
  This color would also be inherited in the Swan Merchant Payment page.
  """
  accentColor: String

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!
  merchantPaymentLinks(first: Int! = 50, after: String, orderBy: MerchantPaymentLinkOrderByInput, filters: MerchantPaymentLinkFiltersInput): MerchantPaymentLinkConnection
  merchantPayments(first: Int! = 50, after: String, orderBy: MerchantPaymentOrderByInput, filters: MerchantPaymentFiltersInput): MerchantPaymentConnection
}

"""Merchant Profile Statuses"""
enum MerchantProfileStatus {
  """A Merchant Profile is created in the PendingReview status"""
  PendingReview

  """Enabled"""
  Enabled

  """Rejected"""
  Rejected

  """Suspended"""
  Suspended

  """Disabled"""
  Disabled
}

"""Merchant Profile Status Information"""
interface MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
}

"""
Rejection returned when the Merchant Profile is not in the expected status
"""
type MerchantProfileWrongStatusRejection implements Rejection {
  message: String!
  currentStatus: MerchantProfileStatus!
  expectedStatus: MerchantProfileStatus!
}

enum MerchantSubCategory {
  Education
  Museums
  CinemasAndShows
  GamblingAndBettingActivities
  OtherLeisureActivities
  StreamingPlatforms
  ThemeParks
  TicketsAndEvents
  VideoGames
  FinancialServices
  Insurance
  LiquorStore
  SupermarketsAndOtherGroceryStores
  FitnessAndSports
  Hairdressing
  Healthcare
  Pharmacies
  SpaAndBeautyTreatments
  ConstructionAndOddJobs
  EnergyProviders
  Gardening
  Laundries
  PhoneAndInternetServicesProviders
  RealEstate
  CharityAndNonProfitOrganizations
  ReligiousOrganizations
  AdvertisingAndMarketing
  BookkeepingAndConsultancy
  CourierAndLogistics
  IndustrialCleaning
  LegalActivities
  OtherProfessionalServices
  StationaryServices
  GovernmentAndCityCouncils
  BarsAndRestaurants
  CoffeeAndBakeries
  FoodDelivery
  PubsAndNightclubs
  BooksAndNewspapers
  CigarShops
  ClothingShoesAndAccessories
  ComputersAndElectronicDevices
  DepartmentStores
  Furniture
  GamesAndToys
  HardwareStores
  HouseholdItems
  Pets
  SoftwareServices
  CarRental
  MetroBusAndTrains
  MotorVehiclesRepairsAndAccessories
  OtherTransportProviders
  PrivateMobilityServices
  ServiceStations
  TollsAndParkings
  Airlines
  FerriesAndBoats
  HotelsAndAccommodation
  TravelAgents
  AtmWithdrawal
  OfficeRental
  HrAndRecruiting
  Flowers
  OtherStores
  PerfumesAndCosmetics
  Other
}

"""Monthly income."""
enum MonthlyIncome {
  """less than 500"""
  LessThan500

  """between 500 and 1500"""
  Between500And1500

  """between 1500 and 3000"""
  Between1500And3000

  """between 3000 and 4500"""
  Between3000And4500

  """more than 4500"""
  MoreThan4500
}

"""Monthly payment volume."""
enum MonthlyPaymentVolume {
  Between10000And50000
  Between50000And100000
  LessThan10000
  MoreThan100000
}

type Mutation {
  """Mutation to simulate a manual provisioning"""
  simulateManualProvisioning(input: DigitalizationInput!): SimulationResponse!

  """
  Mutation to give decision on digitalization.
  If more than one InApp digitalization process are ongoing, only the latest one will be acted upon
  """
  simulateInAppProvisioningCompletion(input: InAPpDigitalizationInput!): SimulationResponse!

  """
  Mutation to simulate the reception of a physical card.
  Requires a physical card in a valid state for reception.
  """
  physicalCardReception(input: PhysicalCardReceptionInput!): PhysicalCardReceptionPayload!

  """
  Mutation to promote an account holder to the role of project owner.
  Requires the account holder identifier to be promoted to Project Owner.
  Beware, if another account holder had this role, they will lose it.
  """
  promoteAccountHolderToProjectOwner(input: PromoteAccountHolderToProjectOwnerInput!): PromoteAccountHolderToProjectOwnerPayload!
  requestSupportingDocuments(input: RequestSupportingDocumentsInput!): RequestSupportingDocumentsPayload!

  """
  Mutation to simulate delivery of a physical card.
  Requires a physical card in a valid state for delivery.
  """
  simulatePhysicalCardDelivery(input: SimulatePhysicalCardDeliveryInput!): SimulationResponse!

  """Simulate physical card renewal process."""
  simulatePhysicalCardRenewalProcess(input: SimulatePhysicalCardRenewalProcessInput!): SimulatePhysicalCardRenewalProcessPayload!
  updateSupportingDocumentCollectionStatus(input: UpdateSupportingDocumentCollectionStatusInput!): UpdateSupportingDocumentCollectionStatusPayload!
  updateSupportingDocumentStatus(input: UpdateSupportingDocumentStatusInput!): UpdateSupportingDocumentStatusPayload!
  updateAccountHolder(input: UpdateAccountHolderInput!): UpdateAccountHolderPayload!
  updateFundingLimitSettingsChangeRequest(input: UpdateFundingLimitSettingsChangeRequestInput!): UpdateFundingLimitSettingsChangeRequestPayload!

  """Simulation to insert card transaction enrichment infos manualy"""
  simulateCardTransactionEnrichment(input: SimulateCardTransactionEnrichmentInput!): SimulateCardTransactionEnrichmentPayload!

  """
  Mutation to simulate the generation of an account invoice
  This invoice will contain all banking fees related to the account
  """
  simulateInvoiceGeneration(input: SimulateInvoiceGenerationInput!): SimulateInvoiceGenerationPayload

  """Mutation to simulate a banking fee manually added by the Swan Team"""
  simulateManualBankingFee(input: SimulateManualBankingFeeInput!): SimulateManualBankingFeePayload

  """
  Mutation to simulate the start of the billing for a given project, which occurs generally when the project go Live (Partner billing)
  
  This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  simulateStartProjectBilling(input: SimulateStartProjectBillingInput!): SimulateStartProjectBillingPayload

  """Mutation to simulate a capital deposit case approval."""
  simulateApproveCapitalDepositCase(input: SimulateApproveCapitalDepositCaseInput!): SimulateApproveCapitalDepositCasePayload!

  """Mutation to simulate an update of capital deposit document status."""
  simulateCapitalDepositDocumentStatus(input: SimulateCapitalDepositDocumentStatusInput!): SimulateCapitalDepositDocumentStatusPayload!

  """Create a sandbox identification"""
  createSandboxIdentification(input: CreateSandboxIdentificationInput!): CreateSandboxIdentificationPayload!

  """Update a sandbox identification"""
  updateSandboxIdentification(input: UpdateSandboxIdentificationInput!): UpdateSandboxIdentificationPayload!

  """
  Create a sandbox user
  This mutation is restricted to a User access token
  """
  createSandboxUser(input: CreateSandboxUserInput!): CreateSandboxUserPayload!

  """
  Delete a sandbox user
  This mutation is restricted to a User access token
  """
  deleteSandboxUser(input: DeleteSandboxUserInput!): DeleteSandboxUserPayload!

  """
  Log sandbox user
  This mutation is restricted to a User access token
  """
  endorseSandboxUser(input: EndorseSandboxUserInput!): EndorseSandboxUserPayload!

  """
  Updates a sandbox user
  This mutation is restricted to a User access token
  """
  updateSandboxUser(input: UpdateSandboxUserInput!): UpdateSandboxUserPayload!

  """Simulate Swan processing on Account Verification"""
  updateAccountVerificationStatus(input: UpdateAccountVerificationStatusInput!): UpdateAccountVerificationStatusPayload!

  """Generate a CMC7 with its RLMC key usable for test purpose"""
  generateTestCheck(input: GenerateCheckInput!): GenerateCheckPayload!

  """Simulate the authorization of a card merchant payment"""
  simulateIncomingCardAuthorization(input: SimulateIncomingCardAuthorizationInput!): SimulateIncomingCardAuthorizationPayload!

  """Simulate the update of a Merchant Payment Method"""
  simulateMerchantPaymentMethodRequestOutcome(input: SimulateMerchantPaymentMethodRequestOutcomeInput!): SimulateMerchantPaymentMethodRequestOutcomePayload!

  """
  Simulate the approval or rejection of a merchant payment method update request
  """
  simulateMerchantPaymentMethodUpdateRequestOutcome(input: SimulateMerchantPaymentMethodUpdateRequestOutcomeInput!): SimulateMerchantPaymentMethodUpdateRequestOutcomePayload!

  """Simulate the update of a Merchant Profile"""
  simulateMerchantProfileRequestOutcome(input: SimulateMerchantProfileRequestOutcomeInput!): SimulateMerchantProfileRequestOutcomePayload!

  """
  Simulate the approval or rejection of a merchant profile update request
  """
  simulateMerchantProfileUpdateRequestOutcome(input: SimulateMerchantProfileUpdateRequestOutcomeInput!): SimulateMerchantProfileUpdateRequestOutcomePayload!

  """
  After an incoming Card transaction has been scheduled, simulate the corresponding transaction being booked on the Swan creditor account.
  """
  simulateIncomingCardBooking(input: SimulateIncomingCardBookingInput!): SimulateIncomingCardBookingPayload!

  """
  Simulate a card advice (amendment) received for a previous authorization for a card issued on a Swan account.
  """
  simulateOutgoingCardAdvice(input: SimulateOutgoingCardAdviceInput!): SimulateOutgoingCardAuthorizationPayload!

  """
  Simulate a card authorization release being received for a card authorization.
  """
  simulateOutgoingCardAuthorizationRelease(input: SimulateOutgoingCardAuthorizationReleaseInput!): SimulateOutgoingCardAuthorizationReleasePayload!

  """
  Simulate a card authorization request being received for a card issued on a Swan account.
  """
  simulateOutgoingCardAuthorization(input: SimulateOutgoingCardAuthorizationInput!): SimulateOutgoingCardAuthorizationPayload!

  """
  After a Card Credit has been booked on a Swan account, simulate the merchant reversing the transaction and the subsequent debit of funds from the Swan account.
  """
  simulateOutgoingCardCreditReverse(input: SimulateOutgoingCardCreditReverseInput!): SimulateOutgoingCardCreditReversePayload!

  """Simulate the reception of a card credit on a Swan account."""
  simulateOutgoingCardCredit(input: SimulateOutgoingCardCreditInput!): SimulateOutgoingCardCreditPayload!

  """
  After a Card Debit has been booked on a Swan account, simulate the merchant reversing the transaction and the subsequent return of funds to the Swan account.
  """
  simulateOutgoingCardDebitReverse(input: SimulateOutgoingCardDebitReverseInput!): SimulateOutgoingCardDebitReversePayload!

  """
  Simulate a card debit being received on a previously authorized card transaction.
  """
  simulateOutgoingCardDebit(input: SimulateOutgoingCardDebitInput!): SimulateOutgoingCardDebitPayload!

  """
  After an incoming Check has been scheduled, simulate the corresponding transaction being booked on the Swan creditor account.
  """
  simulateIncomingCheckBooking(input: SimulateIncomingCheckBookingInput!): SimulateIncomingCheckBookingPayload!

  """
  After an incoming Check has been sent, simulate the corresponding transaction being rejected on the Swan creditor account.
  """
  simulateIncomingCheckRejection(input: SimulateIncomingCheckRejectionInput!): SimulateIncomingCheckRejectionPayload!

  """
  After an incoming Check has been booked, simulate the corresponding transaction being returned from the Swan creditor account.
  """
  simulateIncomingCheckReturn(input: SimulateIncomingCheckReturnInput!): SimulateIncomingCheckReturnPayload!

  """
  After an incoming Internal Direct Debit has been scheduled, simulate the corresponding transaction being booked on the Swan creditor account.
  """
  simulateIncomingInternalDirectDebitBooking(input: SimulateIncomingInternalDirectDebitBookingInput!): SimulateIncomingInternalDirectDebitBookingPayload!

  """
  After an incoming Internal Direct Debit has been sent, simulate the corresponding transaction being rejected on the Swan creditor account.
  """
  simulateIncomingInternalDirectDebitRejection(input: SimulateIncomingInternalDirectDebitRejectionInput!): SimulateIncomingInternalDirectDebitRejectionPayload!

  """
  After an incoming Internal Direct Debit has been sent, simulate the corresponding transaction being returned.
  """
  simulateIncomingInternalDirectDebitReturn(input: SimulateIncomingInternalDirectDebitReturnInput!): SimulateIncomingInternalDirectDebitReturnPayload!

  """
  Simulate Swan returning an Incoming International Credit Transfer Return request.
  """
  simulateIncomingInternationalCreditTransferReturn(input: SimulateIncomingInternationalCreditTransferReturnInput!): SimulateIncomingInternationalCreditTransferReturnPayload!

  """
  After an outgoing International Credit Transfer has been sent for execution to Swan, simulate the corresponding transaction being booked on the Swan debtor account.
  """
  simulateOutgoingInternationalCreditTransferBooking(input: SimulateOutgoingInternationalCreditTransferBookingInput!): SimulateOutgoingInternationalCreditTransferBookingPayload!

  """
  Simulate Swan rejecting an outgoing International Credit Transfer request, for compliance reasons.
  """
  simulateOutgoingInternationalCreditTransferRejection(input: SimulateOutgoingInternationalCreditTransferRejectionInput!): SimulateOutgoingInternationalCreditTransferRejectionPayload!

  """
  Simulate Swan returning an outgoing International Credit Transfer request.
  """
  simulateOutgoingInternationalCreditTransferReturn(input: SimulateOutgoingInternationalCreditTransferReturnInput!): SimulateOutgoingInternationalCreditTransferReturnPayload!

  """Simulate an incoming international credit transfer"""
  simulateIncomingInternationalCreditTransferReception(input: SimulateIncomingInternationalCreditTransferInput!): SimulateIncomingInternationalCreditTransferPayload!

  """
  After a SEPA Credit Transfer has credited a Swan account, simulate an authorized account member accepting a recall request, and the subsequent return of funds to the issuer.
  """
  simulateIncomingSepaCreditTransferAcceptedRecall(input: SimulateIncomingSepaCreditTransferAcceptedRecallInput!): SimulateIncomingSepaCreditTransferAcceptedRecallPayload!

  """Simulate when a SEPA Credit Transfer credits the account"""
  simulateIncomingSepaCreditTransferReception(input: IncomingSepaCreditTransferInput!): SimulateIncomingSepaCreditTransferReceptionPayload!

  """
  After a SEPA Credit Transfer has credited a Swan account, simulate an authorized account member returning funds to the issuer.
  """
  simulateIncomingSepaCreditTransferReturn(input: SimulateIncomingSepaCreditTransferReturnInput!): SimulateIncomingSepaCreditTransferReturnPayload!

  """
  After an incoming SEPA Direct Debit has been sent for execution to Sepa, simulate the corresponding transaction being booked on the Swan creditor account.
  """
  simulateIncomingSepaDirectDebitBooking(input: SimulateIncomingSepaDirectDebitBookingInput!): SimulateIncomingSepaDirectDebitBookingPayload!

  """
  After an incoming SEPA Direct Debit has been sent for execution to Sepa, simulate the corresponding transaction being rejected on the Swan creditor account.
  """
  simulateIncomingSepaDirectDebitRejection(input: SimulateIncomingSepaDirectDebitRejectionInput!): SimulateIncomingSepaDirectDebitRejectionPayload!

  """
  After an incoming SEPA Direct Debit has been booked, simulate the corresponding transaction being returned from the Swan creditor account.
  """
  simulateIncomingSepaDirectDebitReturn(input: SimulateIncomingSepaDirectDebitReturnInput!): SimulateIncomingSepaDirectDebitReturnPayload!

  """
  Simulate the return of funds to a Swan account, following a recall request by an authorized account member of that account and the acceptance by the beneficiary.
  """
  simulateOutgoingSepaCreditTransferAcceptedRecall(input: SimulateOutgoingSepaCreditTransferAcceptedRecallInput!): SimulateOutgoingSepaCreditTransferAcceptedRecallPayload!

  """
  After an outgoing SEPA Credit Transfer has been sent for execution to Swan, simulate the corresponding transaction being booked on the Swan debtor account.
  """
  simulateOutgoingSepaCreditTransferBooking(input: SimulateOutgoingSepaCreditTransferBookingInput!): SimulateOutgoingSepaCreditTransferBookingPayload!

  """
  Simulate Swan rejecting an outgoing SEPA Credit Transfer request, for compliance reasons.
  """
  simulateOutgoingSepaCreditTransferRejection(input: SimulateOutgoingSepaCreditTransferRejectionInput!): SimulateOutgoingSepaCreditTransferRejectionPayload!

  """
  Simulate a beneficiary bank returning funds to a Swan account after a SEPA Credit Transfer debited the account.
  """
  simulateOutgoingSepaCreditTransferReturn(input: SimulateOutgoingSepaCreditTransferReturnInput!): SimulateOutgoingSepaCreditTransferReturnPayload!

  """
  Simulate a creditor cancelling an incoming SEPA Direct Debit instruction sent to debit a Swan account, before the execution/debit date.
  """
  simulateOutgoingSepaDirectDebitCancel(input: SimulateOutgoingSepaDirectDebitCancelInput!): SimulateOutgoingSepaDirectDebitCancelPayload!

  """
  Simulate a Swan account receiving a SEPA Direct Debit instruction and being debited.
  """
  simulateOutgoingSepaDirectDebitReception(input: SimulateOutgoingSepaDirectDebitReceptionInput!): SimulateOutgoingSepaDirectDebitReceptionPayload!

  """
  Simulate a Swan debtor rejecting a SEPA Direct Debit instruction they’ve already received, before the execution/debit date
  """
  simulateOutgoingSepaDirectDebitReject(input: SimulateOutgoingSepaDirectDebitRejectInput!): SimulateOutgoingSepaDirectDebitRejectPayload!

  """
  After a SEPA Direct Debit instruction has been received and the transaction was booked on a Swan debtor account, simulate a refund request by an authorized account member and the subsequent return of funds to their account.
  """
  simulateOutgoingSepaDirectDebitReturn(input: SimulateOutgoingSepaDirectDebitReturnInput!): SimulateOutgoingSepaDirectDebitReturnPayload!

  """
  After a SEPA Direct Debit instruction has been received and the transaction was booked on a Swan debtor account, simulate the creditor reversing the transaction and the subsequent return of funds to the Swan account
  """
  simulateOutgoingSepaDirectDebitReverse(input: SimulateOutgoingSepaDirectDebitReverseInput!): SimulateOutgoingSepaDirectDebitReversePayload!

  """Release reserved balance associate to a transaction id."""
  simulateReleaseReservedBalance(input: SimulateReleaseReservedBalanceInput!): SimulateReleaseReservedBalancePayload!

  """Update the account holder funding limit"""
  updateAccountHolderFundingLimits(input: UpdateAccountHolderFundingLimitsInput!): UpdateAccountHolderFundingLimitsPayload @deprecated(reason: "Use mutation updateFundingLimitSettingsChangeRequest in sandbox-partner-admin instead.")
}

"""Rejection returned on unknown nationality"""
type NationalityNotFoundRejection implements Rejection {
  message: String!
  identifier: CCA3!
}

"""
Rejection returned if the entity was not found or if the user does not have the rights to know that the account exists
"""
type NotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Rejection returned when consent status couldn't change"""
type NotReachableConsentStatusRejection implements Rejection {
  message: String!
  currentStatus: ConsentStatus
  unreachableStatus: ConsentStatus
}

"""
@deprecated Use 'StartedIdentificationLevelStatusInfo' instead. Deprecated to ensure consistency and clear identification status behavior
Describes an identification level that hasn't started for the process of the current identification
"""
type NotStartedIdentificationLevelStatusInfo {
  """Always set to `NotStarted`"""
  status: SwanIdentificationStatus! @deprecated(reason: "Use 'Started' instead. Deprecated to ensure consistency and clear identification status behavior.")
}

"""
Describes an identification level that's not supported for the process of the current identification
"""
type NotSupportedIdentificationLevelStatusInfo {
  """Always set to `NotSupported`"""
  status: SwanIdentificationStatus!
}

type OAuth2Consent implements DetailedConsent {
  id: ID!
  projectId: String
  requireSCA: Boolean!
  status: ConsentStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  startedAt: DateTime
  expiredAt: DateTime
  acceptedAt: DateTime
  refusedAt: DateTime
  canceledAt: DateTime
  consentResponses: [ConsentResponse!]!
  purpose: DetailedConsentPurpose!
  consentOperations: [ConsentOperation!]!
  env: EnvType!
  identityId: String!
  userId: String
  state: String
  branding: Branding!
  operationsSHA256HexDigest: String
  consentChallenge: String
  loginChallenge: String
  scopes: String
  challenge: String
}

"""Extra parameters provided by partner"""
type OAuthRedirectParameters {
  """
  Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity.
  """
  state: String

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  """
  redirectUrl: String
}

"""
Information provided during the onboarding process of an individual or a company
"""
type Onboarding {
  """Unique identifier of an onboarding"""
  id: String!

  """Account name"""
  accountName: String

  """Account Country"""
  accountCountry: AccountCountry!

  """Creation date"""
  createdAt: DateTime!

  """Email"""
  email: String

  """Finalization date"""
  finalizedAt: DateTime

  """
  Language of the onboarding process.
  - Accepted languages: `["en", "fr", "nl", "de", "it", "es", "pt", "fi"]`
  """
  language: String

  """Information regarding the Individual or the company to onboard"""
  info: OnboardingAccountHolderInfo!

  """Account holder created at the end of the onboarding process"""
  accountHolder: AccountHolder

  """
  Redirect the legal representative of a new account holder to this URL to start the onboarding process
  """
  onboardingUrl: String

  """Current computed state of onboarding"""
  onboardingState: OnboardingState!

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  """
  redirectUrl: String! @deprecated(reason: "Use `redirectUrl` field on oauthRedirectParameters parameters instead.")

  """Extra parameters provided by partner"""
  oAuthRedirectParameters: OAuthRedirectParameters

  """Status (valid/invalid/finalized) and details of errors on fields"""
  statusInfo: OnboardingStatusInfo!

  """Swan TCU URL"""
  tcuUrl: String!

  """List of supporting document collection owned by the account holder."""
  supportingDocumentCollection: SupportingDocumentCollection!

  """Creation date"""
  updatedAt: DateTime!

  """Account opened after the onboarding finalization"""
  account: Account

  """List of accepted identification level for the legal representative"""
  legalRepresentativeAcceptedIdentificationLevels: [IdentificationLevel]!

  """Recommended identification level for the legal representative"""
  legalRepresentativeRecommendedIdentificationLevel: IdentificationLevel!
}

"""The onboarding could be for an Individual or a company"""
interface OnboardingAccountHolderInfo {
  """Account holder type"""
  type: AccountHolderType!
}

"""Company Account Holder Information"""
type OnboardingCompanyAccountHolderInfo implements OnboardingAccountHolderInfo {
  """
  Account holder type (always Company for type OnboardingCompanyAccountHolderInfo)
  """
  type: AccountHolderType!

  """Name of the company."""
  name: String

  """
  Registration number of the company (for example, Système d'Identification du Répertoire des ENtreprises [SIREN] in France, ...).
  - Length must be from 0 to 50 characters.
  """
  registrationNumber: String

  """legal form of the company (SAS, SCI, SASU, ...)"""
  companyType: CompanyType

  """business activity"""
  businessActivity: BusinessActivity

  """
  business activity description
  This must be 1024 characters long maximum.
  """
  businessActivityDescription: String

  """estimated monthly payment volume (euro)"""
  monthlyPaymentVolume: MonthlyPaymentVolume

  """
  The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
  
  The ultimate beneficiary is :
  - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
  - either the natural person (s) who exercise, by other means, a power of control of the company;
  """
  individualUltimateBeneficialOwners: [IndividualUltimateBeneficialOwner!]

  """residency address of the head office (Must be in a European country)"""
  residencyAddress: AddressInfo

  """Is company registered at RCS in its country"""
  isRegistered: Boolean

  """
  Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT
  """
  vatNumber: String

  """Tax Identification Number"""
  taxIdentificationNumber: String

  """Legal representative personal address"""
  legalRepresentativePersonalAddress: AddressInformation

  """Type of representation (legal representative or power of attorney)"""
  typeOfRepresentation: TypeOfRepresentation
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type OnboardingConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """OnboardingEdge list"""
  edges: [OnboardingEdge!]!
}

"""Implements the Relay Edge interface"""
type OnboardingEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The Onboarding"""
  node: Onboarding!
}

"""Filters that can be applied when listing onboardings"""
input OnboardingFiltersInput {
  """
  Search by email
  
  @deprecated(reason: "use `search` instead")
  """
  email: String

  """
  Search string to look for
  
  Search will be performed in following fields:
   - Account holder's first name
   - Account holder's last name
   - Account holder's company name
   - Account holder's ID
   - Email
   - ID
  """
  search: String

  """Filter by status"""
  status: [OnboardingStatus!]

  """Filter by type"""
  types: [AccountHolderType!]
}

"""StatusInfo when onboarding has been finalized"""
type OnboardingFinalizedStatusInfo implements OnboardingStatusInfo {
  status: OnboardingStatus!
}

"""Individual Account Holder Information"""
type OnboardingIndividualAccountHolderInfo implements OnboardingAccountHolderInfo {
  """
  Account holder type (always Individual for type OnboardingIndividualAccountHolderInfo)
  """
  type: AccountHolderType!

  """employment status of the individual account holder"""
  employmentStatus: EmploymentStatus

  """monthly income of the individual account holder"""
  monthlyIncome: MonthlyIncome

  """
  residency address of the individual account holder (must be in a European country)
  """
  residencyAddress: AddressInfo

  """Tax Identification Number"""
  taxIdentificationNumber: String
}

type OnboardingInfo {
  """Unique identifier of an onboarding"""
  id: String!

  """Account name"""
  accountName: String

  """
  Country of the account that will be created at the end of the onboarding process
  """
  accountCountry: AccountCountry

  """email"""
  email: String

  """
  Language of the onboarding process.
  - Accepted languages: `["en", "fr", "nl", "de", "it", "es", "pt", "fi"]`
  """
  language: String

  """Information regarding the Individual or the company to onboard"""
  info: OnboardingAccountHolderInfo!

  """
  Redirect the legal representative of a new account holder to this URL to start the onboarding process
  """
  onboardingUrl: String!

  """Current computed state of onboarding"""
  onboardingState: OnboardingState

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  """
  redirectUrl: String!

  """Project infos you set in the dashboard"""
  projectInfo: ProjectInfo

  """Verification Flow"""
  verificationFlow: VerificationFlow!

  """Extra parameters provided by partner"""
  oAuthRedirectParameters: OAuthRedirectParameters

  """Status (valid/invalid/finalized) and details of errors on fields"""
  statusInfo: OnboardingStatusInfo!

  """Supporting document collection related to onboarding."""
  supportingDocumentCollection: SupportingDocumentCollection!

  """List of accepted identification level for the legal representative"""
  legalRepresentativeAcceptedIdentificationLevels: [IdentificationLevel]!

  """Recommended identification level for the legal representative"""
  legalRepresentativeRecommendedIdentificationLevel: IdentificationLevel!

  """Swan TCU URL"""
  tcuUrl: String!
}

"""StatusInfo when onboarding has still at least one incorrect field"""
type OnboardingInvalidStatusInfo implements OnboardingStatusInfo {
  status: OnboardingStatus!
  errors: [ValidationError!]!
}

"""
Field we can use when ordering that can be applied when listing onboardings
"""
enum OnboardingOrderByFieldInput {
  createdAt
  updatedAt
  finalizedAt
}

"""Order that can be applied when listing onboardings"""
input OnboardingOrderByInput {
  field: OnboardingOrderByFieldInput
  direction: OrderByDirection
}

"""Onboarding process state"""
enum OnboardingState {
  """When the onboarding is in progress"""
  Ongoing

  """When the onboarding is finalized and the account holder is created"""
  Completed
}

"""Possible values for onboarding status"""
enum OnboardingStatus {
  """When the onboarding is finalized"""
  Finalized

  """when the onboarding is invalid. Final status"""
  Invalid

  """When the onboarding is valid. Final status"""
  Valid
}

"""
Object containing details about onboarding status (valid/invalid and why it is invalid/already finalized)
"""
interface OnboardingStatusInfo {
  """
  Current onboarding status. Onboarding can only be finalized if status is "valid"
  """
  status: OnboardingStatus!
}

"""
StatusInfo when onboarding has all onboarding fields are correctly filled
"""
type OnboardingValidStatusInfo implements OnboardingStatusInfo {
  status: OnboardingStatus!
}

enum OrderByDirection {
  Asc
  Desc
}

"""Reason codes for returning an outgoing transfer"""
enum OutgoingInternationalCreditTransferReturnReasonCode {
  AccountBlocked
  AccountClosed
  AccountDoesNotExist
  AccountFrozen
  AccountLimitReached
  BusinessPaymentsForbidden
  CannotAcceptFrom3RdParty
  CreditingAccountForbidden
  DuplicateEntry
  FundsNotExpectedReturned
  MandateNotFilledIn
  ReasonNotSpecified
  TaxIdNotMatching
  TaxIdSuspended
  WrongAccountDetails
  WrongAccountNumber
  WrongAccountType
  WrongBankCode
  WrongBranchCode
  WrongCardNumber
  WrongCardType
  WrongCurrency
  WrongIdNumber
  WrongName
  WrongPaymentPurpose
  WrongPhoneNumber
  WrongReference
  WrongRutNumber
}

"""
Implements PageInfo from the Relay Connections Specification - information about a page in the pagination mechanism
"""
type PageInfo {
  """Indicates whether more edges exist following this page"""
  hasNextPage: Boolean

  """Indicates whether more edges exist preceding this page"""
  hasPreviousPage: Boolean

  """Opaque identifier pointing to the first node of the page"""
  startCursor: String

  """Opaque identifier pointing to the last node of the page"""
  endCursor: String
}

"""Partnership Status Accepted"""
type PartnershipAcceptedStatusInfo implements PartnershipStatusInfo {
  """
  Partnership status (always Accepted for type PartnershipAcceptedStatusInfo)
  """
  status: PartnershipStatus!

  """Accepted date of the partnership for this account"""
  acceptedDate: DateTime!
}

"""Partnership Status canceled"""
type PartnershipCanceledStatusInfo implements PartnershipStatusInfo {
  """
  Partnership status (always Canceled for type PartnershipCanceledStatusInfo)
  """
  status: PartnershipStatus!

  """Accepted date of the partnership for this account"""
  acceptedDate: DateTime!

  """Canceled date of the partnership for this account"""
  canceledDate: DateTime!

  """Reason of the cancelation"""
  reason: String!
}

"""Partnership Status currently cancelling"""
type PartnershipCancelingStatusInfo implements PartnershipStatusInfo {
  """
  Partnership status (always Canceling for type PartnershipCancelingStatusInfo)
  """
  status: PartnershipStatus!

  """Accepted date of the partnership for this account"""
  acceptedDate: DateTime!

  """Canceled date of the partnership for this account"""
  canceledAfter: DateTime!
}

enum PartnershipStatus {
  """
  When the partnership is accepted by the account holder for this account
  """
  Accepted

  """When you decide to stop the partnership, you have 2 months notice"""
  Canceling

  """When the partnership was canceled by you or the account holder"""
  Canceled
}

"""Partnership Status information"""
interface PartnershipStatusInfo {
  """Status of the partnership for this account"""
  status: PartnershipStatus!
}

"""The document corresponding to a passport"""
type PassportDocument {
  """Unique identifier of the passport document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """The date at which the passport was issued"""
  issueDate: Date

  """The date at which the passport expires"""
  expiryDate: Date

  """Machine-readable zone code of the passport"""
  mrz: String

  """Number of the passport"""
  number: String

  """List of the associated files"""
  files: [PassportDocumentFile!]!
}

"""The file associated to the passport document"""
type PassportDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!

  """From which side the passport's picture was taken"""
  side: DocumentFileSide!
}

enum PaymentAccountType {
  """When the account holder if the account hasn't met KYC requirements"""
  EMoney

  """When all KYC requirements are met"""
  PaymentService
}

interface PaymentDirectDebitMandate {
  """Unique identifier of the Direct Debit Payment Mandate"""
  id: ID!
}

"""Payment Level of the account"""
enum PaymentLevel {
  """When the account is limited to 0€ within 30 days and with no IBAN"""
  Limited

  """
  When the account holder is fully verified and then the account is unlimited with an IBAN
  """
  Unlimited
}

interface PaymentMandate {
  """Unique identifier of the Payment Mandate"""
  id: ID!

  """Custom name of the mandate"""
  name: String

  """Account Holder information"""
  accountHolder: AccountHolder!

  """Creation date of the Payment Mandate"""
  createdAt: DateTime!

  """Last Update date of the Payment Mandate"""
  updatedAt: DateTime!

  """
  Date of the the last transaction executed for the concerned Payment Mandate
  """
  executedAt: DateTime

  """Expiry date of the Payment Mandate"""
  expiredAt: Date

  """Payment Mandate status information"""
  statusInfo: PaymentMandateStatusInfo!
}

enum PaymentMandateCanceledReason {
  """When the user requested to cancel the Payment Mandate"""
  RequestedByUser

  """When the Payment Mandate is expired"""
  MandateExpired
}

"""Payment Mandate Canceled status information"""
type PaymentMandateCanceledStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Canceled for type PaymentMandateCanceledStatusInfo).
  """
  status: PaymentMandateStatus!

  """Reason behind the Payment Mandate Canceled status"""
  reason: PaymentMandateCanceledReason!

  """Date of Cancellation of the mandate."""
  canceledAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type PaymentMandateConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """PaymentMandateEdge list"""
  edges: [PaymentMandateEdge!]!
}

"""Payment Mandate Consent Pending status information"""
type PaymentMandateConsentPendingStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Enabled for type PaymentMandateEnableedStatusInfo).
  """
  status: PaymentMandateStatus!

  """Consent information required to enable the concerned Payment Mandate"""
  consent: Consent!
}

interface PaymentMandateCreditor {
  """Creditor UUID"""
  id: ID!

  """Creditor name"""
  name: String!

  """Creditor address"""
  address: Address!
}

interface PaymentMandateDebtor {
  """Debtor name"""
  name: String!

  """Debtor e-mail"""
  email: String

  """Debtor country"""
  country: CCA3!
}

"""Implements the Relay Edge interface"""
type PaymentMandateEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The payment mandate"""
  node: PaymentMandate!
}

"""Payment Mandate Enabled status information"""
type PaymentMandateEnabledStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Enabled for type PaymentMandateEnabledStatusInfo).
  """
  status: PaymentMandateStatus!
}

"""
Filter that can be passed to get the payment mandate in a specific data range
"""
input PaymentMandateFiltersInput {
  """To filter on status values"""
  status: [PaymentMandateStatus!]

  """To filter on scheme values"""
  scheme: [PaymentMandateScheme!]
}

"""Error returned if the payment mandate was not found"""
type PaymentMandateMandateNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""
Field we can use when ordering that can be applied when listing payment mandate results
"""
enum PaymentMandateOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing payment mandate results"""
input PaymentMandateOrderByInput {
  field: PaymentMandateOrderByFieldInput
  direction: OrderByDirection
}

"""
Rejection returned if the payment mandate reference is already used for the same creditor
"""
type PaymentMandateReferenceAlreadyUsedRejection implements Rejection {
  message: String!
}

"""Payment Mandate Rejected status information"""
type PaymentMandateRejectedStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Rejected for type PaymentMandateSuspendedStatusInfo).
  """
  status: PaymentMandateStatus!
}

enum PaymentMandateScheme {
  """SEPA Direct Debit Core"""
  SepaDirectDebitCore

  """SEPA Direct Debit B2B"""
  SepaDirectDebitB2b

  """Internal Direct Debit Standard"""
  InternalDirectDebitStandard

  """Internal Direct Debit B2B"""
  InternalDirectDebitB2b

  """Card Visa"""
  CardVisa

  """Card Mastercard"""
  CardMastercard

  """Card Cartes Bancaires"""
  CardCartesBancaires
}

"""Payment Mandate Sequence"""
enum PaymentMandateSequence {
  """The Payment Mandate can be used for recurrent collections"""
  Recurrent

  """The Payment Mandate can be used only once"""
  OneOff
}

"""Payment Mandate status"""
enum PaymentMandateStatus {
  ConsentPending
  Enabled
  Rejected
  Canceled
}

"""Payment Mandate status information"""
interface PaymentMandateStatusInfo {
  """Status of the payment mandate."""
  status: PaymentMandateStatus!
}

"""
Rejection returned when a payment method is not compatible for the requested mutation
"""
type PaymentMethodNotCompatibleRejection implements Rejection {
  message: String!
}

"""
Describes an identification level that is pending for the process of the current identification, requiring an operation not related to the end-user to progress
"""
type PendingIdentificationLevelStatusInfo {
  """Always set to `Pending`"""
  status: SwanIdentificationStatus!
}

"""PendingMerchantPaymentMethodStatusInfo"""
type PendingMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!
}

"""PendingReviewMerchantProfileStatusInfo"""
type PendingReviewMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
}

"""Pending Verification Information"""
type PendingReviewStatusInfo implements AccountVerificationStatusInfo {
  """Account verification status (PendingReview)"""
  status: AccountVerificationStatus!
}

"""Pending Verification Information"""
type PendingVerificationStatusInfo implements AccountVerificationStatusInfo {
  """Account verification status (PendingVerification)"""
  status: AccountVerificationStatus!
}

"""
E.164 standard format phone number

Examples
+551155256325
+44207183875
"""
scalar PhoneNumber

"""Physical Card"""
type PhysicalCard {
  """Physical Card status information"""
  statusInfo: PhysicalCardStatusInfo!

  """Physical Card expiration date  with MM/YY string format"""
  expiryDate: String

  """
  Unique identifier present on physical card, such identifier is null if the status is ToActivate or Canceled. This identifier is updated when a renewed card is activated
  """
  identifier: String

  """Offline Spending limit defined by Swan"""
  offlineSpendingLimit: Amount!

  """Masked Card Number"""
  cardMaskedNumber: String!

  """Custom Options"""
  customOptions: PhysicalCardCustomOptions!

  """every previous Physical Card information"""
  previousPhysicalCards: [BasicPhysicalCardInfo!]!
}

"""Physical Card Activated Status Information"""
type PhysicalCardActivatedStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Activated for type PhysicalCardEnabledStatusInfo).
  """
  status: PhysicalCardStatus!
}

"""Physical Card Canceled Status Information"""
type PhysicalCardCanceledStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Canceled for type PhysicalCardCanceledStatusInfo).
  """
  status: PhysicalCardStatus!

  """Reason why the card is canceled."""
  reason: String!
}

"""Physical Card Canceling Status Information"""
type PhysicalCardCancelingStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Canceling for type PhysicalCardCancelingStatusInfo).
  """
  status: PhysicalCardStatus!

  """Reason why the card is canceled."""
  reason: String!
}

"""when the user has to authorize production of the physical card"""
type PhysicalCardConsentPendingStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always ConsentPending for type PhysicalCardConsentPendingStatusInfo)
  """
  status: PhysicalCardStatus!

  """The consent required to authorize production of the physical card"""
  consent: Consent!
}

"""Custom options for physical card."""
type PhysicalCardCustomOptions {
  """Additional line embossed on the card."""
  additionalPrintedLine: String

  """Custom Card Holder Name"""
  customCardHolderName: String
}

"""when the physical card is in the process of being ready to use"""
type PhysicalCardProcessingStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical card status (always Processing for type PhysicalCardProcessingStatusInfo)
  """
  status: PhysicalCardStatus!
}

"""Input to simulate reception of a physical card"""
input PhysicalCardReceptionInput {
  """Unique identifier of a card"""
  cardId: ID!
}

union PhysicalCardReceptionPayload = PhysicalCardReceptionSuccessPayload | SimulationRejection | ValidationRejection

type PhysicalCardReceptionSuccessPayload {
  physicalCardIdentifier: String!
}

"""Possible physical card renewal status"""
enum PhysicalCardRenewalStatus {
  """Physical card is in the process of being renewed"""
  ToRenew

  """Physical card is renewed but hasn’t made a transaction since renewal"""
  Renewed
}

"""Physical Card Renewed Status Information"""
type PhysicalCardRenewedStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Renewed for type PhysicalCardRenewedStatusInfo).
  """
  status: PhysicalCardStatus!

  """address to deliver the physical card"""
  address: Address!

  """Estimated delivery date"""
  estimatedDeliveryDate: DateTime

  """Shipping tracking number"""
  trackingNumber: String

  """Name of the shipping provider (Ex: LaPoste, DHL ...)"""
  shippingProvider: String

  """`true` if PIN Code is available."""
  isPINReady: Boolean!

  """New physical Card info"""
  newPhysicalCard: BasicPhysicalCardInfo!
}

"""Physical Card Status"""
enum PhysicalCardStatus {
  """Consent to authorize physical card production is pending"""
  ConsentPending

  """Physical card is in processing and can’t be used yet"""
  Processing

  """Physical card is activated and can be used"""
  Activated

  """Physical card is suspended and can’t be used"""
  Suspended

  """Physical card is canceled, can’t be used, and can’t be restored"""
  Canceled

  """
  Physical card is in the process of being canceled; card can’t be used or restored
  """
  Canceling

  """Physical card needs to be activated by cardholder"""
  ToActivate

  """Physical card is in the process of being renewed"""
  ToRenew

  """Physical card is renewed but hasn’t made a transaction since renewal"""
  Renewed
}

"""Physical Card Status Information"""
interface PhysicalCardStatusInfo {
  """Status of the physical card."""
  status: PhysicalCardStatus!
}

"""Physical Card Suspended Status Information"""
type PhysicalCardSuspendedStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Suspended for type PhysicalCardSuspendedStatusInfo).
  """
  status: PhysicalCardStatus!

  """Reason why the card is suspended."""
  reason: String!
}

"""Physical Card To Activate Status Information"""
type PhysicalCardToActivateStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always ToActivate for type PhysicalCardToActivateStatusInfo).
  """
  status: PhysicalCardStatus!

  """address to deliver the physical card"""
  address: Address!

  """Estimated delivery date"""
  estimatedDeliveryDate: DateTime

  """Shipping tracking number"""
  trackingNumber: String

  """Name of the shipping provider (Ex: LaPoste, DHL ...)"""
  shippingProvider: String

  """`true` if PIN Code is available."""
  isPINReady: Boolean!
}

"""when the physical card is in the process of being renewed"""
type PhysicalCardToRenewStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical card status (always ToRenew for type PhysicalCardToRenewStatusInfo)
  """
  status: PhysicalCardStatus!

  """registered address to deliver the new physical card"""
  address: Address!
}

"""Rejection returned when the Physical Card is not the expected status"""
type PhysicalCardWrongStatusRejection implements Rejection {
  message: String!
  identifier: String!
  currentStatus: PhysicalCardStatus!
  expectedStatus: PhysicalCardStatus!
}

"""6 digits numeric passcode"""
scalar PIN

enum PreferredNotificationChannel {
  """Use Swan SMS"""
  Sms

  """Use In-App notification"""
  App
}

"""
Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
"""
enum ProductType {
  Goods
  Services
  VirtualGoods
  GiftsAndDonations
}

"""Thrown when a plan already has a subscription"""
type ProjectAlreadyHasSubscriptionRejection implements Rejection {
  message: String!
}

type ProjectForbiddenRejection implements Rejection {
  message: String!
}

"""Rejection returned when the Project Funding has been exceeded"""
type ProjectFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""Public information of a `Project`"""
type ProjectInfo {
  """Unique identifier of the project"""
  id: ID!
  B2BMembershipIDVerification: Boolean

  """
  Your project name displayed in white label interfaces and in the terms and conditions
  """
  name: String!

  """The type of your project"""
  type: ProjectType!

  """URL of your logo"""
  logoUri: String

  """
  Your accent color, used in white label interfaces. Most of the time for call to actions
  """
  accentColor: String

  """Your custom subdomain used in consents"""
  customConsentSubdomain: String

  """Your OAuth client id"""
  oAuthClientId: String

  """
  URL to your Terms and Conditions of Use document depending on the provided language
  """
  tcuDocumentUri(
    """
    this consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)
    """
    language: String!
  ): String!

  """Unique id of your current Terms and Conditions of Use"""
  tcuDocumentId: String!

  """Web banking settings"""
  webBankingSettings: WebBankingSettings

  """Project status"""
  status: ProjectStatus!

  """
  Flag that determines if desktop authentication is enabled for this project
  """
  allowsDesktopAuthentication: Boolean!

  """The related project settings"""
  projectSettingsId: ID!
}

"""
Rejection returned when the Project Instant Funding limit has been exceeded
"""
type ProjectInstantFundingLimitExceededRejection implements Rejection {
  message: String!
}

type ProjectInvalidStatusRejection implements Rejection {
  message: String!
}

type ProjectNotFound implements Rejection {
  message: String!
}

type ProjectSettingsForbiddenError implements Rejection {
  message: String!
}

type ProjectSettingsNotFound implements Rejection {
  message: String!
}

type ProjectSettingsStatusNotReachable implements Rejection {
  message: String!
}

enum ProjectStatus {
  Initiated
  MeetingScheduled
  ToReview @deprecated(reason: "replaced by `PendingCompliance`")
  PendingCompliance
  LimitedLiveAccess
  BetaLiveAccess
  Enabled @deprecated(reason: "replaced by `LimitedLiveAccess`")
  FullLiveAccess
  Disabled
  Suspended
  Rejected
  PendingLiveReview
}

enum ProjectType {
  INDIVIDUAL @deprecated(reason: "replaced by `Individual`")
  COMPANY @deprecated(reason: "replaced by `Company`")
  COMPANY_AND_CUSTOMERS @deprecated(reason: "replaced by `CompanyAndCustomers`")
  Individual
  Company
  CompanyAndCustomers
}

input PromoteAccountHolderToProjectOwnerInput {
  """Unique identifier of account holder"""
  accountHolderId: ID!
}

union PromoteAccountHolderToProjectOwnerPayload = PromoteAccountHolderToProjectOwnerSuccessPayload | ForbiddenRejection | AccountHolderNotFoundRejection

type PromoteAccountHolderToProjectOwnerSuccessPayload {
  accountHolder: AccountHolder!
}

"""The different response that Swan can give to a provisioning request"""
enum ProvisioningResponse {
  """
  No OTP will be sent before validation
  Can happen in Live if the cardHolder is trusted by the wallet provider (Adding a card to the watch after adding it to the iPhone)
  """
  NoOTP

  """An OTP will be sent to the cardHolder"""
  OTP

  """Provisioning request will be declined"""
  Decline
}

type PurposeWithOperations {
  purpose: ConsentPurpose!
  operations: [ConsentOperation!]!
}

type Query {
  """
  Returns sandbox user data of active user.
  Active user is the user who runs the query with their token.
  This query is restricted to a User access token
  """
  sandboxUser: SandboxUser!

  """
  Returns sandbox user data of provided user ID
  This query is restricted to a User access token
  """
  sandboxUserById(id: ID!): SandboxUser

  """
  Returns a list of sandbox users data
  This query is restricted to a User access token
  """
  sandboxUsers(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to start at a specific offset"""
    offset: Int

    """When the list of elements needs to be ordered"""
    orderBy: SandboxUsersOrderByInput
  ): SandboxUserConnection
}

type RadioField implements Field {
  key: String!
  name: String!
  refreshDynamicFieldsOnChange: Boolean!
  required: Boolean!
  allowedValues: [AllowedValue!]!
}

"""Define a reason with a message"""
interface Reason {
  message: String
}

"""Input version"""
input ReasonInput {
  message: String
}

"""Interface for Received Direct Debit Mandate"""
interface ReceivedDirectDebitMandate {
  """
  Unique identifier of the received direct debit mandate, generated by Swan
  """
  id: ID!

  """Version of the received direct debit mandate"""
  version: String!

  """Creation date of the received direct debit mandate"""
  createdAt: DateTime!

  """Last Update date of the received direct debit mandate"""
  updatedAt: DateTime!

  """Date of signature of the received direct debit mandate"""
  signatureDate: Date

  """
  Date of the last direct debit transaction executed for the concerned received direct debit mandate
  """
  executedAt: DateTime

  """Expiry date of the received direct debit mandate"""
  expiredAt: Date

  """Mandate status information of the received direct debit mandate"""
  statusInfo: ReceivedDirectDebitMandateStatusInfo!

  """Mandate name"""
  name: String
}

"""Rejection returned if the received direct debit mandate already exist"""
type ReceivedDirectDebitMandateAlreadyExistRejection implements Rejection {
  id: String!
  message: String!
}

"""
Received direct debit mandate is canceled and therefore can't be enabled/suspended or updated
"""
type ReceivedDirectDebitMandateCanceledRejection implements Rejection {
  id: String!
  message: String!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type ReceivedDirectDebitMandateConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ReceivedDirectDebitMandateEdge list"""
  edges: [ReceivedDirectDebitMandateEdge!]!
}

"""Implements the Relay Edge interface"""
type ReceivedDirectDebitMandateEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The received direct debit mandate"""
  node: ReceivedDirectDebitMandate!
}

"""
Rejection returned if the received direct debit mandate is not a B2b mandate
"""
type ReceivedDirectDebitMandateNotB2bRejection implements Rejection {
  id: String!
  message: String!
}

"""
Error returned if the received direct debit mandate was not found or if the user does not have the rights to receive information abo
ut the existence of the received direct debit mandate
"""
type ReceivedDirectDebitMandateNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Received Direct Debit Mandate Scheme"""
enum ReceivedDirectDebitMandateScheme {
  """
  When the received direct debit mandate can only be used for SEPA B2B direct debit transactions
  """
  SepaDirectDebitB2b

  """
  When the received direct debit mandate can only be used for SEPA Core direct debit transactions
  """
  SepaDirectDebitCore
}

"""Received Direct Debit Mandate Statuses"""
enum ReceivedDirectDebitMandateStatus {
  """When the received direct debit mandate is enabled"""
  Enabled

  """When the received direct debit mandate is suspended"""
  Suspended

  """When the received direct debit mandate is canceled"""
  Canceled

  """
  When the received direct debit mandate requires the initiation of a consent process
  """
  ConsentInitiationPending

  """When the received direct debit mandate is pending consent completion"""
  ConsentPending
}

"""Received Direct Debit Mandate status information"""
interface ReceivedDirectDebitMandateStatusInfo {
  """Received Direct Debit Mandate status"""
  status: ReceivedDirectDebitMandateStatus!
}

"""Received Direct Debit Mandate Canceled status information"""
type ReceivedDirectDebitMandateStatusInfoCanceled implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always Canceled for type ReceivedDirectDebitMandateStatusInfoCanceled)
  """
  status: ReceivedDirectDebitMandateStatus!

  """Date of cancellation"""
  canceledAt: DateTime!
}

"""
Received Direct Debit Mandate ConsentInitiationPending status information
"""
type ReceivedDirectDebitMandateStatusInfoConsentInitiationPending implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentInitiationPending)
  """
  status: ReceivedDirectDebitMandateStatus!
}

"""Received Direct Debit Mandate ConsentPending status information"""
type ReceivedDirectDebitMandateStatusInfoConsentPending implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentPending)
  """
  status: ReceivedDirectDebitMandateStatus!

  """The consent required to consent to a received direct debit mandate"""
  consent: Consent!
}

"""Received Direct Debit Mandate Enabled status information"""
type ReceivedDirectDebitMandateStatusInfoEnabled implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always Enabled for type ReceivedDirectDebitMandateStatusInfoEnabled)
  """
  status: ReceivedDirectDebitMandateStatus!

  """
  Date at which the received direct debit mandate has been moved to the enabled status
  """
  enabledAt: DateTime!
}

"""Received Direct Debit Mandate Suspended status information"""
type ReceivedDirectDebitMandateStatusInfoSuspended implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always Suspended for type ReceivedDirectDebitMandateStatusInfoSuspended)
  """
  status: ReceivedDirectDebitMandateStatus!

  """
  Date of the last time the received direct debit mandate has been moved to the suspended status
  """
  suspendedAt: DateTime!
}

"""RejectedMerchantPaymentMethodStatusInfo"""
type RejectedMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method rejected date"""
  rejectedAt: Date!
}

"""RejectedMerchantProfileStatusInfo"""
type RejectedMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  rejectedAt: Date!
}

"""Rejected Verification Reason"""
enum RejectedVerificationReason {
  HolderDidNotMatch
}

"""Rejected Information"""
type RejectedVerificationStatusInfo implements AccountVerificationStatusInfo {
  """Rejected Reason"""
  reason: RejectedVerificationReason!

  """Date at which the verification was rejected"""
  rejectedAt: DateTime!

  """Account verification status (Rejected)"""
  status: AccountVerificationStatus!
}

interface Rejection {
  message: String!
}

type RejectionReasonMandatoryRejection implements Rejection {
  message: String!
}

"""Success payload type"""
type ReleaseReservedBalanceSuccessPayload {
  transactionId: ID!
}

"""The document corresponding to a identification report"""
type ReportDocument {
  """Unique identifier of the report document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """List of the associated files"""
  files: [ReportDocumentFile!]!
}

"""The file associated to the report document"""
type ReportDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!
}

"""Request Update Merchant Profile"""
type RequestMerchantProfileUpdate {
  """The Request ID"""
  id: ID!

  """The Merchant Profile ID to update"""
  merchantProfileId: ID!

  """
  Business name of the merchant, i.e. name that will be displayed on debtors' bank statements
  """
  merchantName: String!

  """Url of the merchant's website"""
  merchantWebsite: String

  """Url of the merchant's logo"""
  merchantLogoUrl: String

  """The status of the request"""
  status: RequestMerchantProfileUpdateStatus!

  """
  Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
  """
  productType: ProductType!

  """Expected annual activity volumes for all payment method"""
  expectedMonthlyPaymentVolume: Amount!

  """expected average basket value."""
  expectedAverageBasket: Amount!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!
}

"""Request Merchant Profile Update Statuses"""
enum RequestMerchantProfileUpdateStatus {
  """A Request is created in the PendingReview status"""
  PendingReview

  """A Request that has already been approved"""
  Enabled

  """A Request that has already been rejected"""
  Rejected

  """A Request that has been canceled by the user"""
  Canceled
}

"""Request Outcome Merchant Profile Status Input"""
input RequestOutcomeMerchantPaymentMethodInput {
  methodType: MerchantPaymentMethodType!

  """Status to which to move the related payment product"""
  status: MerchantPaymentMethodStatus!
}

input RequestSupportingDocumentsInput {
  supportingDocumentCollectionId: ID!
  requiredSupportingDocumentPurposes: [SupportingDocumentPurposeEnum!]!
}

union RequestSupportingDocumentsPayload = RequestSupportingDocumentsSuccessPayload | AccountHolderNotFoundRejection | SupportingDocumentCollectionNotFoundRejection | ForbiddenRejection | InternalErrorRejection

type RequestSupportingDocumentsSuccessPayload {
  supportingDocumentCollection: SupportingDocumentCollection!
}

"""The document corresponding to a residence permit"""
type ResidencePermitDocument {
  """Unique identifier of the residence permit document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """The date at which the residence permit was issued"""
  issueDate: Date

  """The date at which the residence permit expires"""
  expiryDate: Date

  """Machine-readable zone code of the residence permit"""
  mrz: String

  """Number of the residence permit"""
  number: String

  """List of the associated files"""
  files: [ResidencePermitDocumentFile!]!
}

"""The file associated to the resident permit document"""
type ResidencePermitDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!

  """From which side the residence permit's picture was taken"""
  side: DocumentFileSide!
}

input ResidencyAddressInput {
  """Address line 1. Length must be from 0 to 255 characters"""
  addressLine1: String

  """AddressLine2. Length must be from 0 to 255 characters"""
  addressLine2: String

  """City. Length must be from 0 to 100 characters"""
  city: String

  """Postal code. Length must be from 0 to 50 characters"""
  postalCode: String

  """State of residency. Length must be from 0 to 100 characters"""
  state: String

  """Country"""
  country: CCA3
}

"""
The channels that can be used to send the OTP and the end of provisioning message
"""
enum ResponseChannel {
  SMS
}

"""Account membership restricted to"""
type RestrictedTo {
  """first name"""
  firstName: String!

  """last name"""
  lastName: String!

  """birth date"""
  birthDate: Date

  """
  phone number
  We're introducing more flexibility in the process to invite & bind new account members (cf [public roadmap](https://swanio.notion.site/Swan-Public-Roadmap-385e4b2e91b3409786a6c8e885654a22?p=a59db00a478e4faaaefbd901e1ed7ed3&pm=s) on notion).
  For some use cases, it would be possible to invite an account member without their mobile phone number.
  Please note that the phone number will remain mandatory at the invitation (despite being optional in the Graph) until the new flow is delivered. It is hidden behind a feature toggle
  """
  phoneNumber: String
}

"""
Percentage over a number of business days, that is applied to all funds collected to compute a Reserved amount
This amount cannot be used over the corresponding business days
"""
type RollingReserve {
  """Percentage of the funding amount to be reserved"""
  percentage: Int!

  """Number of business days the computed amount is reserved"""
  rollingDays: Int!
}

type SandboxIdentification {
  """Unique identifier of the identification"""
  id: String!
}

type SandboxIdentificationNotFoundRejection implements Rejection {
  message: String!
}

"""
To make your integration with Swan as seamless as possible, we allow you to create as many Sandbox users as you want from Swan.
Sandbox users make it possible to simulate the different processes you may encounter with your real users, once you go live.
You can simulate different onboarding scenarios and processes, or practice managing the user rights of your accounts.

Read more about sandbox users [on the documentation](https://docs.swan.io/concept/user#sandbox-users)
"""
type SandboxUser {
  """Sandbox user ID"""
  id: ID!

  """
  Mobile phone number with the international format
  Example: +33689788967
  """
  mobilePhoneNumber: PhoneNumber

  """Last name"""
  lastName: String

  """First name"""
  firstName: String

  """List of first names"""
  allFirstNames: [String!]

  """Birth Date"""
  birthDate: Date

  """Birth City"""
  birthCity: String

  """
  [Alpha-3 birth country representation](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  """
  birthCountryCCA3: CCA3

  """
  [Alpha-3 nationality representation](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  Ex: FRA for french nationality
  """
  nationalityCCA3: CCA3

  """
  Indicates wether the user has verified his/her identity or not
  @deprecated Use the equivalent identificationLevels.expert field instead
  """
  idVerified: Boolean @deprecated(reason: "Use the equivalent `identificationLevels.expert` field instead")

  """
  Saves you considerable time during the development phase,
  by automatically allowing consent,
  removing the need to repeatedly get consent.
  """
  autoConsent: Boolean!

  """
  Preferred notification channel
  
  When it is "null" it means that the preferences have not been updated. Default SMS in use
  """
  preferredNotificationChannel: PreferredNotificationChannel

  """
  List of identification levels available for the user.
  
  Whenever TRUE, it means the identification was successful for the associated level.
  """
  identificationLevels: IdentificationLevels

  """Indicates if sandbox user is logged or not"""
  isActive: Boolean
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)).
"""
type SandboxUserConnection implements Connection {
  """Total number of element in the list."""
  totalCount: Int!

  """Information about the current, the previous and the next page."""
  pageInfo: PageInfo!

  """SandboxUserEdge list."""
  edges: [SandboxUserEdge!]!
}

"""Implements the Relay Edge interface."""
type SandboxUserEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism."""
  cursor: String!

  """The sandbox user."""
  node: SandboxUser!
}

"""Rejection returned when sandbox user doesn't exist"""
type SandboxUserNotFoundRejection implements Rejection {
  """Rejection message"""
  message: String!

  """Sandbox user ID"""
  userId: String!
}

"""
Field we can use when ordering that can be applied when listing sandbox users results
"""
enum SandboxUsersOrderByFieldInput {
  createdAt
  updatedAt
}

input SandboxUsersOrderByInput {
  field: SandboxUsersOrderByFieldInput
  direction: OrderByDirection
}

"""Rejection returned when adding a B2B mandate with an Individual debtor"""
type SchemeWrongRejection implements Rejection {
  message: String!
}

type SelectField implements Field {
  key: String!
  name: String!
  refreshDynamicFieldsOnChange: Boolean!
  required: Boolean!
  allowedValues: [AllowedValue!]!
}

"""Sepa beneficiary account"""
input SepaBeneficiaryInput {
  """International Bank Account Number"""
  iban: IBAN!

  """
  Full name of the beneficiary (min 2 characters, max 70 characters). The name should not include any special characters.
  """
  name: String!

  """beneficiary address"""
  address: AddressInput

  """
  `true` if this new beneficiary is the account holder himself in another financial institution.
  """
  isMyOwnIban: Boolean!

  """
  `true` if this new beneficiary will be saved to the beneficiary list of the debited account.
  """
  save: Boolean!
}

"""
SEPA Creditor Identifier
format :
    1 – 2: ISO Country Code
    3 – 4: Check Digit
    5 – 7: Creditor Business Code – you (Creditor) choose this. The default is ZZZ
    8 - 35: Creditor National Identifier – a consecutive number that will be assigned by country
example:
    FR11ABC123456
"""
scalar SepaCreditorIdentifier

"""List of recalled reasons"""
enum SepaCreditTransferRecalledReasonCodeEnum {
  BeneficiaryAccountIncorrect
  NotSpecifiedByOriginator
  TransactionAmountIncorrect
}

"""List of Recall reasons"""
enum SepaCreditTransferRecallReasonCodeEnum {
  BeneficiaryAccountIncorrect
  NotSpecifiedByOriginator
  TechnicalIssueOccurred
  TransactionAmountIncorrect
  TransactionDuplicated
  TransactionFraudulent
}

"""List of rejection reasons"""
enum SepaCreditTransferRejectionReasonCodeEnum {
  AccountClosed
  AccountHolderDeceased
  AccountLimited
  AccountSuspended
  AccountUnknown
  AmountExceedsSettlementLimit
  BankOperationCodeInvalid
  BeneficiaryBankBicInvalid
  BeneficiaryBankBicNotFound
  BeneficiaryBankNotReachable
  CreditorAddressMissing
  CreditorAgentSuspended
  CreditorBankOffline
  CreditorBankTechnicalErrorOccurred
  CreditorBankTimeout
  CreditorNameOrAddressMissing
  DebtorAccountOrIdMissing
  DebtorBankTimeout
  DebtorNameOrAddressMissing
  InsufficientFunds
  InvalidTransferDate
  PaymentNotReceived
  ReasonNotSpecifiedByBank
  ReasonNotSpecifiedByCreditor
  RejectedByCompliance
  TransactionAmountLimitExceeded
  TransactionDuplicated
  TransactionOnAccountTypeNotAllowed
}

"""List of return reasons"""
enum SepaCreditTransferReturnedReasonCodeEnum {
  BankOperationCodeInvalid
  BeneficiaryAccountBlocked
  BeneficiaryAccountClosed
  BeneficiaryAccountNotFound
  BeneficiaryAddressMissing
  BeneficiaryBankEriNotAllowed
  BeneficiaryBankNotRegisteredCsm
  BeneficiaryDeceased
  BeneficiaryNameOrAddressInsufficientByRegulatory
  BicIncorrect
  NotSpecified
  NotSpecifiedByBeneficiary
  OriginatorAccountOrIdInsufficientByRegulatory
  OriginatorNameOrAddressInsufficientByRegulatory
  PotentialHitBeneficiaryByRegulatory
  TransactionDuplicated
  TransactionNotAllowedOnAccountType
}

"""List of return reasons"""
enum SepaCreditTransferReturnReasonCodeEnum {
  NotSpecifiedByBeneficiary
}

"""SDD Account input"""
input SepaDirectDebitAccount {
  """Address input"""
  address: AddressInput

  """
  Your Swan IBAN if you want to receive or send a credit transfer in or from your Swan account
  """
  iban: IBAN!

  """Name of the account holder"""
  name: String!

  """SEPA creditor identifier"""
  identifier: SepaCreditorIdentifier!

  """Creditor ultime name"""
  ultimateName: String
}

"""SepaDirectDebitB2BMerchantPaymentMethod"""
type SepaDirectDebitB2BMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve

  """Whether this payment method uses the Swan Sepa Creditor Identifier"""
  useSwanSepaCreditorIdentifier: Boolean!

  """
  When the above is false, the value of the Sepa Creditor Identifier used
  """
  sepaCreditorIdentifier: String
  updateRequest: SepaDirectDebitPaymentMethodUpdateRequest
}

"""List of SDD cancel reasons"""
enum SepaDirectDebitCancelReasonCodeEnum {
  AgentIncorrect
  InvestigationRequestReceived
  NotSpecifiedByOriginator
  PaymentUndue
  TransactionDuplicated
}

"""SepaDirectDebitCoreMerchantPaymentMethod"""
type SepaDirectDebitCoreMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve

  """Whether this payment method uses the Swan Sepa Creditor Identifier"""
  useSwanSepaCreditorIdentifier: Boolean!

  """
  When the above is false, the value of the Sepa Creditor Identifier used
  """
  sepaCreditorIdentifier: String
  updateRequest: SepaDirectDebitPaymentMethodUpdateRequest
}

interface SEPADirectDebitMandate {
  """
  Unique identifier of the received direct debit mandate, generated by Swan
  """
  id: ID!
}

type SepaDirectDebitPaymentMethodUpdateRequest implements MerchantPaymentMethodUpdateRequest {
  id: ID!

  """
  If `true`, the transaction will be created with the Swan Creditor Identifier
  """
  useSwanSepaCreditorIdentifier: Boolean!

  """
  Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false
  """
  sepaCreditorIdentifier: String
}

"""List of SDD reject reasons"""
enum SepaDirectDebitRejectReasonCodeEnum {
  NotSpecifiedByPayer
}

"""List of SDD return reasons"""
enum SepaDirectDebitReturnReasonCodeEnum {
  DebtorAccountBlocked
  DebtorAccountClosed
  MandateInvalid
  NotSpecifiedByBank
  NotSpecifiedByPayer
  RefundRequestedByDebtor
  RegulatorReason
  TransactionDuplicated
  TransactionNotAllowedOnAccountType
}

"""List of SDD reverse reasons"""
enum SepaDirectDebitReverseReasonCodeEnum {
  NotSpecifiedByBank
  NotSpecifiedByOriginator
  TransactionDuplicated
}

"""Payment direct debit mandate for SEPA"""
type SEPAPaymentDirectDebitMandate implements SEPADirectDebitMandate & PaymentDirectDebitMandate & PaymentMandate {
  """Unique identifier of the SEPA Direct Debit Payment Mandate"""
  id: ID!

  """Unique reference of the SEPA Direct Debit Payment Mandate"""
  reference: String!

  """SEPA Direct Debit Payment Mandate scheme"""
  scheme: SEPAPaymentMandateScheme!

  """SEPA Direct Debit Payment Mandate status information"""
  statusInfo: PaymentMandateStatusInfo!

  """SEPA Direct Debit Payment Mandate sequence"""
  sequence: PaymentMandateSequence!

  """SEPA Direct Debit Payment Mandate PDF document URL"""
  mandateDocumentUrl: String!

  """SEPA Direct Debit Payment Mandate debtor information"""
  debtor: SEPAPaymentMandateDebtor!

  """SEPA direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """SEPA Direct Debit Payment Mandate creditor information"""
  creditor: SEPAPaymentMandateCreditor!

  """Signature date of the SEPA Direct Debit Payment Mandate"""
  signatureDate: Date

  """Creation date of the SEPA Direct Debit Payment Mandate"""
  createdAt: DateTime!

  """Last Update date of the SEPA Direct Debit Payment Mandate"""
  updatedAt: DateTime!

  """
  Date of the the last transaction executed for the concerned SEPA Direct Debit Payment Mandate
  """
  executedAt: DateTime

  """Expiry date of the SEPA Direct Debit Payment Mandate"""
  expiredAt: Date

  """Account Holder information"""
  accountHolder: AccountHolder!

  """Custom name of the mandate"""
  name: String
}

type SEPAPaymentMandateCreditor implements PaymentMandateCreditor {
  """SEPA Direct Debit Payment Mandate creditor UUID"""
  id: ID!

  """SEPA Direct Debit Payment Mandate Sepa Creditor Idenfier (SCI)"""
  identifier: SepaCreditorIdentifier!

  """SEPA Direct Debit Payment Mandate creditor name"""
  name: String!

  """SEPA Direct Debit Payment Mandate creditor address"""
  address: Address!
}

type SEPAPaymentMandateDebtor implements PaymentMandateDebtor {
  """SEPA Direct Debit Payment Mandate debtor name"""
  name: String!

  """SEPA Direct Debit Payment Mandate debtor IBAN"""
  iban: IBAN!

  """SEPA Direct Debit Payment Mandate debtor e-mail"""
  email: String

  """SEPA Direct Debit Payment Mandate debtor country"""
  country: CCA3!

  """
  SEPA Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries
  """
  address: Address
}

enum SEPAPaymentMandateScheme {
  """SEPA Direct Debit Core"""
  SepaDirectDebitCore

  """SEPA Direct Debit B2B"""
  SepaDirectDebitB2b
}

"""Received direct debit mandate for SEPA"""
type SEPAReceivedDirectDebitMandate implements ReceivedDirectDebitMandate & SEPADirectDebitMandate {
  """
  Unique identifier of the received SEPA direct debit mandate, generated by Swan
  """
  id: ID!

  """Version of the received SEPA direct debit mandate"""
  version: String!

  """Creation date of the received SEPA direct debit mandate"""
  createdAt: DateTime!

  """Last Update date of the received SEPA direct debit mandate"""
  updatedAt: DateTime!

  """Received SEPA direct debit Unique Mandate Reference (UMR)"""
  reference: String!

  """Received SEPA direct debit mandate scheme"""
  scheme: SEPAReceivedDirectDebitMandateScheme!

  """Received SEPA direct debit mandate sequence"""
  sequence: SEPAReceivedDirectDebitMandateSequence!

  """Received SEPA direct debit creditor"""
  creditor: SEPAReceivedDirectDebitMandateCreditor!

  """Received SEPA direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """
  Date of the last SEPA direct debit transaction executed for the concerned received SEPA direct debit mandate
  """
  executedAt: DateTime

  """Date of signature of the received SEPA direct debit mandate"""
  signatureDate: Date

  """
  Expiry date of the received SEPA direct debit mandate, computed automatically (36 months from the executedAt date)
  """
  expiredAt: Date

  """Mandate status information of the received SEPA direct debit mandate"""
  statusInfo: ReceivedDirectDebitMandateStatusInfo!

  """Account of the received SEPA direct debit mandate debtor"""
  account: Account

  """Iban of the received SEPA direct debit mandate debtor"""
  iban: IBAN!

  """Mandate name"""
  name: String
}

"""SEPA received direct debit mandate creditor"""
type SEPAReceivedDirectDebitMandateCreditor {
  """SEPA Creditor identifier (SCI)"""
  identifier: String!

  """Name of the SEPA creditor"""
  name: String!

  """Address of the SEPA creditor"""
  address: Address!
}

"""Received SEPA direct debit mandate scheme"""
enum SEPAReceivedDirectDebitMandateScheme {
  """
  When the received SEPA direct debit mandate can only be used for SEPA B2B direct debit transactions
  """
  SepaDirectDebitB2b

  """
  When the received SEPA direct debit mandate can only be used for SEPA Core direct debit transactions
  """
  SepaDirectDebitCore
}

"""SEPA received direct debit mandate sequence"""
enum SEPAReceivedDirectDebitMandateSequence {
  """
  When the authorisation is given once by the SEPA Debtor to collect only one single SEPA direct debit
  """
  OneOff

  """
  When the authorisation by the Debtor can be used for regular SEPA direct debits initiated by the Creditor
  """
  Recurrent
}

"""Received SEPA direct debit mandate type"""
enum SEPAReceivedDirectDebitMandateType {
  """
  When the received SEPA direct debit mandate can only be used for SEPA B2B direct debit transactions
  """
  B2B

  """
  When the received SEPA direct debit mandate can only be used for SEPA Core direct debit transactions
  """
  Core
}

"""
SEPA Identifier
max 35 Latin characters as follow :
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    0 1 2 3 4 5 6 7 8 9
    / - ? : ( ) . , '  +
with some follow extra rules :
    Content must not start or end with a ‘/’
    Content must not contain ‘//’s
"""
scalar SepaReference

"""Shareholder of a company creating a Capital Deposit Case"""
type Shareholder {
  """Unique identifier of a shareholder."""
  id: ID!

  """Amount the shareholder has to deposit."""
  capitalDepositAmount: Amount!

  """Onboarding information of the shareholder."""
  onboarding: Onboarding

  """Unique identifier of the shareholder account."""
  accountId: String

  """Status of the shareholder during the process with Swan."""
  status: ShareholderStatus!

  """Extra information about the shareholder"""
  info: ShareholderInfo!

  """Shareholder documents for the capital deposit case"""
  documents: [CapitalDepositDocument!]!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Information about capital deposit case."""
  relatedCapitalDepositCase: CapitalDepositCase!
}

"""Shareholder information."""
union ShareholderInfo = IndividualShareholder | CompanyShareholder

"""Status of the shareholder during the process with Swan."""
enum ShareholderStatus {
  """Waiting for the shareholder to finalize their onboarding."""
  PendingOnboarding

  """Waiting for Swan compliance team to verify the shareholder."""
  WaitingForVerification

  """
  Waiting for the shareholder to wire their share of the capital on their temporary Swan account.
  """
  WaitingForTransfer

  """When the shareholder has wired their share of the capital."""
  CapitalTransferred

  """When the shareholder's capital is wired to the notary."""
  CapitalFundsWiredToNotary

  """When the capital deposit of the shareholder is canceled."""
  CapitalDepositCanceled
}

"""Shareholder type to identify individuals and companies."""
enum ShareholderType {
  """Individual shareholder type."""
  Individual

  """Company shareholder type."""
  Company
}

"""Inputs to approve a capital deposit case."""
input SimulateApproveCapitalDepositCaseInput {
  """Identifier of capital deposit case to validated."""
  capitalDepositCaseId: String!
}

union SimulateApproveCapitalDepositCasePayload = SimulateApproveCapitalDepositCaseSuccessPayload | CouldNotFindCapitalDepositCaseRejection

type SimulateApproveCapitalDepositCaseSuccessPayload {
  id: String!
}

"""
Inputs to update a capital deposit document status.
Automatically uploads the document if the document status in input is UPLOADED.
"""
input SimulateCapitalDepositDocumentStatusInput {
  """Identifier of capital deposit document."""
  documentId: String!

  """Status of capital deposit document."""
  documentStatus: CapitalDepositDocumentStatus!

  """Document refusal reason code for refused capital deposit document."""
  documentRefusalReasonCode: DocumentReasonCode
}

union SimulateCapitalDepositDocumentStatusPayload = SimulateCapitalDepositDocumentStatusSuccessPayload | CouldNotFindCapitalDepositCaseRejection | CouldNotUpdateCapitalDepositDocumentStatusRejection | CouldNotUploadCapitalDepositDocumentRejection | CouldNotFindCapitalDepositDocumentRejection | CouldNotRejectCapitalDepositDocumentRejection

type SimulateCapitalDepositDocumentStatusSuccessPayload {
  id: String!
}

"""Input of simulateCardTransactionEnrichment mutation"""
input SimulateCardTransactionEnrichmentInput {
  """Card transaction id"""
  transactionId: ID!

  """Merchant address, if nothing entered genereted randomly"""
  address: String

  """
  Transaction carbon footprint in micrograms of CO2 emitted, if nothing entered genereted randomly
  """
  carbonFootprint: String

  """Merchant category, if nothing entered default to 'Other'"""
  category: MerchantCategory

  """Merchant city, if nothing entered genereted randomly"""
  city: String

  """Merchant email, if nothing entered default to 'noreply@swan.io'"""
  contactEmail: String

  """Merchant phone number, if nothing entered default to '+33123456789'"""
  contactPhone: String

  """
  Merchant website, if nothing entered default to 'https://www.swan.io/contact'
  """
  contactWebsite: String

  """Merchant country, if nothing entered genereted randomly"""
  country: CCA3

  """Enhanced merchant name, if nothing entered genereted randomly"""
  enrichedMerchantName: String

  """Is transaction a subcription, if nothing entered default to false"""
  isSubscription: Boolean

  """Merchant latitude, if nothing entered genereted randomly"""
  latitude: String

  """Merchant longitude, if nothing entered genereted randomly"""
  longitude: String

  """Merchant postal code, if nothing entered genereted randomly"""
  postalCode: String

  """Merchant subcategory, if nothing entered default to 'Other'"""
  subcategory: MerchantSubCategory
}

union SimulateCardTransactionEnrichmentPayload = SimulateCardTransactionEnrichmentSuccessPayload | SimulateCardTransactionEnrichmentRejection | ForbiddenRejection

type SimulateCardTransactionEnrichmentRejection implements Rejection {
  message: String!
}

type SimulateCardTransactionEnrichmentSuccessPayload {
  transactionId: ID!
  enrichedData: EnrichedTransactionInfo!
}

input SimulateIncomingCardAuthorizationAuthorization {
  status: SimulateIncomingCardAuthorizationStatus!
  rejectionReason: String
}

enum SimulateIncomingCardAuthorizationCardCategory {
  Commercial
  Consumer
}

input SimulateIncomingCardAuthorizationCardDetails {
  scheme: SimulateIncomingCardAuthorizationCardScheme!
  category: SimulateIncomingCardAuthorizationCardCategory!
  type: SimulateIncomingCardAuthorizationCardType!
  country: String!
}

enum SimulateIncomingCardAuthorizationCardScheme {
  Visa
  Mastercard
  CartesBancaires
}

enum SimulateIncomingCardAuthorizationCardType {
  Credit
  Debit
  Prepaid
  Charge
  DeferredDebit
}

input SimulateIncomingCardAuthorizationInput {
  """ID of the related payment link"""
  paymentLinkId: ID!
  authorization: SimulateIncomingCardAuthorizationAuthorization!
  threeDS: SimulateIncomingCardAuthorizationThreeDS!
  cardDetails: SimulateIncomingCardAuthorizationCardDetails!
}

"""SimulateIncomingCardAuthorizationPayload"""
union SimulateIncomingCardAuthorizationPayload = InternalErrorRejection | ForbiddenRejection | NotFoundRejection | SimulateIncomingCardAuthorizationSuccessPayload | ValidationRejection

enum SimulateIncomingCardAuthorizationStatus {
  Authorized
  Rejected
}

"""SimulateIncomingCardAuthorizationSuccessPayload"""
type SimulateIncomingCardAuthorizationSuccessPayload {
  paymentLinkId: ID!
  cardMandateId: ID!
  paymentId: ID!
}

input SimulateIncomingCardAuthorizationThreeDS {
  status: SimulateIncomingCardAuthorizationThreeDSStatus!
  rejectionReason: String
}

enum SimulateIncomingCardAuthorizationThreeDSStatus {
  Successful
  Failed
}

"""Book an incoming card transaction simulation input"""
input SimulateIncomingCardBookingInput {
  """Transaction ID to be booked"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingCardBookingPayload = SimulateIncomingCardBookingSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingCardBookingSuccessPayload {
  transactionId: ID!
}

"""Book an incoming check simulation input"""
input SimulateIncomingCheckBookingInput {
  """Transaction ID to be booked"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingCheckBookingPayload = SimulateIncomingCheckBookingSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingCheckBookingSuccessPayload {
  transactionId: ID!
}

type SimulateIncomingCheckRejectionErrorPayload {
  reason: String!
}

"""Reject incoming Check simulation input"""
input SimulateIncomingCheckRejectionInput {
  """Transaction ID to be Rejected"""
  transactionId: ID!

  """Rejection reason code"""
  reasonCode: IncomingCheckRejectionReasonCodeEnum
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingCheckRejectionPayload = SimulateIncomingCheckRejectionSuccessPayload | SimulateIncomingCheckRejectionErrorPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingCheckRejectionSuccessPayload {
  transactionId: ID!
}

"""Return a booked incoming check simulation input"""
input SimulateIncomingCheckReturnInput {
  """Transaction ID to be booked"""
  transactionId: ID!

  """Return reason code"""
  reasonCode: CheckReturnReasonCodeEnum
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingCheckReturnPayload = SimulateIncomingCheckReturnSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingCheckReturnSuccessPayload {
  transactionId: ID!
}

"""Book an outgoing transfer simulation input"""
input SimulateIncomingInternalDirectDebitBookingInput {
  """Transaction ID to be booked"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingInternalDirectDebitBookingPayload = SimulateIncomingInternalDirectDebitBookingSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingInternalDirectDebitBookingSuccessPayload {
  transactionId: ID!
}

type SimulateIncomingInternalDirectDebitRejectionErrorPayload {
  reason: String!
}

"""Reject incoming SEPA Direct Debit simulation input"""
input SimulateIncomingInternalDirectDebitRejectionInput {
  """Transaction ID to be Rejected"""
  transactionId: ID!

  """Rejection reason code"""
  reasonCode: IncomingInternalDirectDebitRejectionReasonCodeEnum
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingInternalDirectDebitRejectionPayload = SimulateIncomingInternalDirectDebitRejectionSuccessPayload | SimulateIncomingInternalDirectDebitRejectionErrorPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingInternalDirectDebitRejectionSuccessPayload {
  transactionId: ID!
}

type SimulateIncomingInternalDirectDebitReturnErrorPayload {
  reason: String!
}

"""Return incoming SEPA Direct Debit simulation input"""
input SimulateIncomingInternalDirectDebitReturnInput {
  """Transaction ID to be Returned"""
  transactionId: ID!

  """Return reason code"""
  reasonCode: IncomingInternalDirectDebitReturnReasonCodeEnum!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingInternalDirectDebitReturnPayload = SimulateIncomingInternalDirectDebitReturnSuccessPayload | SimulateIncomingInternalDirectDebitReturnErrorPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingInternalDirectDebitReturnSuccessPayload {
  transactionId: ID!
}

input SimulateIncomingInternationalCreditTransferInput {
  """Amount of the incoming credit transfer"""
  amount: AmountInput!

  """
  Creditor IBAN. Your Swan IBAN if you want to receive a credit transfer in your Swan account
  """
  creditorIban: IBAN!

  """Creditor name"""
  creditorName: String!

  """Debtor IBAN. It should be a valid IBAN"""
  debtorIban: IBAN!

  """Debtor name"""
  debtorName: String!

  """External identifier of the transaction"""
  reference: String

  """Label"""
  label: String
}

"""SimulateIncomingInternationalCreditTransferPayload"""
union SimulateIncomingInternationalCreditTransferPayload = SimulateIncomingInternationalCreditTransferSuccessPayload | AccountNotFoundRejection | ForbiddenRejection

"""Return an incoming transfer simulation input"""
input SimulateIncomingInternationalCreditTransferReturnInput {
  """Reason of the return"""
  reasonCode: IncomingInternationalCreditTransferReturnReasonCode!

  """Transaction ID to return"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingInternationalCreditTransferReturnPayload = SimulateIncomingInternationalCreditTransferReturnSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection | IncorrectTransactionTypeRejection | TransactionAlreadyReturnedRejection

"""Success payload type"""
type SimulateIncomingInternationalCreditTransferReturnSuccessPayload {
  transactionId: ID!
}

"""SimulateIncomingInternationalCreditTransferSuccessPayload"""
type SimulateIncomingInternationalCreditTransferSuccessPayload {
  transactionId: ID!
}

"""Recall an incoming transfer simulation input"""
input SimulateIncomingSepaCreditTransferAcceptedRecallInput {
  """Reason code for incoming transfer recall"""
  reasonCode: SepaCreditTransferRecallReasonCodeEnum!

  """Transaction ID to be recalled"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingSepaCreditTransferAcceptedRecallPayload = SimulateIncomingSepaCreditTransferAcceptedRecallSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingSepaCreditTransferAcceptedRecallSuccessPayload {
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingSepaCreditTransferReceptionPayload = SimulateIncomingSepaCreditTransferReceptionSuccessPayload | ForbiddenRejection

"""Success payload type"""
type SimulateIncomingSepaCreditTransferReceptionSuccessPayload {
  transactionId: ID!
}

"""Return an incoming transfer simulation input"""
input SimulateIncomingSepaCreditTransferReturnInput {
  """Reason code for incoming transfer return"""
  reasonCode: SepaCreditTransferReturnReasonCodeEnum!

  """Transaction ID to be returned"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingSepaCreditTransferReturnPayload = SimulateIncomingSepaCreditTransferReturnSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingSepaCreditTransferReturnSuccessPayload {
  transactionId: ID!
}

"""Book an outgoing transfer simulation input"""
input SimulateIncomingSepaDirectDebitBookingInput {
  """Transaction ID to be booked"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingSepaDirectDebitBookingPayload = SimulateIncomingSepaDirectDebitBookingSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingSepaDirectDebitBookingSuccessPayload {
  transactionId: ID!
}

type SimulateIncomingSepaDirectDebitRejectionErrorPayload {
  reason: String!
}

"""Reject incoming SEPA Direct Debit simulation input"""
input SimulateIncomingSepaDirectDebitRejectionInput {
  """Transaction ID to be Rejected"""
  transactionId: ID!

  """Rejection reason code"""
  reasonCode: IncomingSepaDirectDebitRejectionReasonCodeEnum
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingSepaDirectDebitRejectionPayload = SimulateIncomingSepaDirectDebitRejectionSuccessPayload | SimulateIncomingSepaDirectDebitRejectionErrorPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingSepaDirectDebitRejectionSuccessPayload {
  transactionId: ID!
}

type SimulateIncomingSepaDirectDebitReturnErrorPayload {
  reason: String!
}

"""Return incoming SEPA Direct Debit simulation input"""
input SimulateIncomingSepaDirectDebitReturnInput {
  """Transaction ID to be returned"""
  transactionId: ID!

  """Return reason code"""
  reasonCode: IncomingSepaDirectDebitReturnReasonCodeEnum
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingSepaDirectDebitReturnPayload = SimulateIncomingSepaDirectDebitReturnSuccessPayload | SimulateIncomingSepaDirectDebitReturnErrorPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingSepaDirectDebitReturnSuccessPayload {
  transactionId: ID!
}

input SimulateInvoiceGenerationInput {
  """ID of the account for which we want to generate an invoice"""
  accountId: ID!
}

union SimulateInvoiceGenerationPayload = SimulateInvoiceGenerationSuccessPayload | AccountNotFoundRejection | AccountNotEligibleRejection | ForbiddenRejection

enum SimulateInvoiceGenerationPayloadStatus {
  Pending
  Succeeded
}

type SimulateInvoiceGenerationSuccessPayload {
  """The generated invoice"""
  invoice: Invoice
  status: SimulateInvoiceGenerationPayloadStatus!
}

"""Input to simulate a manual banking fee"""
input SimulateManualBankingFeeInput {
  """ID of the account for which we want add a banking fee manually"""
  accountId: ID!

  """Type of banking fee to add"""
  type: ManualBankingFee!

  """
  When is it booked ?
  cf. https://docs.swan.io/concept/account/billing
  """
  effectiveDate: DateTime!

  """
  Related due amount
  Used when the banking fee is a percentage of initial amount
  """
  dueAmount: AmountInput
}

union SimulateManualBankingFeePayload = SimulateManualBankingFeeSuccessPayload | AccountNotFoundRejection | AccountNotEligibleRejection | ForbiddenRejection

type SimulateManualBankingFeeSuccessPayload {
  """internal ID of this usage"""
  id: ID!

  """amount to debit on the account"""
  debitedAmount: Amount
}

input SimulateMerchantPaymentMethodRequestOutcomeInput {
  merchantPaymentMethodId: ID!
  merchantPaymentMethodStatus: MerchantPaymentMethodStatus!

  """
  In case status is Rejected, merchantPaymentMethodRejectReason is mandatory
  """
  merchantPaymentMethodRejectReason: MerchantPaymentMethodRejectReason
}

"""SimulateMerchantPaymentMethodPayload"""
union SimulateMerchantPaymentMethodRequestOutcomePayload = CheckMerchantPaymentMethod | InternalDirectDebitStandardMerchantPaymentMethod | InternalDirectDebitB2BMerchantPaymentMethod | SepaDirectDebitCoreMerchantPaymentMethod | SepaDirectDebitB2BMerchantPaymentMethod | CardMerchantPaymentMethod | NotFoundRejection | ForbiddenRejection | InternalErrorRejection | MerchantPaymentMethodWrongStatusRejection | RejectionReasonMandatoryRejection | ValidationRejection

input SimulateMerchantPaymentMethodUpdateRequestOutcomeInput {
  """
  ID of the Merchant PaymentMethod update request to simulate the outcome of
  """
  updateRequestId: ID!

  """Whether the update is approved or not"""
  requestedUpdateApproved: Boolean!
}

"""SimulateMerchantPaymentMethodUpdateRequestOutcomePayload"""
union SimulateMerchantPaymentMethodUpdateRequestOutcomePayload = SimulateMerchantPaymentMethodUpdateRequestOutcomeSuccessPayload | ForbiddenRejection | NotFoundRejection | InternalErrorRejection

"""SimulateMerchantPaymentMethodUpdateRequestOutcomeSuccessPayload"""
type SimulateMerchantPaymentMethodUpdateRequestOutcomeSuccessPayload {
  updateRequestId: ID!
}

input SimulateMerchantProfileRequestOutcomeInput {
  """ID of the Merchant Profile to update"""
  merchantProfileId: ID!

  """Desired status of the Merchant Profile"""
  merchantProfileStatus: MerchantProfileStatus
}

"""SimulateMerchantProfileRequestOutcomePayload"""
union SimulateMerchantProfileRequestOutcomePayload = SimulateMerchantProfileRequestOutcomeSuccessPayload | NotFoundRejection | MerchantProfileWrongStatusRejection | ForbiddenRejection | InternalErrorRejection

"""SimulateMerchantProfileRequestOutcomeSuccessPayload"""
type SimulateMerchantProfileRequestOutcomeSuccessPayload {
  merchantProfile: MerchantProfile!
}

input SimulateMerchantProfileUpdateRequestOutcomeInput {
  """ID of the Merchant Profile update request to simulate the outcome of"""
  merchantProfileId: ID!

  """Whether the update is approved or not"""
  requestedUpdateApproved: Boolean!
}

"""SimulateMerchantProfileUpdateRequestOutcomePayload"""
union SimulateMerchantProfileUpdateRequestOutcomePayload = SimulateMerchantProfileUpdateRequestOutcomeSuccessPayload | ForbiddenRejection | NotFoundRejection | InternalErrorRejection

"""SimulateMerchantProfileUpdateRequestOutcomeSuccessPayload"""
type SimulateMerchantProfileUpdateRequestOutcomeSuccessPayload {
  updateRequestId: ID!
}

"""Request a card advice simulation input"""
input SimulateOutgoingCardAdviceInput {
  amount: AmountInput!

  """Card transaction category"""
  cardTransactionCategory: CardTransactionCategory = Other

  """Merchant"""
  merchant: Merchant

  """Original amount"""
  originalAmount: AmountInput

  """Authorization wanted outcome"""
  outcome: CardAuthorizationOutcome

  """Terminal ID"""
  terminalId: String = "SWAN01"

  """Transaction ID"""
  transactionId: ID!

  """Expiration date time"""
  expirationDateTime: DateTime

  """"""
  transactionTransportType: TransactionTransportType
}

"""Request a card authorization simulation input"""
input SimulateOutgoingCardAuthorizationInput {
  amount: AmountInput

  """Authorization request type"""
  authorizationType: CardAuthorizationType = Classic

  """Card ID"""
  cardId: String!

  """Card transaction category"""
  cardTransactionCategory: CardTransactionCategory = Other

  """Simulation card type"""
  cardType: SimulationCardType

  """Merchant"""
  merchant: Merchant

  """Operation type"""
  operationType: CardAuthorizationOperationType

  """Original amount"""
  originalAmount: AmountInput

  """Authorization wanted outcome"""
  outcome: CardAuthorizationOutcome

  """Terminal ID"""
  terminalId: String = "SWAN01"

  """Expiration date time"""
  expirationDateTime: DateTime

  """"""
  allowsPartialAuthorization: Boolean = false

  """"""
  transactionTransportType: TransactionTransportType
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingCardAuthorizationPayload = SimulateOutgoingCardAuthorizationSuccessPayload | SimulateOutgoingCardAuthorizationRejectPayload | CardNotFoundRejection | ForbiddenRejection

"""Reject payload type"""
type SimulateOutgoingCardAuthorizationRejectPayload {
  transactionId: ID!
  reason: SimulateOutgoingCardAuthorizationRejectPayloadReason! @deprecated(reason: "Use rejectedReason instead")
  rejectedReason: String!
}

"""Reject payload reason"""
enum SimulateOutgoingCardAuthorizationRejectPayloadReason {
  AccountSuspended
  CardExpired
  CardSuspended
  InsufficientFunds
  NotHeld
  PartnerRefused
  PartnerTechnicalErrorOccurred
  PeriodAmountLimitExceeded
  SwanRefused
  TransactionTypeNotAllowed
  ThreeDsError
  PeriodTransactionNumberLimitExceeded
  MissingExpirationDate
  MissingPin
  DigitalWalletDeactivated
  DigitalWalletEnrolmentInvalid
  DigitalWalletTokenInvalid
  DigitalWalletRefusal
  DigitalWalletSuspended
  InvalidAmount
  CardholderCancellation
}

"""Input to simulate a release of a card authorization"""
input SimulateOutgoingCardAuthorizationReleaseInput {
  transactionId: ID!
  reason: CardAuthorizationReleaseReason = Expired
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingCardAuthorizationReleasePayload = SimulateOutgoingCardAuthorizationReleaseSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingCardAuthorizationReleaseSuccessPayload {
  transactionId: ID!
}

"""Success payload type"""
type SimulateOutgoingCardAuthorizationSuccessPayload {
  transactionId: ID!
}

"""Credit a card simulation input"""
input SimulateOutgoingCardCreditInput {
  """Amount"""
  amount: AmountInput!

  """Card ID"""
  cardId: String!

  """Card type"""
  cardType: SimulationCardType

  """Original amount"""
  originalAmount: AmountInput

  """Terminal Id"""
  terminalId: String

  """Merchant Id"""
  merchantId: String

  """Merchant Category Code"""
  merchantCategoryCode: String

  """Merchant Name"""
  merchantName: String

  """Merchant City"""
  merchantCity: String

  """Merchant Postal Code"""
  merchantPostalCode: String

  """Merchant Country"""
  merchantCountry: CCA3
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingCardCreditPayload = SimulateOutgoingCardCreditSuccessPayload | CardNotFoundRejection | ForbiddenRejection

"""Reverse a credit simulation input"""
input SimulateOutgoingCardCreditReverseInput {
  """Amount"""
  amount: AmountInput

  """Original amount"""
  originalAmount: AmountInput

  """Transaction ID to be reversed"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingCardCreditReversePayload = SimulateOutgoingCardCreditReverseSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingCardCreditReverseSuccessPayload {
  transactionId: ID!
}

"""Success payload type"""
type SimulateOutgoingCardCreditSuccessPayload {
  transactionId: ID!
}

"""Debit a card simulation input"""
input SimulateOutgoingCardDebitInput {
  """Amount"""
  amount: AmountInput

  """Originalmount"""
  originalAmount: AmountInput

  """Transaction ID to be debited"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingCardDebitPayload = SimulateOutgoingCardDebitSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection | CardNotFoundRejection

"""Debit Reversal simulation input"""
input SimulateOutgoingCardDebitReverseInput {
  """Amount"""
  amount: AmountInput

  """Originalmount"""
  originalAmount: AmountInput

  """Transaction ID to be reversed"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingCardDebitReversePayload = SimulateOutgoingCardDebitReverseSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingCardDebitReverseSuccessPayload {
  transactionId: ID!
}

"""Success payload type"""
type SimulateOutgoingCardDebitSuccessPayload {
  transactionId: ID!
}

"""Book an outgoing transfer simulation input"""
input SimulateOutgoingInternationalCreditTransferBookingInput {
  """Transaction ID to be booked"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingInternationalCreditTransferBookingPayload = SimulateOutgoingInternationalCreditTransferBookingSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingInternationalCreditTransferBookingSuccessPayload {
  transactionId: ID!
}

"""Reject an outgoing transfer simulation input"""
input SimulateOutgoingInternationalCreditTransferRejectionInput {
  """Transaction ID to be booked"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingInternationalCreditTransferRejectionPayload = SimulateOutgoingInternationalCreditTransferRejectionSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingInternationalCreditTransferRejectionSuccessPayload {
  transactionId: ID!
}

"""Return an outgoing transfer simulation input"""
input SimulateOutgoingInternationalCreditTransferReturnInput {
  """Reason of the return"""
  reasonCode: OutgoingInternationalCreditTransferReturnReasonCode!

  """Transaction ID to return"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingInternationalCreditTransferReturnPayload = SimulateOutgoingInternationalCreditTransferReturnSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingInternationalCreditTransferReturnSuccessPayload {
  transactionId: ID!
}

"""Recall an outgoing transfer simulation input"""
input SimulateOutgoingSepaCreditTransferAcceptedRecallInput {
  """Recall reason code"""
  reasonCode: SepaCreditTransferRecalledReasonCodeEnum!

  """Transaction ID to be recalled"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaCreditTransferAcceptedRecallPayload = SimulateOutgoingSepaCreditTransferAcceptedRecallSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaCreditTransferAcceptedRecallSuccessPayload {
  transactionId: ID!
}

"""Book an outgoing transfer simulation input"""
input SimulateOutgoingSepaCreditTransferBookingInput {
  """Transaction ID to be booked"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaCreditTransferBookingPayload = SimulateOutgoingSepaCreditTransferBookingSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaCreditTransferBookingSuccessPayload {
  transactionId: ID!
}

"""Reject an outgoing transfer simulation input"""
input SimulateOutgoingSepaCreditTransferRejectionInput {
  """Rejection reason code"""
  reasonCode: SepaCreditTransferRejectionReasonCodeEnum!

  """Transaction ID to be rejected"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaCreditTransferRejectionPayload = SimulateOutgoingSepaCreditTransferRejectionSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaCreditTransferRejectionSuccessPayload {
  transactionId: ID!
}

"""Return an outgoing transfer simulation input"""
input SimulateOutgoingSepaCreditTransferReturnInput {
  """Return reason code"""
  reasonCode: SepaCreditTransferReturnedReasonCodeEnum!

  """Transaction ID to be returned"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaCreditTransferReturnPayload = SimulateOutgoingSepaCreditTransferReturnSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaCreditTransferReturnSuccessPayload {
  transactionId: ID!
}

"""Cancel a direct debit instruction simulation input"""
input SimulateOutgoingSepaDirectDebitCancelInput {
  """Cancelation reason code"""
  reasonCode: SepaDirectDebitCancelReasonCodeEnum!

  """Transaction ID to be cancelled"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaDirectDebitCancelPayload = SimulateOutgoingSepaDirectDebitCancelSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaDirectDebitCancelSuccessPayload {
  transactionId: ID!
}

"""Receive a direct debit instruction simulation input"""
input SimulateOutgoingSepaDirectDebitReceptionInput {
  """Amount"""
  amount: AmountInput!

  """Creditor account"""
  creditor: SepaDirectDebitAccount!

  """Debtor IBAN. It should be your Swan IBAN"""
  debtorIban: IBAN!

  """SEPA end to end reference"""
  endToEndId: SepaReference

  """
  Requested execution date with date time format (ISO 8601 with time information). It can't be in the past
  ex: 2021-04-12T16:28:22.867Z
  """
  executionDate: DateTime!

  """Mandate amendment info"""
  mandateAmendment: MandateAmendment

  """SEPA mandate reference"""
  mandateReference: SepaReference!

  """SEPA direct debit mandate sequence"""
  mandateSequence: SEPAReceivedDirectDebitMandateSequence!

  """Received SEPA direct debit mandate type"""
  mandateType: SEPAReceivedDirectDebitMandateType!

  """Displayed label in Swan account"""
  label: String
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaDirectDebitReceptionPayload = SimulateOutgoingSepaDirectDebitReceptionSuccessPayload | ForbiddenRejection

"""Success payload type"""
type SimulateOutgoingSepaDirectDebitReceptionSuccessPayload {
  transactionId: ID!
}

"""Reject a received direct debit instruction simulation input"""
input SimulateOutgoingSepaDirectDebitRejectInput {
  """Rejection reason code"""
  reasonCode: SepaDirectDebitRejectReasonCodeEnum!

  """Transaction ID to be rejected"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaDirectDebitRejectPayload = SimulateOutgoingSepaDirectDebitRejectSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaDirectDebitRejectSuccessPayload {
  transactionId: ID!
}

"""Request a direct debit refund simulation"""
input SimulateOutgoingSepaDirectDebitReturnInput {
  """Refund reason code"""
  reasonCode: SepaDirectDebitReturnReasonCodeEnum!

  """Transaction ID to be returned"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaDirectDebitReturnPayload = SimulateOutgoingSepaDirectDebitReturnSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaDirectDebitReturnSuccessPayload {
  transactionId: ID!
}

"""Receive a direct debit reversal simulation"""
input SimulateOutgoingSepaDirectDebitReverseInput {
  """Reversal reason code"""
  reasonCode: SepaDirectDebitReverseReasonCodeEnum!

  """Transaction ID to be reversed"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaDirectDebitReversePayload = SimulateOutgoingSepaDirectDebitReverseSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaDirectDebitReverseSuccessPayload {
  transactionId: ID!
}

"""Input to simulate delivery of a physical card"""
input SimulatePhysicalCardDeliveryInput {
  """Unique identifier of a card"""
  cardId: ID!

  """
  Alphanumeric string with the tracking identifier of the delivery supplier.
  """
  trackingNumber: String
}

"""Inputs to simulate physical card renewal process"""
input SimulatePhysicalCardRenewalProcessInput {
  """Unique identifier of a card"""
  cardId: ID!

  """Desired status to simulate part of the physical card renewal process"""
  status: PhysicalCardRenewalStatus!
}

"""
Union of all possible payloads for simulate physical card renewal process
"""
union SimulatePhysicalCardRenewalProcessPayload = SimulatePhysicalCardRenewalProcessSuccessPayload | ForbiddenRejection | PhysicalCardWrongStatusRejection | CardNotFoundRejection

"""Simulate physical card renewal process success payload"""
type SimulatePhysicalCardRenewalProcessSuccessPayload {
  """The physical card updated"""
  physicalCard: PhysicalCard!
}

"""Release reserved balance input"""
input SimulateReleaseReservedBalanceInput {
  """Transaction ID to be release"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateReleaseReservedBalancePayload = ForbiddenRejection | TransactionNotFoundRejection | ReleaseReservedBalanceSuccessPayload

input SimulateStartProjectBillingInput {
  """Name of the company to bill"""
  companyName: String!

  """E-mail which will receive the generated invoices each month"""
  email: String!
}

union SimulateStartProjectBillingPayload = SimulateStartProjectBillingSuccessPayload | ProjectAlreadyHasSubscriptionRejection | ForbiddenRejection

type SimulateStartProjectBillingSuccessPayload {
  """ID of the project billed"""
  projectId: ID!
}

enum SimulationCardType {
  Physical
  Virtual
}

"""
A rejection returned when the simulation couldn't be performed because of a functional error
"""
type SimulationRejection {
  code: SimulationRejectionCode!
  message: String!
}

enum SimulationRejectionCode {
  CouldNotProvisionCard
  CouldNotUpdateDeliveryInformation
  CouldNotObtainIdentifier
}

"""
The response to a simulation call.
Will alway be true and mean that the simulation was successfully executed
"""
union SimulationResponse = SimulationSuccessfulResponse | SimulationRejection | ValidationRejection

"""
The response to a simulation call.
Will alway be true and mean that the simulation was successfully executed
"""
type SimulationSuccessfulResponse {
  noop: Boolean
}

"""Spending"""
type Spending {
  """period concerned"""
  period: SpendingLimitPeriod!

  """amount spent during the period"""
  amount: Amount
}

"""Spending limits"""
type SpendingLimit {
  """type of limit (defined by the Partner, defined by Swan, etc.)"""
  type: SpendingLimitType!

  """period concerned"""
  period: SpendingLimitPeriod!

  """sum of amount of spending authorized during the period"""
  amount: Amount!
}

"""Inputs when editing spending limit configuration"""
input SpendingLimitInput {
  """period concerned"""
  period: SpendingLimitPeriodInput!

  """sum of amount of spending authorized during the period"""
  amount: AmountInput!
}

"""Available period to compute spending limits"""
enum SpendingLimitPeriod {
  Monthly
  Weekly
  Daily
  Always
}

"""Available period to compute spending limits"""
enum SpendingLimitPeriodInput {
  Monthly
  Weekly
  Daily
  Always
}

"""Available type of spending limits"""
enum SpendingLimitType {
  """for the account holder - defined by the partner"""
  AccountHolder

  """for the partner - defined by Swan"""
  Partner
}

"""Rejection returned when Standing Order is not found"""
type StandingOrderNotFoundRejection implements Rejection {
  message: String!
}

"""
Describes an identification level that has started for the process of the current identification
"""
type StartedIdentificationLevelStatusInfo {
  """Always set to `Started`"""
  status: SwanIdentificationStatus!
}

type SuccessfulThreeDs {
  status: ThreeDsStatus!
}

"""Supporting document used for compliance"""
type SupportingDocument {
  """Unique identifier of the document"""
  id: String!

  """Supporting document status information"""
  statusInfo: SupportingDocumentStatusInfo!

  """Type of supporting Document"""
  supportingDocumentType: SupportingDocumentType

  """Purpose of supporting document"""
  supportingDocumentPurpose: SupportingDocumentPurposeEnum!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!
}

type SupportingDocumentAccountHolder {
  id: ID
  name: String
}

"""
Collection of supporting documents used for compliance

Fetching SupportingDocument is restricted to Project access token
"""
type SupportingDocumentCollection {
  """Unique identifier of the supporting document collection"""
  id: String!

  """Status of the supporting document collection"""
  statusInfo: SupportingDocumentCollectionStatusInfo!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  List of supported documents contained in the supporting document collection
  """
  supportingDocuments: [SupportingDocument]!

  """
  List of required supporting document purposes for this supporting document collection
  """
  requiredSupportingDocumentPurposes: [SupportingDocumentPurpose!]!
  accountHolder: SupportingDocumentAccountHolder!
  onboarding: SupportingDocumentOnboarding!
  projectInfo: ProjectInfo!

  """SupportingDocumentCollection URL to Swan portal"""
  supportingDocumentCollectionUrl: String!
  type: SupportingDocumentCollectionType!
  transaction: SupportingDocumentTransaction!
}

"""Supporting document collection with Approved status"""
type SupportingDocumentCollectionApprovedStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the supporting document collection is approved"""
  status: SupportingDocumentCollectionStatus!

  """Date on which the supporting document collection has been approved"""
  approvedAt: DateTime!
}

"""Supporting document collection with Canceled status"""
type SupportingDocumentCollectionCanceledStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the supporting document collection is canceled"""
  status: SupportingDocumentCollectionStatus!

  """Date on which the supporting document collection has been canceled"""
  canceledAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type SupportingDocumentCollectionConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """SupportingDocumentCollectionEdge list"""
  edges: [SupportingDocumentCollectionEdge!]!
}

"""Implements the Relay Edge interface"""
type SupportingDocumentCollectionEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The supporting document collection"""
  node: SupportingDocumentCollection!
}

"""
Filters that can be applied when listing supporting document collections
"""
input SupportingDocumentCollectionFilterInput {
  """Supporting document collection type/types we're looking for"""
  type: [SupportingDocumentCollectionType!]

  """Supporting document collection status we're looking for"""
  status: [SupportingDocumentCollectionStatus!]
}

"""Rejection returned if the supporting document collection was not found"""
type SupportingDocumentCollectionNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Supporting document collection with PendingReview status"""
type SupportingDocumentCollectionPendingReviewStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """
  When the supporting document collection is completed and in compliance review
  """
  status: SupportingDocumentCollectionStatus!
}

"""Supporting document collection with Rejected status"""
type SupportingDocumentCollectionRejectedStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the supporting document collection is rejected"""
  status: SupportingDocumentCollectionStatus!

  """Date on which the supporting document collection has been rejected"""
  rejectedAt: DateTime!
}

"""Verification status of a supporting document collection"""
enum SupportingDocumentCollectionStatus {
  """When the supporting document collection is created and on going"""
  WaitingForDocument

  """
  When the supporting document collection is completed and in compliance review
  """
  PendingReview

  """When the supporting document collection is approved. Final status"""
  Approved

  """When the supporting document collection is canceled. Final status"""
  Canceled

  """When the supporting document collection is rejected. Final status"""
  Rejected
}

"""
Rejection returned if supporting document cannot be deleted because its supporting document collection status is not WaitingForDocument
"""
type SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection implements Rejection {
  message: String!
  supportingDocumentCollectionStatus: SupportingDocumentCollectionStatus!
  supportingDocumentCollection: SupportingDocumentCollection!
}

"""
Rejection returned if supporting document cannot be updated because its supporting document collection status is not WaitingForDocument
"""
type SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection implements Rejection {
  message: String!
  supportingDocumentCollectionStatus: SupportingDocumentCollectionStatus!
  supportingDocumentCollection: SupportingDocumentCollection!
}

interface SupportingDocumentCollectionStatusInfo {
  """Status of the supporting document collection"""
  status: SupportingDocumentCollectionStatus!
}

"""Rejection returned if the status transition is not allowed"""
type SupportingDocumentCollectionStatusNotAllowedRejection implements Rejection {
  oldStatus: SupportingDocumentCollectionStatus!
  newStatus: SupportingDocumentCollectionStatus!
  message: String!
}

enum SupportingDocumentCollectionType {
  Onboarding
  AccountHolderVerificationRenewal
  Transaction
}

"""Supporting document collection with WaitingForUpload status"""
type SupportingDocumentCollectionWaitingForDocumentStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the Supporting Document Collection is created"""
  status: SupportingDocumentCollectionStatus!
}

"""Rejection returned if the supporting document was not found"""
type SupportingDocumentNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Supporting document with NotUploaded status."""
type SupportingDocumentNotUploadedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has not been updated on time."""
  status: SupportingDocumentStatus!
}

type SupportingDocumentOnboarding {
  id: ID
}

type SupportingDocumentPostField {
  key: String!
  value: String!
}

"""Details of a supporting document purpose"""
type SupportingDocumentPurpose {
  """Technical name of the purpose"""
  name: SupportingDocumentPurposeEnum!

  """
  Corresponding supporting document types accepted for this supporting document purpose
  """
  acceptableSupportingDocumentTypes: [SupportingDocumentType!]!

  """
  Corresponding Supporting Document Purpose Title translation according to accept-language header
  """
  label: String!

  """
  Corresponding Supporting Document Purpose Description translation according to accept-language header
  """
  description: String!
}

"""Supporting document purpose"""
enum SupportingDocumentPurposeEnum {
  """Proof of association registration"""
  AssociationRegistration

  """Banking"""
  Banking

  """Proof of company registration"""
  CompanyRegistration

  """Minutes Of The General Assembly"""
  GeneralAssemblyMinutes

  """Other"""
  Other

  """Signed power of attorney document to give the power to act on behalf."""
  PowerOfAttorney

  """Proof of company address"""
  ProofOfCompanyAddress

  """Proof of company income"""
  ProofOfCompanyIncome

  """Proof of identity"""
  ProofOfIdentity

  """Proof of individual address"""
  ProofOfIndividualAddress

  """Proof of individual income"""
  ProofOfIndividualIncome

  """Proof of origin of funds"""
  ProofOfOriginOfFunds

  """Signed status"""
  SignedStatus

  """UBO Declaration"""
  UBODeclaration

  """Sworn statement"""
  SwornStatement

  """Proof of identity of the legal representative"""
  LegalRepresentativeProofOfIdentity

  """Proof of identity of the Ultimate Beneficial Owner"""
  UltimateBeneficialOwnerProofOfIdentity

  """NIF Accreditation Card"""
  NIFAccreditationCard

  """Decision of appointment of the President"""
  PresidentDecisionOfAppointment

  """Decision of appointment of Administrator"""
  AdministratorDecisionOfAppointment

  """Financial Statements"""
  FinancialStatements

  """Proof of address of the Ultimate Beneficial Owner"""
  UltimateBeneficialOwnerProofOfAddress

  """Personal Income"""
  PersonalIncome

  """Personal Savings"""
  PersonalSavings

  """Investment"""
  Investment

  """Donation"""
  Donation

  """Inheritance"""
  Inheritance

  """Real Estate Income"""
  RealEstateIncome

  """Gambling Prize Winnings"""
  GamblingPrizeWinnings

  """Trade"""
  Trade

  """Company Treasury"""
  CompanyTreasury

  """Company Obligations"""
  CompanyObligations

  """Politically exposed person declaration"""
  PepDeclaration

  """Proof of the company creation process"""
  CompanyFormationRegistration
}

"""Refused supporting document reason code"""
enum SupportingDocumentReasonCode {
  """The company name in document doesn’t match our records."""
  CompanyNameMismatch

  """The document must be dated less than 3 months ago."""
  ExpiredDocument

  """The address in document doesn’t match our records."""
  InvalidAddress

  """The document is not valid."""
  InvalidDocument

  """
  The name of shareholder is not clearly visible or some fields are not duely completed.
  """
  InvalidOrMissingData

  """Document cannot be accepted for the requested document type."""
  UnacceptableDocument

  """The document must be in color."""
  ProviderColorIdDocumentRequired

  """Documents are not signed or dated."""
  MissingSignature

  """The quality of the document is really low."""
  BadDocumentQuality

  """Full Document required."""
  FullDocumentRequired

  """
  The document provided is missing essential details required to comprehend the transaction's nature. Please submit an additional supporting document to supplement the initial one.
  """
  MissingDescription

  """
  The document appears to be inconsistent with the specified transaction.
  """
  InvalidTransaction

  """
  The issuer or beneficiary name on the document we received does not match the information requested for the transaction.
  """
  TransactionNameMismatch

  """
  The date on the document we received does not match the information requested for the transaction.
  """
  TransactionDateMismatch

  """
  The amount on the document we received does not match the information requested for the transaction.
  """
  TransactionAmountMismatch

  """
  The beneficiary IBAN on the document we received does not match the information requested for the transaction.
  """
  IbanMismatch

  """Other"""
  Other
}

"""Supporting document with Refused status"""
type SupportingDocumentRefusedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has been refused by Swan"""
  status: SupportingDocumentStatus!

  """Date on which the supporting document collection has been refused"""
  refusedAt: DateTime!

  """Reason why the supporting document has been refused"""
  reason: String!

  """Reason code why the supporting document has been refused"""
  reasonCode: SupportingDocumentReasonCode!

  """Original file name"""
  filename: String!
}

"""Verification status of a document"""
enum SupportingDocumentStatus {
  """Document is not uploaded yet."""
  WaitingForUpload

  """Document has been uploaded but not verified by Swan yet."""
  Uploaded

  """Document has been uploaded and verified by Swan."""
  Validated

  """Document has been refused by Swan."""
  Refused

  """Document has not been uploaded on time."""
  NotUploaded
}

"""
Rejection returned if supporting document cannot be deleted because of its status
"""
type SupportingDocumentStatusDoesNotAllowDeletionRejection implements Rejection {
  supportingDocument: SupportingDocument!
  status: SupportingDocumentStatus!
  message: String!
}

"""
Rejection returned if supporting document cannot be updated because of its status
"""
type SupportingDocumentStatusDoesNotAllowUpdateRejection implements Rejection {
  supportingDocument: SupportingDocument!
  status: SupportingDocumentStatus!
  message: String!
}

interface SupportingDocumentStatusInfo {
  """Status of the supporting document"""
  status: SupportingDocumentStatus!
}

"""Rejection returned if the status transition is not allowed"""
type SupportingDocumentStatusNotAllowedRejection implements Rejection {
  oldStatus: SupportingDocumentStatus!
  newStatus: SupportingDocumentStatus!
  message: String!
}

type SupportingDocumentTransaction {
  id: ID
}

"""Specific type for document"""
enum SupportingDocumentType {
  """Selfie"""
  Selfie

  """Passport"""
  Passport

  """NationalIdCard"""
  NationalIdCard

  """Resident permit"""
  ResidentPermit

  """Driving license"""
  DrivingLicense

  """Water, Electricity or Gas Bill issued within the last 3 months"""
  UtilityBill

  """Telephone Bill issued within the last 3 months"""
  PhoneBill

  """Rental Receipt issued within the last 3 months"""
  RentReceipt

  """Home Insurance contract"""
  HomeInsurance

  """
  Income Tax return or tax-exemption certificate dating less than 2 years
  """
  IncomeTaxReturn

  """A pay slip dating less than 3 months"""
  PaySlip

  """Commercial registry extract issued within the last 3 months"""
  RegisterExtract

  """Legal document required for company’s formation"""
  ArticlesOfIncorporation

  """Share Deposit Certificate"""
  CapitalShareDepositCertificate

  """Ultimate Beneficial Owner Declaration"""
  UBODeclaration

  """Association registration proof for french association"""
  JOAFFEExtract

  """
  Lease agreement in the name of the business or Proof of Individual Address if the company is hosted by one of the legal representative
  """
  CompanyLeaseAgreement

  """Bank Statement"""
  BankStatement

  """
  Document with details such as bank name, address, account number and account holder
  """
  BankAccountDetails

  """Signed power of attorney document to give the power to act on behalf"""
  PowerOfAttorney

  """
  Document submitted to your tax bureau at the end of the last business period
  """
  CorporateIncomeTaxReturn

  """Other"""
  Other

  """By Laws"""
  ByLaws

  """Account statement"""
  AccountStatement

  """Deed of donation"""
  DeedOfDonation

  """Deed of sale"""
  DeedOfSale

  """Deed of succession"""
  DeedOfSuccession

  """Loan contract"""
  LoanContract

  """Notarial deed"""
  NotarialDeed

  """Sworn statement"""
  SwornStatement

  """Meeting's minutes"""
  MeetingMinutes

  """NIF Accreditation Card"""
  NIFAccreditationCard

  """Decision of appointment"""
  DecisionOfAppointment

  """Financial Statements"""
  FinancialStatements

  """Winnings Certificate"""
  WinningsCertificate

  """Invoice"""
  Invoice

  """Politically exposed person declaration"""
  PepDeclaration
}

"""Supporting document with Uploaded status"""
type SupportingDocumentUploadedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has been uploaded but not verified by Swan yet"""
  status: SupportingDocumentStatus!

  """Original file name"""
  filename: String!
}

type SupportingDocumentUploadInfo {
  url: String!
  fields: [SupportingDocumentPostField!]!
}

"""
Rejection returned if the supporting document collection cannot receive supporting documents anymore
"""
type SupportingDocumentUploadNotAllowedRejection implements Rejection {
  supportingDocumentCollectionStatus: SupportingDocumentCollectionStatus!
  message: String!
}

"""Supporting document with Validated status"""
type SupportingDocumentValidatedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has been uploaded and verified by Swan"""
  status: SupportingDocumentStatus!

  """Date on which the supporting document has been validated"""
  validatedAt: DateTime!

  """Original file name"""
  filename: String!

  """Reason why the supporting document has been validated"""
  reason: String!
}

"""Supporting document with WaitingForUpload status"""
type SupportingDocumentWaitingForUploadStatusInfo implements SupportingDocumentStatusInfo {
  """When the document is not uploaded yet"""
  status: SupportingDocumentStatus!

  """
  Info to upload the document : url and fields to add along file in form (POST)
  """
  upload: SupportingDocumentUploadInfo!
}

"""
Define a reason with a message and a specific type for suspend account action
"""
type SuspendAccountReason implements Reason {
  type: SuspendAccountReasonType!
  message: String
}

"""Input version"""
input SuspendAccountReasonInput {
  type: SuspendAccountReasonType!
  message: String
}

"""Specific type for suspend account action"""
enum SuspendAccountReasonType {
  """Simple suspend request"""
  SuspendRequested
}

"""SuspendAccountStatusReason"""
union SuspendAccountStatusReason = SuspendAccountReason

"""StatusInfo when funding limit settings has been suspended"""
type SuspendedFundingLimitSettingsStatusInfo implements FundingLimitSettingsStatusInfo {
  status: FundingLimitSettingsStatus!
  reason: String!
}

"""SuspendedMerchantPaymentMethodStatusInfo"""
type SuspendedMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method suspended date"""
  suspendedAt: Date!
}

"""SuspendedMerchantProfileStatusInfo"""
type SuspendedMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  suspendedAt: Date!
}

"""Swan account beneficiary"""
input SwanAccountBeneficiaryInput {
  """account number to be credited"""
  accountNumber: AccountNumber!

  """full name of the beneficiary  (max 70 characters)"""
  name: String!

  """
  `true` if this new beneficiary will be saved to the beneficiary list of the debited account.
  """
  save: Boolean!
}

"""Status values of an identification"""
enum SwanIdentificationStatus {
  """
  When the identification process is currently being treated by a manual or automatic process
  """
  Pending

  """When the identification is valid"""
  Valid

  """When the identification is invalid"""
  Invalid

  """
  When the user canceled the identification process or the identification service was unavailable
  """
  Canceled

  """When the identification is no longer valid"""
  Expired

  """When the identification does not support an identification level"""
  NotSupported

  """When the identification hasn't been started yet"""
  NotStarted @deprecated(reason: "Use 'Started' instead. Deprecated to ensure consistency and clear identification status behavior.")

  """When the identification has been started"""
  Started
}

type TextField implements Field {
  displayFormat: String
  example: String
  key: String!
  maxLength: Int
  minLength: Int
  name: String!
  refreshDynamicFieldsOnChange: Boolean!
  required: Boolean!
  validationRegex: String
}

"""The details of the 3DS challenge associated to the payment."""
type ThreeDS {
  """`true` if a 3DS challenge has been requested from the card holder"""
  requested: Boolean!

  """The status of the 3DS challenge"""
  statusInfo: ThreeDsStatusInfo!
}

type ThreeDsConsent implements DetailedConsent {
  id: ID!
  projectId: String
  requireSCA: Boolean!
  status: ConsentStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  startedAt: DateTime
  expiredAt: DateTime
  acceptedAt: DateTime
  refusedAt: DateTime
  canceledAt: DateTime
  consentResponses: [ConsentResponse!]!
  purpose: DetailedConsentPurpose!
  serviceToHook: String!
  consentOperations: [ConsentOperation!]!
  env: EnvType!
  identityId: String!
  userId: String
  state: String
  branding: Branding!
  operationsSHA256HexDigest: String
  merchantName: String!
  merchantId: String!
  merchantCategoryCode: String
  merchantAppRedirectUrl: String
  monextCardId: String!
  maskedCardNumber: String!
  amount: AmountWithCurrency!
  challenge: String
  channelName: String
}

enum ThreeDsStatus {
  Successful
  Failed
}

interface ThreeDsStatusInfo {
  status: ThreeDsStatus!
}

"""Individual ultimate beneficial owner title (Mr/Ms)"""
enum TitleEnum {
  """Identified as a man"""
  Mr

  """Identified as a woman"""
  Ms
}

scalar TokenRequestorId

"""Rejection returned if too many items are given"""
type TooManyItemsRejection implements Rejection {
  message: String!
}

"""Rejection returned if the transaction was already returned"""
type TransactionAlreadyReturnedRejection implements Rejection {
  message: String!
  returnTransactionId: ID!
}

"""Rejection returned if the transaction was not found"""
type TransactionNotFoundRejection implements Rejection {
  transactionId: ID!
  message: String!
}

enum TransactionSide {
  Credit
  Debit
}

enum TransactionTransportType {
  Prefunded
  RealTimeAuthorized
  PostAuthorizedAggregated
  PostAuthorizedAggregatedMaestro
  AuthorizedAggregatedSplitClearing
  Other
  DebtRecovery
}

"""Quality of the account holder doing the onboarding"""
enum TypeOfRepresentation {
  """The account holder is the legal representative"""
  LegalRepresentative

  """The account holder has a power of attorney"""
  PowerOfAttorney
}

type UBOIdentityDocumentDetails {
  """Type of identity document"""
  type: UBOIdentityDocumentType

  """Issue date of the identity document"""
  issueDate: String

  """Expiry date of the identity document"""
  expiryDate: String

  """Number of the identity document"""
  number: String

  """Issuing authority of the identity document"""
  issuingAuthority: String
}

input UBOIdentityDocumentDetailsInput {
  """Type of identity document"""
  type: UBOIdentityDocumentType

  """Issue date of the identity document"""
  issueDate: String

  """Expiry date of the identity document"""
  expiryDate: String

  """Number of the identity document"""
  number: String

  """Issuing authority of the identity document"""
  issuingAuthority: String
}

enum UBOIdentityDocumentType {
  Passport
  IdCard
}

"""Input of the updateAccountHolderFundingLimits mutation"""
input UpdateAccountHolderFundingLimitsInput {
  """ID of the funding limit's account holder to update"""
  accountHolderId: ID!

  """Interval in number of calendar days where the limit is applied"""
  fundingLimitRollingDays: Int!

  """Global funding amount authorized during the interval"""
  fundingLimitAmount: AmountInput!

  """Instant funding amount authorized"""
  instantFundingLimitAmount: AmountInput!
}

"""Response of the updateAccountHolderFundingLimits mutation"""
union UpdateAccountHolderFundingLimitsPayload = UpdateAccountHolderFundingLimitsSuccessPayload | InternalErrorRejection

type UpdateAccountHolderFundingLimitsSuccessPayload {
  accountHolderId: ID!
}

input UpdateAccountHolderInput {
  accountHolderId: ID!
  verificationStatus: VerificationStatus

  """
  VerificationRequirements for the Account Holder, can only be used when verificationStatus is WaitingForInformation
  """
  verificationRequirements: [VerificationRequirementType!]
}

union UpdateAccountHolderPayload = UpdateAccountHolderSuccessPayload | AccountHolderNotFoundRejection | ValidationRejection | VerificationRequirementsNotUpdatableRejection

type UpdateAccountHolderSuccessPayload {
  accountHolder: AccountHolder!
}

"""Inputs to update the account verification status"""
input UpdateAccountVerificationStatusInput {
  """The unique identifier of the account verification"""
  accountVerificationId: ID!

  """The new status that the account verification should take"""
  newStatus: AccountVerificationStatus!
}

"""Union type return by the addReceivedSepaDirectDebitB2bMandate mutation"""
union UpdateAccountVerificationStatusPayload = UpdateAccountVerificationStatusSuccessPayload | ForbiddenRejection

"""
Return type in case of a successful response of the updateAccountVerificationStatus mutation
"""
type UpdateAccountVerificationStatusSuccessPayload {
  """The updated account verification"""
  accountVerification: AccountVerification!
}

input UpdateFundingLimitSettingsChangeRequestInput {
  fundingLimitSettingsChangeRequestId: ID!
  status: FundingLimitSettingsChangeRequestStatus
  reason: String
  approvedInstantFundingLimit: FundingLimitAmountInput
  approvedFundingLimit: FundingLimitAmountInput
}

union UpdateFundingLimitSettingsChangeRequestPayload = UpdateFundingLimitSettingsChangeRequestSuccessPayload | ForbiddenRejection | FundingLimitSettingsChangeRequestStatusNotAllowedRejection | FundingLimitSettingsChangeRequestNotFoundRejection | ValidationRejection

type UpdateFundingLimitSettingsChangeRequestSuccessPayload {
  fundingLimitSettingsChangeRequest: FundingLimitSettingsChangeRequest!
}

type UpdateRequestNotPendingReviewRejection implements Rejection {
  requestUpdateId: ID
  message: String!
}

"""Update sandbox identification input payload."""
input UpdateSandboxIdentificationInput {
  identificationId: String!
  process: IdentificationProcess!
  levels: IdentificationLevelStatusesInput!
  errorReasons: [IdentificationInvalidReason!]
}

"""Union of success payload and possible rejections"""
union UpdateSandboxIdentificationPayload = UpdateSandboxIdentificationSuccessPayload | ForbiddenRejection | SandboxIdentificationNotFoundRejection | InvalidIdentificationLevelsRejection | InvalidIdentificationErrorReasonsRejection

"""Success payload type"""
type UpdateSandboxIdentificationSuccessPayload {
  """Updated sandbox identification"""
  sandboxIdentification: SandboxIdentification!
}

input UpdateSandboxUserInput {
  id: ID!

  """First name"""
  firstName: String!

  """Last name"""
  lastName: String!

  """List of first names"""
  allFirstNames: [String!]

  """Birth date"""
  birthDate: Date!

  """
  [Alpha-3 birth country representation](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  """
  birthCountryCCA3: CCA3

  """
  [Alpha-3 nationality representation](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  Ex: FRA for french nationality
  """
  nationalityCCA3: CCA3!

  """
  Saves you considerable time during the development phase,
  by automatically allowing consent,
  removing the need to repeatedly get consent.
  """
  autoConsent: Boolean!
}

union UpdateSandboxUserPayload = UpdateSandboxUserSuccessPayload | ForbiddenRejection | NationalityNotFoundRejection | SandboxUserNotFoundRejection

type UpdateSandboxUserSuccessPayload {
  sandboxUser: SandboxUser!
}

input UpdateSupportingDocumentCollectionStatusInput {
  supportingDocumentCollectionId: ID!
  status: SupportingDocumentCollectionStatus!
}

union UpdateSupportingDocumentCollectionStatusPayload = UpdateSupportingDocumentCollectionStatusSuccessPayload | ForbiddenRejection | SupportingDocumentCollectionStatusNotAllowedRejection | SupportingDocumentCollectionNotFoundRejection | InternalErrorRejection | ValidationRejection

type UpdateSupportingDocumentCollectionStatusSuccessPayload {
  supportingDocumentCollection: SupportingDocumentCollection!
}

input UpdateSupportingDocumentStatusInput {
  supportingDocumentId: ID!
  status: SupportingDocumentStatus!
}

union UpdateSupportingDocumentStatusPayload = UpdateSupportingDocumentStatusSuccessPayload | ForbiddenRejection | InternalErrorRejection | SupportingDocumentCollectionNotFoundRejection | SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection | SupportingDocumentNotFoundRejection | SupportingDocumentStatusDoesNotAllowUpdateRejection | ValidationRejection

type UpdateSupportingDocumentStatusSuccessPayload {
  supportingDocument: SupportingDocument!
}

scalar Upload

"""
URL that follows the WHATWG URL Standard.

[Examples of parsed URLs](https://url.spec.whatwg.org/#example-url-parsing) may be found in the Standard itself.
"""
scalar URL

"""The User is the unique user, natural person, of the Swan app."""
type User {
  """unique identifier of the user"""
  id: ID!

  """
  The list of account memberships
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  accountMemberships(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: AccountMembershipsFilterInput
  ): AccountMembershipConnection!

  """
  mobile phone number with the international format (Example: +33689788967)
  """
  mobilePhoneNumber: PhoneNumber

  """first name"""
  firstName: String

  """last name"""
  lastName: String

  """Birth last name"""
  birthLastName: String

  """list of first names"""
  allFirstNames: [String!]

  """
  full name : concatenation of firstName + [ birthLastName | lastName ] depending on preferredLastName setting
  """
  fullName: String

  """birth date"""
  birthDate: Date

  """nationality"""
  nationalityCCA3: CCA3

  """birth city"""
  birthCity: String

  """
  `true` if Swan has verified the user's identity
  @deprecated Use the equivalent identificationLevels.expert field instead
  """
  idVerified: Boolean! @deprecated(reason: "Use the equivalent `identificationLevels.expert` field instead")

  """the methods used to authenticate this user"""
  authenticators: [Authenticator!]

  """
  List of identification levels available for the user.
  
  Whenever TRUE, it means the identification was successful for the associated level.
  """
  identificationLevels: IdentificationLevels

  """
  Preferred notification channel
  
  When it is "null" it means that the preferences have not been updated. Default SMS in use
  """
  preferredNotificationChannel: PreferredNotificationChannel

  """Status of the user"""
  status: UserStatus

  """Creation date of the user"""
  createdAt: DateTime!

  """Last update date of the user"""
  updatedAt: DateTime!

  """The last name that the user prefers to use"""
  preferredLastName: String
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type UserConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """UserEdge list"""
  edges: [UserEdge!]!
}

type UserConsentSettings {
  """Preferred notification channel"""
  preferredNotificationChannel: PreferredNotificationChannel!

  """User identifier"""
  userId: String!

  """Project identifier"""
  projectId: String!
}

"""Implements the Relay Edge interface"""
type UserEdge implements Edge {
  """
  Opaque identifier pointing to this consent node in the pagination mechanism
  """
  cursor: String!

  """The user"""
  node: User!
}

type UserNotFoundRejection implements Rejection {
  id: ID!
  message: String!
}

enum UserStatus {
  """Users with Active status are able to login & use Swan."""
  Active

  """
  Users in Deactivated status don't use Swan anymore and won't ever be able to login. Their phone number can be reused as a new number.
  """
  Deactivated

  """
  Users in Blocked status are not able to login for security reason. Their phone number can't be reused.
  """
  Blocked
}

"""A detail of a validation error : what field is errored and why"""
type ValidationError {
  """
  Onboarding property that is not matching requirements to allow a finalization
  """
  field: String!

  """Constraints that are not matched on the Onboarding property"""
  errors: [FieldValidationError!]
}

type ValidationFieldError {
  code: ValidationFieldErrorCode!
  message: String!
  path: [String!]!
}

enum ValidationFieldErrorCode {
  InvalidString
  InvalidType
  TooLong
  TooShort
  UnrecognizedKeys
}

"""Rejection returned if an input contains invalid data"""
type ValidationRejection implements Rejection {
  fields: [ValidationFieldError!]!
  message: String!
}

"""
Describes a valid identification level for the process associated to this identification, and identification documents can be accessed
"""
type ValidIdentificationLevelStatusInfo {
  """Always set to `Valid`"""
  status: SwanIdentificationStatus!
}

"""Verification Flow."""
enum VerificationFlow {
  """
  When you ask the account holder to start the verification process at the beginning of the relationship to get an unlimited account.
  """
  Upfront

  """
  When you ask the account holder the minimum required to comply the law at the beginning of the relationship.
  """
  Progressive
}

"""
Account Holder Verification Requirement

It is a sub status for the Account Holder when his verification status is WaitingForInformation
"""
type VerificationRequirement {
  id: ID!
  type: VerificationRequirementType!
}

type VerificationRequirementsNotUpdatableRejection implements Rejection {
  accountHolderId: String!
  accountHolderVerificationStatus: VerificationStatus!
  message: String!
}

enum VerificationRequirementType {
  """Swan is requesting for a 1st transfer"""
  FirstTransferRequired

  """Swan is requesting some Supporting Documents"""
  SupportingDocumentsRequired

  """Swan is requesting some clarification on the UBO"""
  UboDetailsRequired

  """
  Swan is requesting some clarification on the legal representative or on the account member with legal representative permissions
  """
  LegalRepresentativeDetailsRequired

  """Swan is requesting some clarification on the organization"""
  OrganizationDetailsRequired

  """Swan is requesting some tax identifier"""
  TaxIdRequired

  """Swan is requesting more information on the account holders"""
  Other
}

"""Verification status of an account holder"""
enum VerificationStatus {
  """
  When the account holder has not started to answer the verification process.
  """
  NotStarted

  """
  When Swan is waiting for information about the account holder to continue the verification process.
  """
  WaitingForInformation

  """When the verification process is pending."""
  Pending

  """When the account holder is verified."""
  Verified

  """When the account holder is refused."""
  Refused
}

"""Enabled Information"""
type VerifiedStatusInfo implements AccountVerificationStatusInfo {
  """Date at which the verification was verified"""
  verifiedAt: DateTime!

  """Account verification status (Verified)"""
  status: AccountVerificationStatus!
}

"""
Virtual IBAN can be used by the account holder to receive SCT (Sepa Credit Transfer) or to be debited by SDD (Sepa Direct Debit).
"""
type VirtualIBANEntry {
  """Unique identifier of a Virtual IBAN entry"""
  id: ID!

  """International Bank Account Number"""
  IBAN: IBAN!

  """Bank Identifier Code"""
  BIC: BIC!

  """Label (could be used to identify)"""
  label: String

  """Status of the Iban"""
  status: IBANStatus!

  """`true` if the Virtual IBAN refuses all Sepa Direct Debit received"""
  blockSDD: Boolean!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type VirtualIBANEntryConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """VirtualIBANEntryEdge list"""
  edges: [VirtualIBANEntryEdge!]!
}

"""Implements the Relay Edge interface"""
type VirtualIBANEntryEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The virtual iban entry"""
  node: VirtualIBANEntry!
}

"""Wallet Provider"""
enum WalletProviderType {
  ApplePay
  GooglePay
}

scalar WalletToken

type WebBankingSettings {
  canViewAccountDetails: Boolean
  canViewAccountStatement: Boolean
  canManageVirtualIbans: Boolean
  canInitiatePaymentsToNewBeneficiaries: Boolean
  canViewPaymentList: Boolean
  canOrderVirtualCards: Boolean
  canOrderPhysicalCards: Boolean
  canViewMembers: Boolean
  canAddNewMembers: Boolean
  canCreateMerchantProfile: Boolean
  canRequestOnlineCardsPaymentMethod: Boolean
  canRequestSepaDirectDebitCorePaymentMethod: Boolean
  canRequestSepaDirectDebitB2BPaymentMethod: Boolean
  canRequestInternalDirectDebitCorePaymentMethod: Boolean
  canRequestInternalDirectDebitB2BPaymentMethod: Boolean
  canRequestChecksPaymentMethod: Boolean
  canInitiateCheckMerchantPayments: Boolean
  canCreateMerchantPaymentLinks: Boolean
}

"""Rejection returned when a parameter has a wrong value"""
type WrongValueProvidedRejection implements Rejection {
  message: String!
  valueProvided: String!
  parameterName: String!
}