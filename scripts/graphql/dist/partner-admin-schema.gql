directive @apollo_studio_metadata(buildId: String, checkId: String, launchId: String) on SCHEMA

"""
Whether you call it a wallet, monetary account, payment account or bank account, the notion of account is fundamental at Swan. All payment flows necessarily go through an account.
"""
type Account {
  """Unique identifier of an account"""
  id: ID!

  """Unique account number"""
  number: AccountNumber!

  """Account name"""
  name: String!

  """Account holder"""
  holder: AccountHolder!

  """Cash account type"""
  cashAccountType: CashAccountType!

  """Country of the account"""
  country: AccountCountry!

  """Payment level"""
  paymentLevel: PaymentLevel!

  """
  Bank Identifier Code
  Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited`
  """
  BIC: BIC!

  """
  International Bank Account Number
  Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited`
  """
  IBAN: IBAN

  """Currency"""
  currency: Currency!

  """`true` if the main IBAN refuses all Sepa Direct Debit received"""
  blockSDD: Boolean

  """Status of the account"""
  statusInfo: AccountStatusInfo!

  """Partnership status"""
  partnershipStatusInfo: PartnershipStatusInfo

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """List of Virtual IBAN"""
  virtualIbanEntries(first: Int! = 50, before: String, after: String): VirtualIBANEntryConnection!

  """List of account membership for this account"""
  memberships(first: Int! = 50, before: String, after: String, filters: MembershipsFilterInput, orderBy: AccountMembershipOrderByInput): AccountMembershipConnection!

  """`true`if a consent is required to fetch new transactions"""
  requiredConsentToFetchNewTransactions: Boolean!

  """Language used for account statements"""
  language: AccountLanguage!

  """Legal representative account membership"""
  legalRepresentativeMembership: AccountMembership!

  """
  Type of the account : EMoney if account holder has not finished the KYC requirements, PaymentService otherwise
  """
  paymentAccountType: PaymentAccountType!

  """Date of the account going from eMoney to PaymentService"""
  upgradedAt: DateTime

  """
  A list of invoices of an account.
  The list is ordered by creation date (from newest to oldest)
  """
  invoices(
    """number of elements in the list (default value 10)"""
    first: Int! = 10

    """When the list of elements needs to start after an element"""
    after: String
  ): InvoiceConnection
}

"""Account Closed status information"""
type AccountClosedStatus implements AccountStatusInfo {
  """Account status (always Closed for type AccountClosedStatus)"""
  status: AccountStatus!

  """
  Reason why the account is suspended
  @Deprecated
  """
  reason: String!

  """Reason why the account is currently closed"""
  reasonInfo: CloseAccountStatusReason!
}

"""Account Closing status information"""
type AccountClosingStatus implements AccountStatusInfo {
  """Account status (always Closing for type AccountClosingStatus)"""
  status: AccountStatus!

  """
  Reason why the account is suspended
  @Deprecated
  """
  reason: String!

  """Reason why the account is currently in closing"""
  reasonInfo: CloseAccountStatusReason!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type AccountConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """AccountEdge list"""
  edges: [AccountEdge!]!
}

"""Available Account Country: CCA3"""
enum AccountCountry {
  FRA
  DEU

  """COMING SOON"""
  ESP

  """COMING SOON"""
  NDL
}

"""Implements the Relay Edge interface"""
type AccountEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The account"""
  node: Account!
}

enum AccountFundingLimitsReachedReason {
  """Account Holder instant funding limit exceeded"""
  InstantFundingLimitExceededRejection

  """Account Holder funding limit exceeded"""
  FundingLimitExceededRejection

  """Project instant funding limit exceeded"""
  ProjectInstantFundingLimitExceededRejection

  """Project funding limit exceeded"""
  ProjectFundingLimitExceededRejection

  """Global instant funding limit exceeded"""
  GlobalInstantFundingLimitExceededRejection

  """Global funding limit exceeded"""
  GlobalFundingLimitExceededRejection

  """Insufficient funds rejection"""
  InsufficientFundsRejection
}

"""
The account holder is the person who owns the money stored in the account. The account holder can be one of your customers, whether it is a natural person or a legal person, or quite simply you.
"""
type AccountHolder {
  """Unique identifier of the account holder."""
  id: ID!

  """
  Verification status.
  *Banking regulations require financial institutions such as Swan to know and verify their customers in order to comply with their anti-money laundering and terrorist financing obligations. In banking jargon, we talk about KYC (Know Your Customers) procedure*
  """
  verificationStatus: VerificationStatus!

  """Account holder type information."""
  info: AccountHolderInfo!

  """Account holder status information."""
  statusInfo: AccountHolderStatusInfo

  """Residency address."""
  residencyAddress: AddressInfo!

  """Created date."""
  createdDate: DateTime!

  """Updated date."""
  updatedDate: DateTime!

  """List of accounts owned by the account holder."""
  accounts(after: String, before: String, first: Int! = 50, orderBy: AccountOrderByInput): AccountConnection!

  """List of supporting document collection for an account holder"""
  supportingDocumentCollections(first: Int! = 50, before: String, after: String): SupportingDocumentCollectionConnection!

  """
  *COMING SOON*
  List of funding limit settings change request for an account holder
  """
  fundingLimitSettingsChangeRequests(first: Int! = 50, before: String, after: String): FundingLimitSettingsChangeRequestConnection!

  """Account holder onboarding"""
  onboarding: Onboarding

  """Funding limit settings"""
  fundingLimitSettings: FundingLimitSettings

  """A list of Payment Mandates for an account holder."""
  paymentMandates(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """
    When the list of elements needs to be ordered, by default, the list will be ordered by the latest updated Payment Mandate
    """
    orderBy: PaymentMandateOrderByInput

    """When the list of elements needs to be filtered"""
    filters: PaymentMandateFiltersInput
  ): PaymentMandateConnection
}

"""Account Holder Canceled Status Information"""
type AccountHolderCanceledStatusInfo implements AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!

  """Reason why the account holder is suspended."""
  reason: String!
}

type AccountHolderCompanyInfo implements AccountHolderInfo {
  """Account holder type (always Company for type AccountHolderCompanyInfo)"""
  type: AccountHolderType!

  """Name of the company."""
  name: String!

  """Registration number of the company (SIRET, ...)."""
  registrationNumber: String

  """Registration date of the company."""
  companyRegistrationDate: Date

  """Legal form of the company (SAS, SCI, SASU, ...)."""
  companyType: CompanyType

  """Business activity."""
  businessActivity: BusinessActivity!

  """
  Business activity description.
  This must be 1024 characters long maximum.
  """
  businessActivityDescription: String!

  """Estimated monthly payment volume (euro)."""
  monthlyPaymentVolume: MonthlyPaymentVolume!

  """
  The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
  
  The ultimate beneficiary is :
  - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
  - either the natural person (s) who exercise, by other means, a power of control of the company;
  """
  individualUltimateBeneficialOwners: [IndividualUltimateBeneficialOwner!]!

  """
  Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT
  """
  vatNumber: String

  """Tax Identification Number"""
  taxIdentificationNumber: String

  """Legal representative personal address"""
  legalRepresentativePersonalAddress: AddressInformation
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)).
"""
type AccountHolderConnection implements Connection {
  """Total number of element in the list."""
  totalCount: Int!

  """Information about the current, the previous and the next page."""
  pageInfo: PageInfo!

  """AccountHolderEdge list."""
  edges: [AccountHolderEdge!]!
}

"""Implements the Relay Edge interface."""
type AccountHolderEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism."""
  cursor: String!

  """The account holder."""
  node: AccountHolder!
}

"""Account Holder Enabled Status Information"""
type AccountHolderEnabledStatusInfo implements AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!
}

input AccountHolderFilterInput {
  status: [AccountHolderStatus!]
  types: [AccountHolderType!]
  verificationStatus: [VerificationStatus!]

  """Searches company name, first name, last name"""
  search: String
  firstName: String
  lastName: String
  birthDate: String
}

"""Individual account holder."""
type AccountHolderIndividualInfo implements AccountHolderInfo {
  """
  Account holder type (always Individual for type AccountHolderIndividualInfo).
  """
  type: AccountHolderType!

  """Account Holder's first name and last name."""
  name: String!

  """Employment status of the account holder (regulatory questions)."""
  employmentStatus: EmploymentStatus!

  """Monthly income of the account holder (regulatory questions)."""
  monthlyIncome: MonthlyIncome!

  """User of the individual account holder."""
  user: User!

  """Tax Identification Number"""
  taxIdentificationNumber: String
}

"""Account holder types."""
interface AccountHolderInfo {
  """Account holder type"""
  type: AccountHolderType!

  """Account holder name"""
  name: String!
}

"""Rejection returned when the Account Holder was not found"""
type AccountHolderNotFoundRejection implements Rejection {
  message: String!
}

"""
Field we can use when ordering that can be applied when listing account holders
"""
enum AccountHolderOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing account holders"""
input AccountHolderOrderByInput {
  field: AccountHolderOrderByFieldInput
  direction: OrderByDirection
}

"""Account holder status."""
enum AccountHolderStatus {
  """When the account holder is enabled."""
  Enabled

  """When the account holder is suspended."""
  Suspended

  """When the account holder is canceled."""
  Canceled
}

"""Account Holder Status Information"""
interface AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!
}

"""Account Holder Suspended Status Information"""
type AccountHolderSuspendedStatusInfo implements AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!

  """Reason why the account holder is suspended."""
  reason: String!
}

"""Account holder type"""
enum AccountHolderType {
  """Individual (Natural person)"""
  Individual

  """Company (Legal person)"""
  Company
}

"""Language: ISO 639-1 language code"""
enum AccountLanguage {
  de
  en
  fr
  it
  nl
  es
}

"""
An account membership represents the rights of a user for a given account.

*Each account is administered by an account membership having the capacity of legal representative. He has the possibility of delegating rights on this account to other users.*
"""
type AccountMembership {
  """unique identifier of an account membership"""
  id: ID!

  """email"""
  email: String!

  """user of this account membership"""
  user: User

  """
  `true` if this account membership having the capacity of the legal representative of the account holder.
  """
  legalRepresentative: Boolean!

  """
  `true` if this account membership can view account balances and transactions history
  """
  canViewAccount: Boolean!

  """`true` if this account membership can add or canceled beneficiaries"""
  canManageBeneficiaries: Boolean!

  """`true` if this account membership can initiate payments"""
  canInitiatePayments: Boolean!

  """
  `true` if this account membership can invite, update, suspend or resume memberships
  """
  canManageAccountMembership: Boolean!

  """status of the account membership"""
  statusInfo: AccountMembershipStatusInfo!

  """account of the account membership"""
  account: Account

  """Periodic Spending limit list"""
  spendingLimits: [SpendingLimit!]

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  version of the account membership started from '1' and incremented at every updates
  """
  version: String!

  """Residency address of the member"""
  residencyAddress: AddressInfo

  """Tax Identification Number of the member"""
  taxIdentificationNumber: String

  """List of accepted identification level"""
  acceptedIdentificationLevels: [IdentificationLevel]!

  """Recommended identification level"""
  recommendedIdentificationLevel: IdentificationLevel!

  """
  Indicate if the identity bound to the account membership has required identification level
  """
  hasRequiredIdentificationLevel: Boolean

  """Disabled date"""
  disabledAt: DateTime
}

"""when a user is binded with the error to the account membership"""
type AccountMembershipBindingUserErrorStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always BindingUserError for type AccountMembershipBindingUserErrorStatusInfo)
  """
  status: AccountMembershipStatus!

  """
  `true` if the first name of the user binded doesn't match with the invitation
  """
  firstNameMatchError: Boolean!

  """`true` if Swan hasn't verified the user's identity"""
  idVerifiedMatchError: Boolean!

  """
  `true` if the last name of the user binded doesn't match with the invitation
  """
  lastNameMatchError: Boolean!

  """
  `true` if the phone number of the user binded doesn't match with the invitation
  """
  phoneNumberMatchError: Boolean!

  """
  `true` if the birth date of the user binded doesn't match with the invitation
  """
  birthDateMatchError: Boolean!

  """restricted to a user"""
  restrictedTo: RestrictedTo!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type AccountMembershipConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """AccountMembershipEdge list"""
  edges: [AccountMembershipEdge!]!
}

"""when the user has to consent to invite a new account membership"""
type AccountMembershipConsentPendingStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always ConsentPending for type AccountMembershipConsentPendingStatusInfo)
  """
  status: AccountMembershipStatus!

  """The consent required to invite this account membership"""
  consent: Consent!

  """restricted to a user"""
  restrictedTo: RestrictedTo!
}

"""when the account membership is disabled"""
type AccountMembershipDisabledStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always Disabled for type AccountMembershipDisabledStatusInfo)
  """
  status: AccountMembershipStatus!

  """reason why the account membership is disabled"""
  reason: String!
}

"""Implements the Relay Edge interface"""
type AccountMembershipEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The account membership"""
  node: AccountMembership!
}

"""when the account membership is enabled"""
type AccountMembershipEnabledStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always Enabled for type AccountMembershipEnabledStatusInfo)
  """
  status: AccountMembershipStatus!
}

"""
when a new account membership is invited and there is no user binded yet
"""
type AccountMembershipInvitationSentStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always InvitationSent for type AccountMembershipInvitationSentStatusInfo)
  """
  status: AccountMembershipStatus!

  """restricted to a user"""
  restrictedTo: RestrictedTo!
}

"""
Field we can use when ordering that can be applied when listing account memberships
"""
enum AccountMembershipOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing account memberships"""
input AccountMembershipOrderByInput {
  field: AccountMembershipOrderByFieldInput
  direction: OrderByDirection
}

"""
Filters that can be applied when listing accounts (Only applied in user context)
"""
input AccountMembershipsFilterInput {
  """Can the user initiate payments on this account"""
  canInitiatePayments: Boolean

  """Can the user manage account membership"""
  canManageAccountMembership: Boolean

  """Can the user manage beneficiaries"""
  canManageBeneficiaries: Boolean

  """Can the user view account"""
  canViewAccount: Boolean

  """Account memberships status/statuses we're looking for"""
  status: [AccountMembershipStatus!]

  """Filtered by email"""
  email: String

  """Filtered by first name"""
  firstName: String

  """Filtered by last name"""
  lastName: String

  """Searches email, first name, last name, and id"""
  search: String
}

"""AccountMembership enabled"""
enum AccountMembershipStatus {
  """when the consent to invite the account membership is pending"""
  ConsentPending

  """when the account membership is invited"""
  InvitationSent

  """when the user binded with errors to the account membership"""
  BindingUserError

  """when the account membership is enabled"""
  Enabled

  """when the account membership is suspended"""
  Suspended

  """when the account membership is disabled"""
  Disabled
}

"""here are the different account membership status:"""
interface AccountMembershipStatusInfo {
  """AccountMembership status"""
  status: AccountMembershipStatus!
}

"""when the account membership is suspended"""
type AccountMembershipSuspendedStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always Suspended for type AccountMembershipSuspendedStatusInfo)
  """
  status: AccountMembershipStatus!

  """reason why the account membership is suspended"""
  reason: String!
}

"""Thrown when an related account is not eligible to the feature"""
type AccountNotEligibleRejection implements Rejection {
  message: String!
}

"""
Rejection returned if the account was not found or if the user does not have the rights to know that the card exists
"""
type AccountNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Swan account number"""
scalar AccountNumber

"""Account Opened status information"""
type AccountOpenedStatus implements AccountStatusInfo {
  """Account status (always Opened for type AccountOpenedStatus)"""
  status: AccountStatus!
}

"""Fields that can be used when ordering accounts"""
enum AccountOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing accounts"""
input AccountOrderByInput {
  field: AccountOrderByFieldInput
  direction: OrderByDirection
}

enum AccountStatus {
  """When the account is opened"""
  Opened

  """When the account is suspended"""
  Suspended

  """When the account is currently closing"""
  Closing

  """When the account is closed"""
  Closed
}

interface AccountStatusInfo {
  """Account status"""
  status: AccountStatus!
}

"""Account Suspended status information"""
type AccountSuspendedStatus implements AccountStatusInfo {
  """Account status (always Suspended for type AccountSuspendedStatus)"""
  status: AccountStatus!

  """
  Reason why the account is suspended
  @Deprecated
  """
  reason: String!

  """Reason why the account is currently suspend"""
  reasonInfo: SuspendAccountStatusReason!
}

"""Account Verification"""
interface AccountVerification {
  """Creation date of the account verification"""
  createdAt: DateTime!

  """Unique identifier of the Account Verification"""
  id: ID!

  """Account Verification Status Information"""
  statusInfo: AccountVerificationStatusInfo!

  """Last update date of the account verification"""
  updatedAt: DateTime!
}

"""
Rejection returned when the external account has already been rejected.

In such a case, contact Swan directly to resolve the situation for this specific account holder.
"""
type AccountVerificationAlreadyRejectedRejection implements Rejection {
  message: String!
}

"""Account Verification Status"""
enum AccountVerificationStatus {
  """
  We are waiting for the end user to send a credit transfer from his external iban to any Swan owned iban
  """
  PendingVerification

  """
  We could not automatically match the external iban based on last received transfer.
  Manuel review process is underway
  """
  PendingReview

  """Account has been verified"""
  Verified

  """Account verification has been rejected"""
  Rejected
}

"""Account Verification Status Information"""
interface AccountVerificationStatusInfo {
  """Account verification status"""
  status: AccountVerificationStatus!
}

"""
Rejection returned when the Account Verification is not in the expected status
"""
type AccountVerificationWrongStatusRejection implements Rejection {
  message: String!
}

"""Address Information"""
type Address {
  """address line 1"""
  addressLine1: String

  """addressLine2"""
  addressLine2: String

  """city"""
  city: String

  """postal code (max 10 characters)"""
  postalCode: String

  """state"""
  state: String

  """country"""
  country: CCA3
}

"""Address information."""
type AddressInfo {
  """Address line 1."""
  addressLine1: String

  """Address line 2."""
  addressLine2: String

  """City."""
  city: String

  """Postal code."""
  postalCode: String

  """State."""
  state: String

  """Country."""
  country: CCA3
}

"""Address"""
type AddressInformation {
  """Address"""
  addressLine1: String!

  """Address"""
  addressLine2: String

  """City"""
  city: String!

  """Country"""
  country: CCA3!

  """Postal code"""
  postalCode: String!

  """State"""
  state: String
}

"""Address"""
input AddressInformationInput {
  """Address"""
  addressLine1: String!

  """Address"""
  addressLine2: String

  """City"""
  city: String!

  """Country"""
  country: CCA3!

  """Postal code"""
  postalCode: String!

  """State"""
  state: String
}

"""Address Information"""
input AddressInput {
  """address line 1 (max 100 characters)"""
  addressLine1: String

  """address line 2 (max 100 characters)"""
  addressLine2: String

  """city (max 100 characters)"""
  city: String

  """postal code (max 10 characters)"""
  postalCode: String

  """state (max 100 characters)"""
  state: String

  """country code"""
  country: CCA3!
}

"""Amount with its currency"""
type Amount {
  """currency"""
  currency: Currency!

  """value of the amount"""
  value: AmountValue!
}

"""Amount with its currency"""
input AmountInput {
  """value of the amount"""
  value: AmountValue!

  """currency"""
  currency: Currency!
}

"""
The amount given with fractional digits, where fractions must be compliant to the currency definition. Up to 14 significant figures. Negative amounts are signed by minus. The decimal separator is a dot.

Example: Valid representations for EUR with up to two decimals are:

1056
5768.2
-1.50
5877.78
"""
scalar AmountValue

type AmountWithCurrency {
  value: AmountValue!
  currency: Currency!
}

"""Approved Funding Limit"""
type ApprovedFundingLimit {
  """Requested amount settings for the instant funding limit"""
  instantFundingLimit: FundingLimitAmount!

  """Requested amount settings for the funding limit"""
  fundingLimit: FundingLimitAmount!
}

scalar AuditId

"""A method used to authenticate a user"""
type Authenticator {
  """Operating System (Apple, Android, ...)"""
  os: String

  """Device Brand (Apple, Samsung, ...)"""
  brand: String

  """Device Model (iPhone XS, Samsung S3, ...)"""
  model: String

  """Type of authenticator"""
  type: AuthenticatorType!

  """User agent, if it's a web authenticator"""
  userAgent: String

  """
  Accept-Language header used during registration, if it's a web authenticator
  """
  acceptLanguage: String
  status: AuthenticatorStatus!
}

enum AuthenticatorStatus {
  """
  The user must send their basic personal info (firstname, name, birthdate)
  before the status can switch to Enabled
  """
  WaitingForUserInfo

  """
  The user must go through the verification (reinit) process
  Once verified, the status will switch to Enabled
  """
  WaitingForVerification

  """
  The user must go through customer support for verification (reinit)
  Once verified, the status will switch to Enabled
  """
  WaitingForCustomerSupportVerification

  """The authenticator can be used eg. to sign requests or call our apis"""
  Enabled

  """
  The authenticator was canceled because the user disconnected
  or they created a new authenticator - this status is final
  """
  Canceled

  """The authenticator was suspended - this status is final"""
  Suspended
}

enum AuthenticatorType {
  """The Swan app"""
  Swan

  """A Swan web authenticator"""
  SwanWeb
}

scalar AuthorizationId

"""Rejection returned if the status account is not valid"""
type BadAccountStatusRejection implements Rejection {
  id: String!
  message: String!
}

type BadRequestRejection implements Rejection {
  message: String!
}

"""Bank Identifier Code"""
scalar BIC

type Branding {
  projectId: String
  name: String!
  logoUri: String
  accentColor: String
  customConsentSubdomain: String
}

type BrowserConsent implements DetailedConsent {
  id: ID!
  projectId: String
  accountId: String
  requireSCA: Boolean!
  status: ConsentStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  startedAt: DateTime
  expiredAt: DateTime
  consentResponses: [ConsentResponse!]!
  purpose: DetailedConsentPurpose!
  serviceToHook: String!
  consentOperations: [ConsentOperation!]!
  env: EnvType!
  identityId: String!
  state: String
  branding: Branding!
  operationsSHA256HexDigest: String
  consentUrl: String!
  redirectUrl: String!
  allowsServerConsent: Boolean!
  challenge: String
}

type BrowserMultiConsent implements DetailedConsent {
  id: ID!
  projectId: String
  accountId: String
  requireSCA: Boolean!
  status: ConsentStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  startedAt: DateTime
  expiredAt: DateTime
  consentResponses: [ConsentResponse!]!
  purpose: DetailedConsentPurpose!
  consentOperations: [ConsentOperation!]!
  env: EnvType!
  identityId: String!
  state: String
  branding: Branding!
  operationsSHA256HexDigest: String
  aggregatedPurposesWithOperations: [PurposeWithOperations!]!
  consentUrl: String!
  redirectUrl: String!
  allowsServerConsent: Boolean!
  challenge: String
}

"""Business activity."""
enum BusinessActivity {
  AdministrativeServices
  Agriculture
  Arts
  BusinessAndRetail
  Construction
  Education
  ElectricalDistributionAndWaterSupply
  FinancialAndInsuranceOperations
  Health
  Housekeeping
  InformationAndCommunication
  LodgingAndFoodServices
  ManufacturingAndMining
  Other
  PublicAdministration
  RealEstate
  ScientificActivities
  Transportation
}

"""CanceledMerchantPaymentMethodStatusInfo"""
type CanceledMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method canceled date"""
  canceledAt: Date!
}

"""CanceledMerchantPaymentProductStatusInfo"""
type CanceledMerchantPaymentProductStatusInfo implements MerchantPaymentProductStatusInfo {
  status: MerchantPaymentProductStatus!

  """Merchant Payment Product canceled date"""
  canceledAt: Date!
}

"""CanceledMerchantProfileStatusInfo"""
type CanceledMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  canceledAt: Date!
  enabledAt: Date
}

enum CardAuthorizationOutcome {
  Accepted
  AccountClosed
  AccountSuspended
  AtmWithdrawalAmountLimitExceeded
  AtmWithdrawalNumberLimitExceeded
  AuthorizationConsumed
  AuthorizationUpdated
  AuthorizationValidityExceeded
  CardCanceled
  CardExpired
  CardholderCancelation
  CardLost
  CardNotProvidedToCardholderOrClosed
  CardNumberInvalid
  CardOpposedCardStolen
  CardOutOfOrder
  CardTemporarilyLocked
  CardUnknown
  DoNotHonor
  eMoneyAccount
  eMoneyAccountLimitExceeded
  IncorrectPinCodeAttemptsExceeded
  InsufficientFunds
  MerchantInvalid
  MerchantShouldResubmitAuthorization
  MiscellaneousReason
  OriginalTransactionNotFound
  PartialApproval
  PartialCancelation
  PeriodAmountLimitExceeded
  PeriodNumberTransactionLimitExceeded
  PinCodeInvalid
  PinCodeValidationImpossible
  SpendingLimitsReached
  TechnicalError
  TransactionAmountLimitExceeded
  TransactionCurrencyIncorrect
  TransactionInvalid
  TransactionNotAuthorizedForCardholder
  TransactionNotAuthorizedForPointOfSale
}

enum CardAuthorizationType {
  Classic
  PreAuthorization
  DataRequest
}

"""
Rejection returned if the card was not found or if the user does not have the rights to know that the account exists
"""
type CardNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

scalar CardToken

enum CardTransactionCategory {
  InStore
  eCommerce
  eCommerceWith3DS
  Withdrawal
  Other
}

"""Type of card"""
enum CardType {
  Physical
  Virtual
}

"""Cash account type (Always Current)"""
enum CashAccountType {
  """When the account is a current account."""
  Current
  CashPayment
  Charges
  CashIncome
  Commission
  ClearingParticipantSettlementAccount
  LimitedLiquiditySavingsAccount
  Loan
  MarginalLending
  MoneyMarket
  NonResidentExternal
  Overdraft
  OverNightDeposit
  OtherAccount
  Settlement
  Salary
  Savings
  Tax
  TransactingAccount
  CashTrading
}

"""Country code alpha 2 (ISO 3166)"""
scalar CCA2

"""Country code alpha 3 (ISO 3166)"""
scalar CCA3

"""CheckMerchantPaymentMethod"""
type CheckMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  productId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applicated to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

"""CheckMerchantPaymentProduct"""
type CheckMerchantPaymentProduct implements MerchantPaymentProduct {
  """
  Unique identifier tied to every version of a given Merchant Payment Product
  """
  id: ID!

  """The Merchant Payment Product Type"""
  type: MerchantPaymentProductType!

  """
  Unique identifier for a given merchant Payment Product, identical for every version of a given Merchant Payment Product Type
  """
  productId: ID!

  """Status of the Merchant Payment Product"""
  statusInfo: MerchantPaymentProductStatusInfo!

  """Version of the Merchant Payment Product"""
  version: Int!

  """Date at which the Merchant Payment Product was last updated"""
  updatedAt: Date!

  """Rolling Reserve applicated to the Merchant Payment Product"""
  rollingReserve: RollingReserve
}

"""
Define a reason with a message and a specific type for closing account action
"""
type CloseAccountReason implements Reason {
  type: CloseAccountReasonType!
  message: String
}

"""Specific type for closing account action"""
enum CloseAccountReasonType {
  """Compliance Reason"""
  ComplianceReason

  """Partner Reason"""
  PartnerReason

  """Inactivity"""
  Inactivity
}

"""
Union between PartnerCloseAccountReasonType and InternalCloseAccountReason
"""
union CloseAccountStatusReason = CloseAccountReason

"""Type of company."""
enum CompanyType {
  Association
  Company
  HomeOwnerAssociation
  Other
  SelfEmployed
}

"""Complete Address Information"""
input CompleteAddressInput {
  """address line 1 (max 38 characters)"""
  addressLine1: String!

  """address line 2 (max 38 characters)"""
  addressLine2: String

  """city (max 30 characters)"""
  city: String!

  """postal code (max 10 characters)"""
  postalCode: String!

  """state (max 30 characters)"""
  state: String

  """country code"""
  country: CCA3!
}

"""Complete Address Information with a contact"""
input CompleteAddressWithContactInput {
  """address line 1 (max 38 characters)"""
  addressLine1: String!

  """address line 2 (max 38 characters)"""
  addressLine2: String

  """city (max 30 characters)"""
  city: String!

  """postal code (max 10 characters)"""
  postalCode: String!

  """state (max 30 characters)"""
  state: String

  """country code"""
  country: CCA3!

  """contact first name"""
  firstName: String!

  """contact last name"""
  lastName: String!

  """contact phone number"""
  phoneNumber: PhoneNumber!

  """contact company name (max 38 characters)"""
  companyName: String
}

"""
Relay Connection type, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
interface Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """Edge list"""
  edges: [Edge!]!
}

"""
Some sensitive operation at Swan, such as initiating a payment, require consent
"""
type Consent {
  """unique identifier of the consent"""
  id: ID!

  """`true` if the consent requires a Strong Customer Authentication"""
  requireSCA: Boolean!

  """status of the consent"""
  status: ConsentStatus!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime

  """date when the `consentUrl` was request the first time"""
  startedAt: DateTime

  """date when the consent expire"""
  expiredAt: DateTime

  """purpose of the consent"""
  purpose: ConsentPurpose!

  """Redirect the user to this URL to start the consent flow"""
  consentUrl: String!

  """When the consent flow is finished the user is redirected to this URL"""
  redirectUrl: String!

  """userId who initiated the consent"""
  userId: String!

  """user who initiated the consent"""
  user: User

  """unique hash of the consent"""
  challenge: String
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type ConsentConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ConsentEdge list"""
  edges: [ConsentEdge!]!
}

"""Implements the Relay Edge interface"""
type ConsentEdge implements Edge {
  """
  Opaque identifier pointing to this consent node in the pagination mechanism
  """
  cursor: String!

  """The consent"""
  node: Consent!
}

type ConsentOperation {
  props: [ConsentOperationProperty!]
}

type ConsentOperationProperty {
  name: ConsentOperationPropertyName!
  value: String!
}

enum ConsentOperationPropertyName {
  Account
  AccountFrom
  AccountHolderName
  AccountTo
  AllowedIpAddresses
  Amount
  BeneficiaryName
  BirthDate
  CardDesignURL
  CardHolderName
  CardNumber
  CardOption
  DeliveryAddress
  Email
  FirstName
  From
  Iban
  Label
  LastName
  Merchant
  MerchantIdentifier
  Option
  Permissions
  PhoneNumber
  PublicKey
  SpendingLimit
  To
  MandateScheme
  MandateReference
  MandateSequenceType
  SignatureDate
  CreditorName
  CreditorAddress
  CreditorIdentifier
  DebtorName
  DebtorIban
  DebtorBankName
  MandateLegalNotice
}

"""Purpose of a consent"""
enum ConsentPurpose {
  """when accepting the partnership conditions"""
  AcceptPartnershipConditions

  """when inviting a new account membership"""
  AddAccountMembership

  """when adding several account memberships"""
  AddAccountMemberships

  """when adding a beneficiary"""
  AddBeneficiary

  """when adding a virtual card"""
  AddCard

  """when adding multiple cards"""
  AddCards

  """when adding a digital card"""
  AddDigitalCard

  """when activating a physical card"""
  ActivatePhysicalCard

  """when closing an account"""
  CloseAccount

  """when initiating a credit transfer"""
  InitPayment

  """when requesting to print physical card"""
  PrintPhysicalCard

  """when resuming an account membership"""
  ResumeAccountMembership

  """when resuming a physical card"""
  ResumePhysicalCard

  """when scheduling a standing order"""
  ScheduleStandingOrder

  """when updating an account membership"""
  UpdateAccountMembership

  """when updating a card"""
  UpdateCard

  """when updating a server consent project settings"""
  UpdateServerConsentProjectSettings

  """when viewing card confidential of a virtual card"""
  ViewCardNumbers

  """when requesting to view physical card PIN"""
  ViewPhysicalCardPin

  """when enabling a mandate"""
  EnableMandate

  """when adding a payment direct debit mandate"""
  AddDirectDebitPaymentMandate

  """when initiating a funding request"""
  InitiateFundingRequest

  """when initiating an instant funding request"""
  InitiateInstantFundingRequest

  """when the consent is a multiple consent"""
  ConsentToMultipleConsents
}

type ConsentResponse {
  identityId: ID!
  originIdentityId: ID!
  authenticatorId: ID!
  idVerified: Boolean!
  provider: AuthenticatorType!
  credentialTypeUsed: CredentialType!
  macAddress: String!
  ipAddress: String!
  respondedAt: DateTime
}

"""Status of a consent"""
enum ConsentStatus {
  """when the user accepted"""
  Accepted

  """when the user refused"""
  CustomerRefused

  """when the operation is committing"""
  OperationCommitting

  """when the user credentials were refused"""
  CredentialRefused

  """when the consent is created"""
  Created

  """when the consentUrl has been requested"""
  Started

  """when the consent is expired"""
  Expired

  """when something went wrong"""
  Failed

  """when the user or the project decided to cancel the consent"""
  Canceled
}

"""Sandbox user input payload."""
input CreateSandboxUserInput {
  """First name"""
  firstName: String!

  """Last name"""
  lastName: String!

  """List of first names"""
  allFirstNames: [String!]

  """Birth date"""
  birthDate: Date!

  """
  [Alpha-3 birth country representation](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  """
  birthCountryCCA3: CCA3

  """
  [Alpha-3 nationality representation](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  Ex: FRA for french nationality
  """
  nationalityCCA3: CCA3!

  """
  Verification status is now is now an Account-Holder's attribute
  @deprecated(reason: "Verification status is now is now an Account-Holder's attribute. Updating this status should be done on the account holder level instead of sandbox users.")
  """
  verificationStatus: VerificationStatus

  """Let you simulate every use case of our identity verification process."""
  identificationStatus: IdentificationStatus!

  """Identification levels."""
  identificationLevels: IdentificationLevelsInput

  """
  Saves you considerable time during the development phase,
  by automatically allowing consent,
  removing the need to repeatedly get consent.
  """
  autoConsent: Boolean!
}

"""Union of success payload and possible rejections"""
union CreateSandboxUserPayload = CreateSandboxUserSuccessPayload | NationalityNotFoundRejection | ForbiddenRejection

"""Success payload type"""
type CreateSandboxUserSuccessPayload {
  """Creates a sandbox user"""
  sandboxUser: SandboxUser!
}

enum CredentialType {
  Pin
  FaceId
  TouchId
}

enum CreditTransferMode {
  InstantWithoutFallback
  InstantWithFallback
  Regular
}

"""currency code alpha 3 (ISO 4217)"""
scalar Currency

"""Date with YYYY-MM-DD format"""
scalar Date

"""
Date time (ISO 8601 with time information)
ex: 2021-04-12T16:28:22.867Z
"""
scalar DateTime

"""Rejection returned when the Debtor is closed"""
type DebtorAccountClosedRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the Debtor does not belong to the same project as the creditor
"""
type DebtorAccountNotAllowedRejection implements Rejection {
  message: String!
}

"""Input of to delete a sandbox user"""
input DeleteSandboxUserInput {
  """Id of the sandbox user to delete"""
  id: String!
}

"""Union of the success payload and possible rejections"""
union DeleteSandboxUserPayload = DeleteSandboxUserSuccessPayload | ForbiddenRejection | LastSandboxUserCannotBeDeletedRejection | SandboxUserNotFoundRejection

type DeleteSandboxUserSuccessPayload {
  """Success flag"""
  success: Boolean!
}

interface DetailedConsent {
  id: ID!
  projectId: String
  requireSCA: Boolean!
  status: ConsentStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  startedAt: DateTime
  expiredAt: DateTime
  consentResponses: [ConsentResponse!]!
  purpose: DetailedConsentPurpose!
  consentOperations: [ConsentOperation!]!
  env: EnvType!
  identityId: String!
  state: String
  branding: Branding!
  operationsSHA256HexDigest: String
  challenge: String
}

type DetailedConsentConnection {
  totalCount: Int!
  pageInfo: PageInfo
  edges: [DetailedConsentEdge!]!
}

type DetailedConsentEdge {
  node: DetailedConsent!
  cursor: String!
}

"""Purpose of a consent"""
enum DetailedConsentPurpose {
  """when accepting the partnership conditions"""
  AcceptPartnershipConditions

  """when inviting a new account membership"""
  AddAccountMembership

  """when adding several account memberships"""
  AddAccountMemberships

  """when adding a beneficiary"""
  AddBeneficiary

  """when adding a virtual card"""
  AddCard

  """when adding multiple cards"""
  AddCards

  """when adding a digital card"""
  AddDigitalCard

  """when activating a physical card"""
  ActivatePhysicalCard

  """when closing an account"""
  CloseAccount

  """when initiating a credit transfer"""
  InitPayment

  """when requesting to print physical card"""
  PrintPhysicalCard

  """when resuming an account membership"""
  ResumeAccountMembership

  """when resuming a physical card"""
  ResumePhysicalCard

  """when scheduling a standing order"""
  ScheduleStandingOrder

  """when updating an account membership"""
  UpdateAccountMembership

  """when updating a card"""
  UpdateCard

  """when viewing card confidential of a virtual card"""
  ViewCardNumbers

  """when requesting to view physical card PIN"""
  ViewPhysicalCardPin

  """to update server consent settings on project"""
  UpdateServerConsentProjectSettings

  """when enabling a mandate"""
  EnableMandate

  """when adding a payment direct debit mandate"""
  AddDirectDebitPaymentMandate

  """when initiating a funding request"""
  InitiateFundingRequest

  """when initiating an instant funding request"""
  InitiateInstantFundingRequest

  """if the consent is a multiple consent"""
  ConsentToMultipleConsents

  """
  if the consent originates from a oauth2 flow, the purpose should be determined from its scopes
  """
  OAuth2

  """if the consent originates from a 3DS flow"""
  ThreeDsPayment
}

"""Input to decide on digitalization"""
input DigitalizationInput {
  """The card id to provision"""
  cardId: String!

  """Type of card"""
  cardType: CardType!

  """Response from swan to the provisioning request"""
  provisioningResponse: ProvisioningResponse!

  """Type of card"""
  responseChannel: ResponseChannel!

  """Wallet Provider (ApplePay, GooglePay ...)"""
  walletProvider: WalletProviderType
}

"""Direct Debit Account Verification"""
type DirectDebitAccountVerification implements AccountVerification {
  """Creation date of the account verification"""
  createdAt: DateTime!

  """IBAN of the account to cross check with account holder information"""
  iban: IBAN!

  """Unique identifier of the Account Verification"""
  id: ID!

  """Account Verification Status Information"""
  statusInfo: AccountVerificationStatusInfo!

  """Last update date of the account verification"""
  updatedAt: DateTime!
}

"""StatusInfo when funding limit settings has been disabled"""
type DisabledFundingLimitSettingsStatusInfo implements FundingLimitSettingsStatusInfo {
  status: FundingLimitSettingsStatus!
  reason: String!
}

"""EnabledMerchantPaymentMethodStatusInfo"""
type DisabledMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method disabled date"""
  disabledAt: Date!
}

"""EnabledMerchantPaymentProductStatusInfo"""
type DisabledMerchantPaymentProductStatusInfo implements MerchantPaymentProductStatusInfo {
  status: MerchantPaymentProductStatus!

  """Merchant Payment Product disabled date"""
  disabledAt: Date!
}

"""
Edge type containing the node and cursor. The node is not defined in the interface because generic is not supported by GraphQL
but all implementation contains its own node property according to the paginated type.
"""
interface Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

scalar EmailAddress

"""Employment status."""
enum EmploymentStatus {
  Craftsman
  Employee
  Entrepreneur
  Farmer
  Manager
  Practitioner
  Retiree
  ShopOwner
  Student
  Unemployed
}

"""StatusInfo when the funding limit settings is enabled"""
type EnabledFundingLimitSettingsStatusInfo implements FundingLimitSettingsStatusInfo {
  status: FundingLimitSettingsStatus!
}

"""EnabledMerchantPaymentMethodStatusInfo"""
type EnabledMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method enabled date"""
  enabledAt: Date!
}

"""EnabledMerchantPaymentProductStatusInfo"""
type EnabledMerchantPaymentProductStatusInfo implements MerchantPaymentProductStatusInfo {
  status: MerchantPaymentProductStatus!

  """Merchant Payment Product enabled date"""
  enabledAt: Date!
}

"""EnabledMerchantProfileStatusInfo"""
type EnabledMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  enabledAt: Date!
}

type EndorseSandboxUserDummyRejection implements Rejection {
  message: String!
}

"""Input of the sandbox user you want to be logged as"""
input EndorseSandboxUserInput {
  """Sandbox user ID"""
  id: String!
}

"""Union of the success payload and possible rejections"""
union EndorseSandboxUserPayload = EndorseSandboxUserSuccessPayload | ForbiddenRejection | SandboxUserNotFoundRejection

"""Success payload type"""
type EndorseSandboxUserSuccessPayload {
  sandboxUser: SandboxUser!
}

enum EnvType {
  Live
  Sandbox
}

enum FieldValidationError {
  Missing
}

type ForbiddenRejection implements Rejection {
  message: String!
}

type FundingLimit {
  """Maximum Funding Amount authorized"""
  amount: Amount!

  """Funding Amount that has already been used during the interval"""
  funding: Amount

  """Interval in number of calendar days where the limit is applied"""
  rollingDays: Int!
}

"""Funding Limit Amount"""
type FundingLimitAmount {
  """The amount settings"""
  amount: Amount!
}

"""Funding Limit Amount Input"""
input FundingLimitAmountInput {
  """The amount settings"""
  amount: AmountInput!
}

"""Rejection returned when the Account Holder Funding has been exceeded"""
type FundingLimitExceededRejection implements Rejection {
  message: String!
}

type FundingLimitSettings {
  """Instant funding limit"""
  instantFundingLimit: InstantFundingLimit

  """Periodic funding limit"""
  fundingLimit: FundingLimit

  """Related change request"""
  fundingLimitSettingsChangeRequest: FundingLimitSettingsChangeRequest

  """Status of the resource"""
  statusInfo: FundingLimitSettingsStatusInfo!
}

"""Funding Limit Settings Change Request"""
type FundingLimitSettingsChangeRequest {
  """Unique identifier of a funding limit settings change request"""
  id: ID!

  """Requested amount settings for the instant funding limit"""
  instantFundingLimit: FundingLimitAmount!

  """Requested amount settings for the funding limit"""
  fundingLimit: FundingLimitAmount!

  """
  Approved amount settings for the the instant funding limit and the funding limit
  """
  approved: ApprovedFundingLimit

  """Status of the request"""
  statusInfo: FundingLimitSettingsChangeRequestStatusInfo!

  """Date of creation"""
  createdAt: Date

  """Date of last update"""
  updatedAt: Date
}

"""
StatusInfo when funding limit settings change request has been approved
"""
type FundingLimitSettingsChangeRequestApprovedStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
  reason: String!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type FundingLimitSettingsChangeRequestConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """FundingLimitSettingsChangeRequestEdge list"""
  edges: [FundingLimitSettingsChangeRequestEdge!]!
}

"""Implements the Relay Edge interface"""
type FundingLimitSettingsChangeRequestEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The FundingLimitSettingsChangeRequest"""
  node: FundingLimitSettingsChangeRequest!
}

"""
Filters that can be applied when listing funding limit settings change requests
"""
input FundingLimitSettingsChangeRequestFiltersInput {
  """The ids of the funding limit settings change requests"""
  id: [String!]

  """Status we want to filter on"""
  status: [FundingLimitSettingsChangeRequestStatus!]
}

type FundingLimitSettingsChangeRequestNotFoundRejection implements Rejection {
  message: String!
}

"""
Field we can use when ordering that can be applied when listing funding limit settings change requests
"""
enum FundingLimitSettingsChangeRequestOrderByFieldInput {
  id
  createdAt
  updatedAt
}

"""
Order that can be applied when listing funding limit settings change requests
"""
input FundingLimitSettingsChangeRequestOrderByInput {
  field: FundingLimitSettingsChangeRequestOrderByFieldInput
  direction: OrderByDirection
}

"""StatusInfo when funding limit settings change request is pending"""
type FundingLimitSettingsChangeRequestPendingStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
}

"""
StatusInfo when funding limit settings change request has been rejected
"""
type FundingLimitSettingsChangeRequestRefusedStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
  reason: String!
}

"""Funding Limit Settings Change Request Status"""
enum FundingLimitSettingsChangeRequestStatus {
  """When the request is in waiting for information"""
  WaitingForInformation

  """When the request is in pending"""
  Pending

  """When the request is approved"""
  Approved

  """When the request is refused"""
  Refused
}

"""
Object containing details about funding limit settings change request status
"""
interface FundingLimitSettingsChangeRequestStatusInfo {
  """Current limit settings change request status."""
  status: FundingLimitSettingsChangeRequestStatus!
}

type FundingLimitSettingsChangeRequestStatusNotAllowedRejection implements Rejection {
  message: String!
}

"""
StatusInfo when funding limit settings change request is waiting for more information
"""
type FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
}

"""Possible values for funding limit settings status"""
enum FundingLimitSettingsStatus {
  """When the funding limit settings is enabled"""
  Enabled

  """When the funding limit settings is suspended"""
  Suspended

  """When the funding limit settings is disabled"""
  Disabled
}

"""Object containing details about funding limit settings status"""
interface FundingLimitSettingsStatusInfo {
  """Current funding limit settings."""
  status: FundingLimitSettingsStatus!
}

"""Funding Source"""
interface FundingSource {
  """ID of the Funding Source"""
  id: ID!

  """Name of the Funding Source"""
  name: String

  """Funding Source status information"""
  statusInfo: FundingSourceStatusInfo!

  """Created date"""
  createdAt: DateTime!

  """Last updated date"""
  updatedAt: DateTime!
}

type FundingSourceNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Funding Source Statuses"""
enum FundingSourceStatus {
  Pending
  Enabled
  Canceled
  Rejected
  Suspended
}

"""Funding Source status information"""
interface FundingSourceStatusInfo {
  """Funding Source Pending status"""
  status: FundingSourceStatus!
}

"""
Rejection returned when the Funding Source is not in the expected status
"""
type FundingSourceWrongStatusRejection implements Rejection {
  message: String!
  currentStatus: FundingSourceStatus!
  expectedStatus: FundingSourceStatus!
}

"""Rejection returned when the Global Funding has been exceeded"""
type GlobalFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the Global Instant Funding limit has been exceeded
"""
type GlobalInstantFundingLimitExceededRejection implements Rejection {
  message: String!
}

type GraphqlInputValidationRejection implements Rejection {
  field: String!
  reason: String!
  message: String!
}

scalar HexColorCode

"""International Bank Account Number"""
scalar IBAN

"""Rejection returned when the IBAN is not reachable"""
type IBANNotReachableRejection implements Rejection {
  message: String!
}

"""Rejection returned when the IBAN is not valid"""
type IBANNotValidRejection implements Rejection {
  message: String!
}

"""Virtual IBAN Status"""
enum IBANStatus {
  """When the virtual IBAN accept to receive Sepa payments"""
  Enabled

  """When the virtual IBAN refuse definitely to receive Sepa payments"""
  Canceled

  """When the virtual IBAN refuse temporarily to receive Sepa payments"""
  Suspended
}

"""Possible value for the field IdentificationLevel"""
enum IdentificationLevel {
  """Human identity verification"""
  Expert

  """Identity verification with Qualified Electronic Signature"""
  QES

  """Identity verification with PVID"""
  PVID
}

"""Identification levels"""
type IdentificationLevels {
  PVID: Boolean!
  QES: Boolean!
  expert: Boolean!
}

"""Sandbox user identification levels input payload."""
input IdentificationLevelsInput {
  """Identity verified by an expert (Ubble-like)"""
  expert: Boolean!

  """
  Identity verified by an expert with a Remote Identity Verification Service
  """
  PVID: Boolean!

  """
  Identity verified by an expert and a Qualified Electronic Signature has been done
  """
  QES: Boolean!
}

"""Identification status"""
enum IdentificationStatus {
  """The user hasn't started the identity verification process yet."""
  Uninitiated

  """
  The user has gone through the identity verification process, but we are still processing their information.
  """
  Processing

  """
  The user has gone through the identity verification process, and we have determined that their identity is valid.
  The user now needs to go through the QES process to complete their identification.
  """
  ReadyToSign

  """
  The user has gone through the identity verification process, and we have determined that their identity is valid.
  """
  ValidIdentity

  """
  The user has gone through the identity verification process, but we were unable to determine if their
  identity is valid because the quality of the provided documents was insufficient.
  The user will have to start a new identification, which will update this status to `Processing`.
  """
  InsufficientDocumentQuality

  """
  The user has gone through the identity verification process, but we have determined that their identity is invalid.
  The user will have to start a new identification, which will update this status to `Processing`.
  """
  InvalidIdentity
}

"""Input to decide on digitalization"""
input InAPpDigitalizationInput {
  """The ID of a InApp Pending DigitalCard"""
  digitalCardId: String!

  """Response from swan to the provisioning request"""
  provisioningResponse: ProvisioningResponse!

  """Type of card"""
  responseChannel: ResponseChannel!
}

enum IncomingCheckRejectionReasonCodeEnum {
  CheckInvalid
}

enum IncomingInternalDirectDebitRejectReasonCodeEnum {
  AccountClosed
  InsufficientFunds
  ReasonNotSpecifiedByDebtor
}

"""Inputs for SEPA credit transfer"""
input IncomingSepaCreditTransferInput {
  """Credit transfer amount input"""
  amount: AmountInput!

  """Creditor address input"""
  creditorAddress: AddressInput

  """
  Creditor IBAN. Your Swan IBAN if you want to receive a credit transfer in your Swan account
  """
  creditorIban: IBAN!

  """Creditor name"""
  creditorName: String!

  """Debtor address input"""
  debtorAddress: AddressInput

  """Debtor IBAN. It should be a valid IBAN"""
  debtorIban: IBAN!

  """Debtor name"""
  debtorName: String!

  """
  SEPA end to end reference. This information can't be updated once it's persisted.
  """
  endToEndId: SepaReference

  """Displayed label in Swan account"""
  label: String

  """
  Indicates that the transfer is received as an instant SEPA Credit transfer
  """
  isInstant: Boolean
}

enum IncomingSepaDirectDebitRejectReasonCodeEnum {
  AccountClosed
  InsufficientFunds
  ReasonNotSpecifiedByDebtor
}

enum IncomingSepaDirectDebitReturnReasonCodeEnum {
  AccountClosed
  InsufficientFunds
  ReasonNotSpecifiedByDebtor
}

"""
Individual Ultimate Beneficial Owner
You need to describe the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company.
Please describe the company (s) that owns the company that wishes to open an account, when an individual holds in fine more than 25%
"""
type IndividualUltimateBeneficialOwner {
  """individual first name"""
  firstName: String

  """individual last name"""
  lastName: String

  """individual birth date"""
  birthDate: DateTime

  """individual birth city"""
  birthCity: String

  """individual birth city postal code"""
  birthCityPostalCode: String

  """individual birth country code"""
  birthCountryCode: CCA3

  """Information relating to the type of the UBO"""
  info: IndividualUltimateBeneficialOwnerInfo!

  """Individual beneficial owner Tax or Identification Number"""
  taxIdentificationNumber: String

  """Individual beneficial owner residency Address"""
  residencyAddress: AddressInformation
}

"""Define the type of the UBO"""
interface IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!
}

input IndividualUltimateBeneficialOwnerInput {
  """
  Individual beneficial owner first name. Length must be from 0 to 100 characters
  """
  firstName: String

  """
  Individual beneficial owner  last name. Length must be from 0 to 100 characters
  """
  lastName: String

  """Individual birth date. Must be a valid date"""
  birthDate: String

  """Individual birth city. Length must be from 0 to 100 characters"""
  birthCity: String

  """
  Individual birth city postal code. Length must be from 0 to 50 characters
  """
  birthCityPostalCode: String

  """Individual birth country code"""
  birthCountryCode: CCA3

  """Define UBO is an Indirect Owner"""
  indirect: Boolean

  """Define UBO is an Direct Owner"""
  direct: Boolean

  """
  Total of capital (in percentage, ex: 50 = 50%). Must be between 1 and 100.
  """
  totalCapitalPercentage: Float

  """Define UBO is a Legal Representative"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!

  """Individual beneficial owner Tax or Identification Number"""
  taxIdentificationNumber: String

  """Individual beneficial owner residency Address"""
  residencyAddress: AddressInformationInput
}

"""Individual Ultimate beneficial owner nature"""
enum IndividualUltimateBeneficialOwnerTypeEnum {
  """The Beneficial Owner is the representant legal"""
  LegalRepresentative

  """The Beneficial Owner have shares"""
  HasCapital

  """Other"""
  Other
}

"""Individual Ultimate Beneficial Owner Type Has Capital"""
type IndividualUltimateBeneficialOwnerTypeHasCapital implements IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!

  """Define UBO is an Indirect Owner"""
  indirect: Boolean

  """Define UBO is an Direct Owner"""
  direct: Boolean

  """Total of capital (in percentage, ex: 50 = 50%)"""
  totalCapitalPercentage: Float
}

"""Individual Ultimate Beneficial Owner Type Legal Representative"""
type IndividualUltimateBeneficialOwnerTypeLegalRepresentative implements IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!
}

"""Individual Ultimate Beneficial Owner Type Other"""
type IndividualUltimateBeneficialOwnerTypeOther implements IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!
}

type InstantFundingLimit {
  """Maximum Instant Funding Amount authorized"""
  amount: Amount!

  """Instant Funding Amount that has already been used"""
  funding: Amount
}

"""
Rejection returned when the Account Holder Instant Funding limit has been exceeded
"""
type InstantFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""Rejection returned when the Available balance is insufficient"""
type InsufficientFundsRejection implements Rejection {
  message: String!
}

"""InternalDirectDebitB2BMerchantPaymentMethod"""
type InternalDirectDebitB2BMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  productId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applicated to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

interface InternalDirectDebitMandate {
  """
  Unique identifier of the internal received direct debit mandate, generated by Swan
  """
  id: ID!
}

"""InternalDirectDebitMerchantPaymentProduct"""
type InternalDirectDebitMerchantPaymentProduct implements MerchantPaymentProduct {
  """
  Unique identifier tied to every version of a given Merchant Payment Product
  """
  id: ID!

  """The Merchant Payment Product Type"""
  type: MerchantPaymentProductType!

  """
  Unique identifier for a given merchant Payment Product, identical for every version of a given Merchant Payment Product Type
  """
  productId: ID!

  """Status of the Merchant Payment Product"""
  statusInfo: MerchantPaymentProductStatusInfo!

  """Version of the Merchant Payment Product"""
  version: Int!

  """Date at which the Merchant Payment Product was last updated"""
  updatedAt: Date!

  """Rolling Reserve applicated to the Merchant Payment Product"""
  rollingReserve: RollingReserve
}

"""InternalDirectDebitStandardMerchantPaymentMethod"""
type InternalDirectDebitStandardMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  productId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applicated to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

"""Rejection returned on unexpected server error"""
type InternalErrorRejection implements Rejection {
  message: String!
}

"""Payment direct debit mandate for Internal"""
type InternalPaymentDirectDebitMandate implements InternalDirectDebitMandate & PaymentDirectDebitMandate & PaymentMandate {
  """Unique identifier of the Internal Direct Debit Payment Mandate"""
  id: ID!

  """Unique reference of the Internal Direct Debit Payment Mandate"""
  reference: String!

  """Internal Direct Debit Payment Mandate scheme"""
  scheme: InternalPaymentMandateScheme!

  """Internal Direct Debit Payment Mandate status information"""
  statusInfo: PaymentMandateStatusInfo!

  """Internal Direct Debit Payment Mandate sequence"""
  sequence: InternalPaymentMandateSequence!

  """Internal Direct Debit Payment Mandate PDF document URL"""
  mandateDocumentUrl: String!

  """Internal Direct Debit Payment Mandate debtor information"""
  debtor: InternalPaymentMandateDebtor!

  """Internal direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """Internal Direct Debit Payment Mandate creditor information"""
  creditor: InternalPaymentMandateCreditor!

  """Signature date of the Internal Direct Debit Payment Mandate"""
  signatureDate: Date

  """Creation date of the Internal Direct Debit Payment Mandate"""
  createdAt: DateTime!

  """Last Update date of the Internal Direct Debit Payment Mandate"""
  updatedAt: DateTime!

  """
  Date of the the last transaction executed for the concerned Internal Direct Debit Payment Mandate
  """
  executedAt: DateTime

  """Expiry date of the Internal Direct Debit Payment Mandate"""
  expiredAt: Date

  """Account Holder information"""
  accountHolder: AccountHolder!

  """Language that will be used to produce the mandate PDF document"""
  language: String!
}

type InternalPaymentMandateCreditor implements PaymentMandateCreditor {
  """Internal Direct Debit Payment Mandate creditor UUID"""
  id: ID!

  """Internal Direct Debit Payment Mandate Creditor Idenfier"""
  identifier: ID!

  """Internal Direct Debit Payment Mandate creditor name"""
  name: String!

  """Internal Direct Debit Payment Mandate creditor address"""
  address: Address!
}

type InternalPaymentMandateDebtor implements PaymentMandateDebtor {
  """Internal Direct Debit Payment Mandate debtor name"""
  name: String!

  """Internal Direct Debit Payment Mandate debtor e-mail"""
  email: String!

  """Internal Direct Debit Payment Mandate debtor country"""
  country: CCA3!

  """
  Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries
  """
  address: Address

  """
  Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries
  """
  accountId: ID
}

enum InternalPaymentMandateScheme {
  """Internal Direct Debit Standard"""
  InternalDirectDebitStandard

  """Internal Direct Debit B2B"""
  InternalDirectDebitB2b
}

"""Internal Direct Debit Payment Mandate Sequence"""
enum InternalPaymentMandateSequence {
  """
  The Internal Direct Debit Payment Mandate can be used for recurrent collections
  """
  Recurring

  """The Internal Direct Debit Payment Mandate can be used only once"""
  OneOff
}

"""Received direct debit mandate for SEPA"""
type InternalReceivedDirectDebitMandate implements ReceivedDirectDebitMandate & InternalDirectDebitMandate {
  """
  Unique identifier of the received internal direct debit mandate, generated by Swan
  """
  id: ID!

  """Version of the received internal direct debit mandate"""
  version: String!

  """Creation date of the received internal direct debit mandate"""
  createdAt: DateTime!

  """Last Update date of the received internal direct debit mandate"""
  updatedAt: DateTime!

  """Received internal direct debit Unique Mandate Reference (UMR)"""
  reference: String!

  """Received internal direct debit mandate scheme"""
  scheme: InternalReceivedDirectDebitMandateScheme!

  """Received internal direct debit mandate sequence"""
  sequence: InternalReceivedDirectDebitMandateSequence!

  """Received internal direct debit creditor"""
  creditor: InternalReceivedDirectDebitMandateCreditor!

  """Received internal direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """
  Date of the last internal direct debit transaction executed for the concerned received internal direct debit mandate
  """
  executedAt: DateTime

  """Date of signature of the received internal direct debit mandate"""
  signatureDate: Date

  """
  Expiry date of the received internal direct debit mandate, computed automatically (36 months from the executedAt date)
  """
  expiredAt: Date

  """
  Mandate status information of the received internal direct debit mandate
  """
  statusInfo: ReceivedDirectDebitMandateStatusInfo!

  """Account of the received internal direct debit mandate debtor"""
  account: Account

  """Iban of the received internal direct debit mandate debtor"""
  iban: IBAN!

  """Mandate name"""
  name: String
}

"""Internal received direct debit mandate creditor"""
type InternalReceivedDirectDebitMandateCreditor {
  """Creditor identifier"""
  identifier: String!

  """Name of the creditor"""
  name: String!

  """Address of the creditor"""
  address: Address!
}

"""Received internal direct debit mandate scheme"""
enum InternalReceivedDirectDebitMandateScheme {
  """
  When the received internal direct debit mandate can only be used for internal B2B direct debit transactions
  """
  InternalDirectDebitB2b

  """
  When the received internal direct debit mandate can only be used for internal Standard direct debit transactions
  """
  InternalDirectDebitStandard
}

"""Internal received direct debit mandate sequence"""
enum InternalReceivedDirectDebitMandateSequence {
  """
  When the authorisation is given once by the Debtor to collect only one single internal direct debit
  """
  OneOff

  """
  When the authorisation by the Debtor can be used for regular internal direct debits initiated by the Creditor
  """
  Recurrent
}

"""International beneficiary account"""
input InternationalBeneficiaryInput {
  """Currency of the international beneficiary"""
  currency: Currency!
}

"""Rejection returned on invalid argument error"""
type InvalidArgumentRejection implements Rejection {
  message: String!
  code: InvalidArgumentRejectionCode!
  fields: [InvalidArgumentRejectionField!]!
}

enum InvalidArgumentRejectionCode {
  INVALID_INPUT
}

type InvalidArgumentRejectionField {
  name: String!
  errors: [String!]!
}

"""Rejection returned if phone number is not well formatted"""
type InvalidPhoneNumberRejection implements Rejection {
  message: String!
}

"""Invoice"""
type Invoice {
  """unique id"""
  id: ID!

  """account id"""
  accountId: ID!

  """name of the invoice"""
  name: String!

  """status of the invoice"""
  status: InvoiceStatus!

  """due amount"""
  amount: Amount!

  """temporary public url on which the file can be accessible"""
  url: String

  """date at which the link will not be useable anymore"""
  expiresAt: DateTime

  """starting date of the billing window"""
  openingDate: DateTime!

  """ending date of the billing window"""
  closingDate: DateTime!

  """creation date"""
  createdAt: DateTime!

  """last update date"""
  updatedAt: DateTime!
}

"""Please see the Connection interface"""
type InvoiceConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Int!
  edges: [InvoiceEdge!]!
}

"""Please see the Edge interface"""
type InvoiceEdge implements Edge {
  node: Invoice!
  cursor: String!
}

"""The different statuses of invoice"""
enum InvoiceStatus {
  Failed
  NotPaid
  Paid
  PaymentDue
  Pending
  Voided
}

"""
Rejection returned when you try to delete the last sandbox user.
At least one sandbox user should be present
"""
type LastSandboxUserCannotBeDeletedRejection implements Rejection {
  """Rejection message"""
  message: String!

  """Sandbox user ID"""
  userId: String!
}

"""Mandate amendment input"""
input MandateAmendment {
  """Previous SEPA creditor identifier"""
  previousCreditorIdentifier: SepaCreditorIdentifier

  """Previous SEPA debtor identifier"""
  previousDebtorIban: IBAN

  """Previous mandate reference"""
  previousMandateReference: SepaReference
}

"""
Filters that can be applied when listing accounts (Only applied in user context)
"""
input MembershipsFilterInput {
  """Can the user initiate payments on this account"""
  canInitiatePayments: Boolean

  """Can the user manage account membership"""
  canManageAccountMembership: Boolean

  """Can the user manage beneficiaries"""
  canManageBeneficiaries: Boolean

  """Account memberships status/statuses we're looking for"""
  status: [AccountMembershipStatus!]

  """Filtered by email"""
  email: String

  """Filtered by first name"""
  firstName: String

  """Filtered by last name"""
  lastName: String

  """Searches email, first name, last name, and id"""
  search: String
}

input Merchant {
  """Merchant city"""
  city: String = "PARIS"

  """Merchant code"""
  code: String = "0000"

  """Merchant country"""
  country: CCA3 = "FRA"

  """Merchant ID"""
  id: String = "SWAN01"

  """Merchant name"""
  name: String = "SWAN"
}

"""Base object for the different Payment Methods available"""
interface MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  productId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applicated to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

"""The different statuses a MerchantPaymentMethod can have"""
enum MerchantPaymentMethodStatus {
  PendingReview
  Enabled
  Rejected
  Disabled
  Canceled
  Suspended
}

"""The payment method status information"""
interface MerchantPaymentMethodStatusInfo {
  """Merchant Payment Method Status"""
  status: MerchantPaymentMethodStatus!
}

"""The different statuses a MerchantPaymentMethod can have"""
enum MerchantPaymentMethodType {
  InternalDirectDebitStandard
  InternalDirectDebitB2B
  Check
}

"""Base object for the different Payment Products available"""
interface MerchantPaymentProduct {
  """
  Unique identifier tied to every version of a given Merchant Payment Product
  """
  id: ID!

  """The Merchant Payment Product Type"""
  type: MerchantPaymentProductType!

  """
  Unique identifier for a given merchant Payment Product, identical for every version of a given Merchant Payment Product Type
  """
  productId: ID!

  """Status of the Merchant Payment Product"""
  statusInfo: MerchantPaymentProductStatusInfo!

  """Version of the Merchant Payment Product"""
  version: Int!

  """Date at which the Merchant Payment Product was last updated"""
  updatedAt: Date!

  """Rolling Reserve applicated to the Merchant Payment Product"""
  rollingReserve: RollingReserve
}

"""The different statuses a MerchantPaymentProduct can have"""
enum MerchantPaymentProductStatus {
  PendingReview
  Enabled
  Rejected
  Disabled
  Canceled
  Suspended
}

"""The payment product status information"""
interface MerchantPaymentProductStatusInfo {
  """Merchant Payment Product Status"""
  status: MerchantPaymentProductStatus!
}

"""The different statuses a MerchantPaymentProduct can have"""
enum MerchantPaymentProductType {
  InternalDirectDebit
  Check
}

"""Merchant Profile"""
type MerchantProfile {
  """The Merchant Profile ID"""
  id: ID!

  """The Account ID this Merchant Profile is linked to"""
  accountId: ID!

  """
  Business name of the merchant, i.e. name that will be displayed on debtors' bank statements
  """
  merchantName: String!

  """Url of the merchant's website"""
  merchantWebsite: String

  """The status of the merchant profile"""
  statusInfo: MerchantProfileStatusInfo!

  """
  Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
  """
  productType: ProductType!

  """Expected annual activity volumes for all payment method"""
  expectedMonthlyPaymentVolume: Amount!

  """Payment Products associated"""
  merchantPaymentProducts: [MerchantPaymentProduct!] @deprecated(reason: "Use merchantPaymentMethods instead")

  """Payment Methods associated"""
  merchantPaymentMethods: [MerchantPaymentMethod!]

  """expected average basket value."""
  expectedAverageBasket: Amount!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!
}

"""Merchant Profile Statuses"""
enum MerchantProfileStatus {
  """A Merchant Profile is created in the PendingReview status"""
  PendingReview

  """Enabled"""
  Enabled

  """Rejected"""
  Rejected

  """Canceled"""
  Canceled

  """Suspended"""
  Suspended
}

"""Merchant Profile Status Information"""
interface MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
}

"""
Rejection returned when the Merchant Profile is not in the expected status
"""
type MerchantProfileWrongStatusRejection implements Rejection {
  message: String!
  currentStatus: MerchantProfileStatus!
  expectedStatus: MerchantProfileStatus!
}

"""Monthly income."""
enum MonthlyIncome {
  """less than 500"""
  LessThan500

  """between 500 and 1500"""
  Between500And1500

  """between 1500 and 3000"""
  Between1500And3000

  """between 3000 and 4500"""
  Between3000And4500

  """more than 4500"""
  MoreThan4500
}

"""Monthly payment volume."""
enum MonthlyPaymentVolume {
  Between10000And50000
  Between50000And100000
  LessThan10000
  MoreThan100000
}

type Mutation {
  """Simulate the update of a Merchant Profile"""
  simulateUpdateMerchantProfile(input: SimulateUpdateMerchantProfileInput!): SimulateUpdateMerchantProfilePayload

  """Update the account holder funding limit"""
  updateAccountHolderFundingLimits(input: UpdateAccountHolderFundingLimitsInput!): UpdateAccountHolderFundingLimitsPayload @deprecated(reason: "Use mutation updateFundingLimitSettingsChangeRequest in sandbox-partner-admin instead.")

  """
  Simulate a card authorization release being received for a card authorization.
  """
  simulateOutgoingCardAuthorizationRelease(input: SimulateOutgoingCardAuthorizationReleaseInput!): SimulateOutgoingCardAuthorizationReleasePayload!

  """
  Simulate a card authorization request being received for a card issued on a Swan account.
  """
  simulateOutgoingCardAuthorization(input: SimulateOutgoingCardAuthorizationInput!): SimulateOutgoingCardAuthorizationPayload!

  """
  After a Card Credit has been booked on a Swan account, simulate the merchant reversing the transaction and the subsequent debit of funds from the Swan account.
  """
  simulateOutgoingCardCreditReverse(input: SimulateOutgoingCardCreditReverseInput!): SimulateOutgoingCardCreditReversePayload!

  """Simulate the reception of a card credit on a Swan account."""
  simulateOutgoingCardCredit(input: SimulateOutgoingCardCreditInput!): SimulateOutgoingCardCreditPayload!

  """
  After a Card Debit has been booked on a Swan account, simulate the merchant reversing the transaction and the subsequent return of funds to the Swan account.
  """
  simulateOutgoingCardDebitReverse(input: SimulateOutgoingCardDebitReverseInput!): SimulateOutgoingCardDebitReversePayload!

  """
  Simulate a card debit being received on a previously authorized card transaction.
  """
  simulateOutgoingCardDebit(input: SimulateOutgoingCardDebitInput!): SimulateOutgoingCardDebitPayload!

  """
  After an incoming Check has been scheduled, simulate the corresponding transaction being booked on the Swan creditor account.
  """
  simulateIncomingCheckBooking(input: SimulateIncomingCheckBookingInput!): SimulateIncomingCheckBookingPayload!

  """
  After an incoming Check has been sent, simulate the corresponding transaction being rejected on the Swan creditor account.
  """
  simulateIncomingCheckRejection(input: SimulateIncomingCheckRejectionInput!): SimulateIncomingCheckRejectionPayload!

  """
  After an incoming Check has been booked, simulate the corresponding transaction being returned from the Swan creditor account.
  """
  simulateIncomingCheckReturn(input: SimulateIncomingCheckReturnInput!): SimulateIncomingCheckReturnPayload!

  """
  After an incoming Internal Direct Debit has been scheduled, simulate the corresponding transaction being booked on the Swan creditor account.
  """
  simulateIncomingInternalDirectDebitBooking(input: SimulateIncomingInternalDirectDebitBookingInput!): SimulateIncomingInternalDirectDebitBookingPayload!

  """
  After an incoming Internal Direct Debit has been sent, simulate the corresponding transaction being rejected on the Swan creditor account.
  """
  simulateIncomingInternalDirectDebitReject(input: SimulateIncomingInternalDirectDebitRejectInput!): SimulateIncomingInternalDirectDebitRejectPayload!

  """
  After a SEPA Credit Transfer has credited a Swan account, simulate an authorized account member accepting a recall request, and the subsequent return of funds to the issuer.
  """
  simulateIncomingSepaCreditTransferAcceptedRecall(input: SimulateIncomingSepaCreditTransferAcceptedRecallInput!): SimulateIncomingSepaCreditTransferAcceptedRecallPayload!

  """Simulate when a SEPA Credit Transfer credits the account"""
  simulateIncomingSepaCreditTransferReception(input: IncomingSepaCreditTransferInput!): SimulateIncomingSepaCreditTransferReceptionPayload!

  """
  After a SEPA Credit Transfer has credited a Swan account, simulate an authorized account member returning funds to the issuer.
  """
  simulateIncomingSepaCreditTransferReturn(input: SimulateIncomingSepaCreditTransferReturnInput!): SimulateIncomingSepaCreditTransferReturnPayload!

  """
  After an incoming SEPA Direct Debit has been sent for execution to Sepa, simulate the corresponding transaction being booked on the Swan creditor account.
  """
  simulateIncomingSepaDirectDebitBooking(input: SimulateIncomingSepaDirectDebitBookingInput!): SimulateIncomingSepaDirectDebitBookingPayload!

  """
  After an incoming SEPA Direct Debit has been sent for execution to Sepa, simulate the corresponding transaction being rejected on the Swan creditor account.
  """
  simulateIncomingSepaDirectDebitReject(input: SimulateIncomingSepaDirectDebitRejectInput!): SimulateIncomingSepaDirectDebitRejectPayload!

  """
  After an incoming SEPA Direct Debit has been booked, simulate the corresponding transaction being returned from the Swan creditor account.
  """
  simulateIncomingSepaDirectDebitReturn(input: SimulateIncomingSepaDirectDebitReturnInput!): SimulateIncomingSepaDirectDebitReturnPayload!

  """
  Simulate the return of funds to a Swan account, following a recall request by an authorized account member of that account and the acceptance by the beneficiary.
  """
  simulateOutgoingSepaCreditTransferAcceptedRecall(input: SimulateOutgoingSepaCreditTransferAcceptedRecallInput!): SimulateOutgoingSepaCreditTransferAcceptedRecallPayload!

  """
  After an outgoing SEPA Credit Transfer has been sent for execution to Swan, simulate the corresponding transaction being booked on the Swan debtor account.
  """
  simulateOutgoingSepaCreditTransferBooking(input: SimulateOutgoingSepaCreditTransferBookingInput!): SimulateOutgoingSepaCreditTransferBookingPayload!

  """
  Simulate Swan rejecting an outgoing SEPA Credit Transfer request, for compliance reasons.
  """
  simulateOutgoingSepaCreditTransferRejection(input: SimulateOutgoingSepaCreditTransferRejectionInput!): SimulateOutgoingSepaCreditTransferRejectionPayload!

  """
  Simulate a beneficiary bank returning funds to a Swan account after a SEPA Credit Transfer debited the account.
  """
  simulateOutgoingSepaCreditTransferReturn(input: SimulateOutgoingSepaCreditTransferReturnInput!): SimulateOutgoingSepaCreditTransferReturnPayload!

  """
  Simulate a creditor cancelling an incoming SEPA Direct Debit instruction sent to debit a Swan account, before the execution/debit date.
  """
  simulateOutgoingSepaDirectDebitCancel(input: SimulateOutgoingSepaDirectDebitCancelInput!): SimulateOutgoingSepaDirectDebitCancelPayload!

  """
  Simulate a Swan account receiving a SEPA Direct Debit instruction and being debited.
  """
  simulateOutgoingSepaDirectDebitReception(input: SimulateOutgoingSepaDirectDebitReceptionInput!): SimulateOutgoingSepaDirectDebitReceptionPayload!

  """
  Simulate a Swan debtor rejecting a SEPA Direct Debit instruction theyve already received, before the execution/debit date
  """
  simulateOutgoingSepaDirectDebitReject(input: SimulateOutgoingSepaDirectDebitRejectInput!): SimulateOutgoingSepaDirectDebitRejectPayload!

  """
  After a SEPA Direct Debit instruction has been received and the transaction was booked on a Swan debtor account, simulate a refund request by an authorized account member and the subsequent return of funds to their account.
  """
  simulateOutgoingSepaDirectDebitReturn(input: SimulateOutgoingSepaDirectDebitReturnInput!): SimulateOutgoingSepaDirectDebitReturnPayload!

  """
  After a SEPA Direct Debit instruction has been received and the transaction was booked on a Swan debtor account, simulate the creditor reversing the transaction and the subsequent return of funds to the Swan account
  """
  simulateOutgoingSepaDirectDebitReverse(input: SimulateOutgoingSepaDirectDebitReverseInput!): SimulateOutgoingSepaDirectDebitReversePayload!

  """Release reserved balance associate to a transaction id."""
  simulateReleaseReservedBalance(input: SimulateReleaseReservedBalanceInput!): SimulateReleaseReservedBalancePayload!

  """Simulate Swan processing on Account Verification"""
  updateAccountVerificationStatus(input: UpdateAccountVerificationStatusInput!): UpdateAccountVerificationStatusPayload!

  """
  Create a sandbox user
  This mutation is restricted to a User access token
  """
  createSandboxUser(input: CreateSandboxUserInput!): CreateSandboxUserPayload!

  """
  Delete a sandbox user
  This mutation is restricted to a User access token
  """
  deleteSandboxUser(input: DeleteSandboxUserInput!): DeleteSandboxUserPayload!

  """
  Log sandbox user
  This mutation is restricted to a User access token
  """
  endorseSandboxUser(input: EndorseSandboxUserInput!): EndorseSandboxUserPayload!

  """
  Updates a sandbox user
  This mutation is restricted to a User access token
  """
  updateSandboxUser(input: UpdateSandboxUserInput!): UpdateSandboxUserPayload!
  simulateInvoiceGeneration(input: SimulateInvoiceGenerationInput!): SimulateInvoiceGenerationPayload

  """Mutation to simulate a manual provisioning"""
  simulateManualProvisioning(input: DigitalizationInput!): SimulationResponse!

  """
  Mutation to give decision on digitalization.
  If more than one InApp digitalization process are ongoing, only the latest one will be acted upon
  """
  simulateInAppProvisioningCompletion(input: InAPpDigitalizationInput!): SimulationResponse!

  """
  Mutation to simulate the reception of a physical card.
  Requires a physical card in a valid state for reception.
  """
  physicalCardReception(input: PhysicalCardReceptionInput!): PhysicalCardReceptionPayload!

  """
  Mutation to promote an account holder to the role of project owner.
  Requires the account holder identifier to be promoted to Project Owner.
  Beware, if another account holder had this role, they will lose it.
  """
  promoteAccountHolderToProjectOwner(input: PromoteAccountHolderToProjectOwnerInput!): PromoteAccountHolderToProjectOwnerPayload!

  """
  Mutation to simulate delivery of a physical card.
  Requires a physical card in a valid state for delivery.
  """
  simulatePhysicalCardDelivery(input: SimulatePhysicalCardDeliveryInput!): SimulationResponse!
  updateSupportingDocumentCollectionStatus(input: UpdateSupportingDocumentCollectionStatusInput!): UpdateSupportingDocumentCollectionStatusPayload!
  updateAccountHolder(input: UpdateAccountHolderInput!): UpdateAccountHolderPayload!
  updateFundingLimitSettingsChangeRequest(input: UpdateFundingLimitSettingsChangeRequestInput!): UpdateFundingLimitSettingsChangeRequestPayload!
}

"""Rejection returned on unknown nationality"""
type NationalityNotFoundRejection implements Rejection {
  message: String!
  identifier: CCA3!
}

"""
Rejection returned if the entity was not found or if the user does not have the rights to know that the account exists
"""
type NotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Rejection returned when consent status couldn't change"""
type NotReachableConsentStatusRejection implements Rejection {
  message: String!
  currentStatus: ConsentStatus
  unreachableStatus: ConsentStatus
}

type OAuth2Consent implements DetailedConsent {
  id: ID!
  projectId: String
  requireSCA: Boolean!
  status: ConsentStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  startedAt: DateTime
  expiredAt: DateTime
  consentResponses: [ConsentResponse!]!
  purpose: DetailedConsentPurpose!
  consentOperations: [ConsentOperation!]!
  env: EnvType!
  identityId: String!
  state: String
  branding: Branding!
  operationsSHA256HexDigest: String
  consentChallenge: String
  loginChallenge: String
  scopes: String
  challenge: String
}

"""Extra parameters provided by partner"""
type OAuthRedirectParameters {
  """
  Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity.
  """
  state: String

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  """
  redirectUrl: String
}

"""
Information provided during the onboarding process of an individual or a company
"""
type Onboarding {
  """Unique identifier of an onboarding"""
  id: String!

  """Account name"""
  accountName: String

  """Account Country"""
  accountCountry: AccountCountry

  """Creation date"""
  createdAt: DateTime!

  """Email"""
  email: String

  """Finalization date"""
  finalizedAt: DateTime

  """
  Language of the onboarding process. This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)
  """
  language: String

  """Information regarding the Individual or the company to onboard"""
  info: OnboardingAccountHolderInfo!

  """Account holder created at the end of the onboarding process"""
  accountHolder: AccountHolder

  """
  Redirect the legal representative of a new account holder to this URL to start the onboarding process
  """
  onboardingUrl: String!

  """Current computed state of onboarding"""
  onboardingState: OnboardingState!

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  """
  redirectUrl: String! @deprecated(reason: "Use `redirectUrl` field on oauthRedirectParameters parameters instead.")

  """Extra parameters provided by partner"""
  oAuthRedirectParameters: OAuthRedirectParameters

  """Status (valid/invalid/finalized) and details of errors on fields"""
  statusInfo: OnboardingStatusInfo!

  """Swan TCU URL"""
  tcuUrl: String!

  """List of supporting document collection owned by the account holder."""
  supportingDocumentCollection: SupportingDocumentCollection!

  """Creation date"""
  updatedAt: DateTime!

  """Account opened after the onboarding finalization"""
  account: Account

  """List of accepted identification level for the legal representative"""
  legalRepresentativeAcceptedIdentificationLevels: [IdentificationLevel]!

  """Recommended identification level for the legal representative"""
  legalRepresentativeRecommendedIdentificationLevel: IdentificationLevel!
}

"""The onboarding could be for an Individual or a company"""
interface OnboardingAccountHolderInfo {
  """Account holder type"""
  type: AccountHolderType!
}

"""Company Account Holder Information"""
type OnboardingCompanyAccountHolderInfo implements OnboardingAccountHolderInfo {
  """
  Account holder type (always Company for type OnboardingCompanyAccountHolderInfo)
  """
  type: AccountHolderType!

  """name of the company"""
  name: String

  """registration number of the company (SIRET, ...)"""
  registrationNumber: String

  """legal form of the company (SAS, SCI, SASU, ...)"""
  companyType: CompanyType

  """business activity"""
  businessActivity: BusinessActivity

  """
  business activity description
  This must be 1024 characters long maximum.
  """
  businessActivityDescription: String

  """estimated monthly payment volume (euro)"""
  monthlyPaymentVolume: MonthlyPaymentVolume

  """
  The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
  
  The ultimate beneficiary is :
  - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
  - either the natural person (s) who exercise, by other means, a power of control of the company;
  """
  individualUltimateBeneficialOwners: [IndividualUltimateBeneficialOwner!]

  """residency address of the head office (Must be in a European country)"""
  residencyAddress: AddressInfo

  """Is company registered at RCS in its country"""
  isRegistered: Boolean

  """
  Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT
  """
  vatNumber: String

  """Tax Identification Number"""
  taxIdentificationNumber: String

  """Legal representative personal address"""
  legalRepresentativePersonalAddress: AddressInformation

  """Type of representation (legal representative or power of attorney)"""
  typeOfRepresentation: TypeOfRepresentation
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type OnboardingConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """OnboardingEdge list"""
  edges: [OnboardingEdge!]!
}

"""Implements the Relay Edge interface"""
type OnboardingEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The Onboarding"""
  node: Onboarding!
}

"""Filters that can be applied when listing onboardings"""
input OnboardingFiltersInput {
  """Type/Types we want to filter on"""
  types: [AccountHolderType!]

  """Email we want to filter on"""
  email: String

  """Searches company name, first name, last name"""
  search: String

  """Status we want to filter on"""
  status: [OnboardingStatus!]
}

"""StatusInfo when onboarding has been finalized"""
type OnboardingFinalizedStatusInfo implements OnboardingStatusInfo {
  status: OnboardingStatus!
}

"""Individual Account Holder Information"""
type OnboardingIndividualAccountHolderInfo implements OnboardingAccountHolderInfo {
  """
  Account holder type (always Individual for type OnboardingIndividualAccountHolderInfo)
  """
  type: AccountHolderType!

  """employment status of the individual account holder"""
  employmentStatus: EmploymentStatus

  """monthly income of the individual account holder"""
  monthlyIncome: MonthlyIncome

  """
  residency address of the individual account holder (must be in a European country)
  """
  residencyAddress: AddressInfo

  """Tax Identification Number"""
  taxIdentificationNumber: String
}

type OnboardingInfo {
  """unique identifier of an onboarding"""
  id: String!

  """Account name"""
  accountName: String

  """
  Country of the account that will be created at the end of the onboarding process
  """
  accountCountry: AccountCountry

  """email"""
  email: String

  """
  language of the onboarding process. This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)
  """
  language: String

  """Information regarding the Individual or the company to onboard"""
  info: OnboardingAccountHolderInfo!

  """
  Redirect the legal representative of a new account holder to this URL to start the onboarding process
  """
  onboardingUrl: String!

  """Current computed state of onboarding"""
  onboardingState: OnboardingState

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  """
  redirectUrl: String!

  """Project infos you set in the dashboard"""
  projectInfo: ProjectInfo

  """Verification Flow"""
  verificationFlow: VerificationFlow!

  """Extra parameters provided by partner"""
  oAuthRedirectParameters: OAuthRedirectParameters

  """Status (valid/invalid/finalized) and details of errors on fields"""
  statusInfo: OnboardingStatusInfo!

  """Supporting document collection related to onboarding."""
  supportingDocumentCollection: SupportingDocumentCollection!

  """List of accepted identification level for the legal representative"""
  legalRepresentativeAcceptedIdentificationLevels: [IdentificationLevel]!

  """Recommended identification level for the legal representative"""
  legalRepresentativeRecommendedIdentificationLevel: IdentificationLevel!

  """Swan TCU URL"""
  tcuUrl: String!
}

"""StatusInfo when onboarding has still at least one incorrect field"""
type OnboardingInvalidStatusInfo implements OnboardingStatusInfo {
  status: OnboardingStatus!
  errors: [ValidationError!]!
}

"""
Field we can use when ordering that can be applied when listing onboardings
"""
enum OnboardingOrderByFieldInput {
  createdAt
  updatedAt
  finalizedAt
}

"""Order that can be applied when listing onboardings"""
input OnboardingOrderByInput {
  field: OnboardingOrderByFieldInput
  direction: OrderByDirection
}

"""Onboarding process state"""
enum OnboardingState {
  """When the onboarding is in progress"""
  Ongoing

  """When the onboarding is finalized and the account holder is created"""
  Completed
}

"""Possible values for onboarding status"""
enum OnboardingStatus {
  """When the onboarding is finalized"""
  Finalized

  """when the onboarding is invalid. Final status"""
  Invalid

  """When the onboarding is valid. Final status"""
  Valid
}

"""
Object containing details about onboarding status (valid/invalid and why it is invalid/already finalized)
"""
interface OnboardingStatusInfo {
  """
  Current onboarding status. Onboarding can only be finalized if status is "valid"
  """
  status: OnboardingStatus!
}

"""
StatusInfo when onboarding has all onboarding fields are correctly filled
"""
type OnboardingValidStatusInfo implements OnboardingStatusInfo {
  status: OnboardingStatus!
}

enum OrderByDirection {
  Asc
  Desc
}

"""
Implements PageInfo from the Relay Connections Specification - information about a page in the pagination mechanism
"""
type PageInfo {
  """Indicates whether more edges exist following this page"""
  hasNextPage: Boolean

  """Indicates whether more edges exist preceding this page"""
  hasPreviousPage: Boolean

  """Opaque identifier pointing to the first node of the page"""
  startCursor: String

  """Opaque identifier pointing to the last node of the page"""
  endCursor: String
}

"""Partnership Status Accepted"""
type PartnershipAcceptedStatusInfo implements PartnershipStatusInfo {
  """
  Partnership status (always Accepted for type PartnershipAcceptedStatusInfo)
  """
  status: PartnershipStatus!

  """Accepted date of the partnership for this account"""
  acceptedDate: DateTime!
}

"""Partnership Status canceled"""
type PartnershipCanceledStatusInfo implements PartnershipStatusInfo {
  """
  Partnership status (always Canceled for type PartnershipCanceledStatusInfo)
  """
  status: PartnershipStatus!

  """Accepted date of the partnership for this account"""
  acceptedDate: DateTime!

  """Canceled date of the partnership for this account"""
  canceledDate: DateTime!

  """Reason of the cancelation"""
  reason: String!
}

"""Partnership Status currently cancelling"""
type PartnershipCancelingStatusInfo implements PartnershipStatusInfo {
  """
  Partnership status (always Canceling for type PartnershipCancelingStatusInfo)
  """
  status: PartnershipStatus!

  """Accepted date of the partnership for this account"""
  acceptedDate: DateTime!

  """Canceled date of the partnership for this account"""
  canceledAfter: DateTime!
}

enum PartnershipStatus {
  """
  When the partnership is accepted by the account holder for this account
  """
  Accepted

  """When you decide to stop the partnership, you have 2 months notice"""
  Canceling

  """When the partnership was canceled by you or the account holder"""
  Canceled
}

"""Partnership Status information"""
interface PartnershipStatusInfo {
  """Status of the partnership for this account"""
  status: PartnershipStatus!
}

enum PaymentAccountType {
  """When the account holder if the account hasn't met KYC requirements"""
  EMoney

  """When all KYC requirements are met"""
  PaymentService
}

interface PaymentDirectDebitMandate {
  """Unique identifier of the Direct Debit Payment Mandate"""
  id: ID!
}

"""Payment Level of the account"""
enum PaymentLevel {
  """When the account is limited to 150 within 30 days and with no IBAN"""
  Limited

  """
  When the account holder is fully verified and then the account is unlimited with an IBAN
  """
  Unlimited
}

interface PaymentMandate {
  """Unique identifier of the Payment Mandate"""
  id: ID!
}

enum PaymentMandateCanceledReason {
  """When the user requested to cancel the Payment Mandate"""
  RequestedByUser

  """When the Payment Mandate is expired"""
  MandateExpired
}

"""Payment Mandate Canceled status information"""
type PaymentMandateCanceledStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Canceled for type PaymentMandateCanceledStatusInfo).
  """
  status: PaymentMandateStatus!

  """Reason behind the Payment Mandate Canceled status"""
  reason: PaymentMandateCanceledReason!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type PaymentMandateConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """PaymentMandateEdge list"""
  edges: [PaymentMandateEdge!]!
}

"""Payment Mandate Consent Pending status information"""
type PaymentMandateConsentPendingStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Enabled for type PaymentMandateEnableedStatusInfo).
  """
  status: PaymentMandateStatus!

  """Consent information required to enable the concerned Payment Mandate"""
  consent: Consent!
}

interface PaymentMandateCreditor {
  """Creditor UUID"""
  id: ID!

  """Creditor name"""
  name: String!

  """Creditor address"""
  address: Address!
}

interface PaymentMandateDebtor {
  """Debtor name"""
  name: String!

  """Debtor e-mail"""
  email: String!

  """Debtor country"""
  country: CCA3!
}

"""Implements the Relay Edge interface"""
type PaymentMandateEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The payment mandate"""
  node: PaymentMandate!
}

"""Payment Mandate Enabled status information"""
type PaymentMandateEnabledStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Enabled for type PaymentMandateEnabledStatusInfo).
  """
  status: PaymentMandateStatus!
}

"""
Filter that can be passed to get the payment mandate in a specific data range
"""
input PaymentMandateFiltersInput {
  """To filter on status values"""
  status: [PaymentMandateStatus!]

  """To filter on scheme values"""
  scheme: [PaymentMandateScheme!]
}

"""
Field we can use when ordering that can be applied when listing payment mandate results
"""
enum PaymentMandateOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing payment mandate results"""
input PaymentMandateOrderByInput {
  field: PaymentMandateOrderByFieldInput
  direction: OrderByDirection
}

"""
Rejection returned when a payment mandate reference is already for a creditor
"""
type PaymentMandateReferenceAlreadyUsedRejection implements Rejection {
  message: String!
}

"""Payment Mandate Rejected status information"""
type PaymentMandateRejectedStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Rejected for type PaymentMandateSuspendedStatusInfo).
  """
  status: PaymentMandateStatus!
}

enum PaymentMandateScheme {
  """SEPA Direct Debit Core"""
  SepaDirectDebitCore

  """SEPA Direct Debit B2B"""
  SepaDirectDebitB2b

  """Internal Direct Debit Standard"""
  InternalDirectDebitStandard

  """Internal Direct Debit B2B"""
  InternalDirectDebitB2b
}

"""Payment Mandate Sequence"""
enum PaymentMandateSequence {
  """The Payment Mandate can be used for recurrent collections"""
  Recurrent

  """The Payment Mandate can be used only once"""
  OneOff
}

"""Payment Mandate status"""
enum PaymentMandateStatus {
  ConsentPending
  Enabled
  Rejected
  Canceled
}

"""Payment Mandate status information"""
interface PaymentMandateStatusInfo {
  """Status of the payment mandate."""
  status: PaymentMandateStatus!
}

"""PendingMerchantPaymentMethodStatusInfo"""
type PendingMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!
}

"""PendingMerchantPaymentProductStatusInfo"""
type PendingMerchantPaymentProductStatusInfo implements MerchantPaymentProductStatusInfo {
  status: MerchantPaymentProductStatus!
}

"""PendingReviewMerchantProfileStatusInfo"""
type PendingReviewMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
}

"""Pending Verification Information"""
type PendingReviewStatusInfo implements AccountVerificationStatusInfo {
  """Account verification status (PendingReview)"""
  status: AccountVerificationStatus!
}

"""Pending Verification Information"""
type PendingVerificationStatusInfo implements AccountVerificationStatusInfo {
  """Account verification status (PendingVerification)"""
  status: AccountVerificationStatus!
}

"""
E.164 standard format phone number

Examples
+551155256325
+44207183875
"""
scalar PhoneNumber

"""Input to simulate reception of a physical card"""
input PhysicalCardReceptionInput {
  """Unique identifier of a card"""
  cardId: ID!
}

union PhysicalCardReceptionPayload = PhysicalCardReceptionSuccessPayload | SimulationRejection | ValidationRejection

type PhysicalCardReceptionSuccessPayload {
  physicalCardIdentifier: String!
}

"""6 digits numeric passcode"""
scalar PIN

enum PreferredNotificationChannel {
  """Use Swan SMS"""
  Sms

  """Use In-App notification"""
  App
}

"""
Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
"""
enum ProductType {
  Goods
  Services
  VirtualGoods
  GiftsAndDonations
}

type ProjectForbiddenRejection implements Rejection {
  message: String!
}

"""Rejection returned when the Project Funding has been exceeded"""
type ProjectFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""Public information of a `Project`"""
type ProjectInfo {
  """Unique identifier of the project"""
  id: ID!

  """
  Your project name displayed in white label interfaces and in the terms and conditions
  """
  name: String!

  """The type of your project"""
  type: ProjectType!

  """URL of your logo"""
  logoUri: String

  """
  Your accent color, used in white label interfaces. Most of the time for call to actions
  """
  accentColor: String

  """Your custom subdomain used in consents"""
  customConsentSubdomain: String

  """Your OAuth client id"""
  oAuthClientId: String

  """
  URL to your Terms and Conditions of Use document depending on the provided language
  """
  tcuDocumentUri(
    """
    this consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)
    """
    language: String!
  ): String! @deprecated(reason: "use tcuDocumentUrl from the onboarding query")

  """Unique id of your current Terms and Conditions of Use"""
  tcuDocumentId: String! @deprecated(reason: "use tcuDocumentUrl from the onboarding query")

  """Web banking settings"""
  webBankingSettings: WebBankingSettings

  """Project status"""
  status: ProjectStatus!
  B2BMembershipIDVerification: Boolean
}

"""
Rejection returned when the Project Instant Funding limit has been exceeded
"""
type ProjectInstantFundingLimitExceededRejection implements Rejection {
  message: String!
}

type ProjectInvalidStatusRejection implements Rejection {
  message: String!
}

type ProjectNotFound implements Rejection {
  message: String!
}

type ProjectSettingsForbiddenError implements Rejection {
  message: String!
}

type ProjectSettingsNotFound implements Rejection {
  message: String!
}

type ProjectSettingsStatusNotReachable implements Rejection {
  message: String!
}

enum ProjectStatus {
  Initiated
  MeetingScheduled
  ToReview @deprecated(reason: "replaced by `PendingCompliance`")
  PendingCompliance
  LimitedLiveAccess
  BetaLiveAccess
  Enabled @deprecated(reason: "replaced by `LimitedLiveAccess`")
  FullLiveAccess
  Disabled
  Suspended
  Rejected
  PendingLiveReview
}

enum ProjectType {
  INDIVIDUAL @deprecated(reason: "replaced by `Individual`")
  COMPANY @deprecated(reason: "replaced by `Company`")
  COMPANY_AND_CUSTOMERS @deprecated(reason: "replaced by `CompanyAndCustomers`")
  Individual
  Company
  CompanyAndCustomers
}

input PromoteAccountHolderToProjectOwnerInput {
  """Unique identifier of account holder"""
  accountHolderId: ID!
}

union PromoteAccountHolderToProjectOwnerPayload = PromoteAccountHolderToProjectOwnerSuccessPayload | ForbiddenRejection | AccountHolderNotFoundRejection

type PromoteAccountHolderToProjectOwnerSuccessPayload {
  accountHolder: AccountHolder!
}

"""The different response that Swan can give to a provisioning request"""
enum ProvisioningResponse {
  """
  No OTP will be sent before validation
  Can happen in Live if the cardHolder is trusted by the wallet provider (Adding a card to the watch after adding it to the iPhone)
  """
  NoOTP

  """An OTP will be sent to the cardHolder"""
  OTP

  """Provisioning request will be declined"""
  Decline
}

type PurposeWithOperations {
  purpose: ConsentPurpose!
  operations: [ConsentOperation!]!
}

type Query {
  """
  Returns sandbox user data of provided user ID
  This query is restricted to a User access token
  """
  sandboxUserById(id: ID!): SandboxUser

  """
  Returns sandbox user data of active user.
  Active user is the user who runs the query with their token.
  This query is restricted to a User access token
  """
  sandboxUser: SandboxUser!

  """
  Returns a list of sandbox users data
  This query is restricted to a User access token
  """
  sandboxUsers(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to start at a specific offset"""
    offset: Int

    """When the list of elements needs to be ordered"""
    orderBy: SandboxUsersOrderByInput
  ): SandboxUserConnection
}

"""Define a reason with a message"""
interface Reason {
  message: String
}

"""Input version"""
input ReasonInput {
  message: String
}

"""Interface for Received Direct Debit Mandate"""
interface ReceivedDirectDebitMandate {
  """
  Unique identifier of the received direct debit mandate, generated by Swan
  """
  id: ID!

  """Version of the received direct debit mandate"""
  version: String!

  """Creation date of the received direct debit mandate"""
  createdAt: DateTime!

  """Last Update date of the received direct debit mandate"""
  updatedAt: DateTime!

  """Date of signature of the received direct debit mandate"""
  signatureDate: Date

  """
  Date of the last direct debit transaction executed for the concerned received direct debit mandate
  """
  executedAt: DateTime

  """Expiry date of the received direct debit mandate"""
  expiredAt: Date

  """Mandate status information of the received direct debit mandate"""
  statusInfo: ReceivedDirectDebitMandateStatusInfo!

  """Mandate name"""
  name: String
}

"""Rejection returned if the received direct debit mandate already exist"""
type ReceivedDirectDebitMandateAlreadyExistRejection implements Rejection {
  id: String!
  message: String!
}

"""
Received direct debit mandate is canceled and therefore can't be enabled/suspended or updated
"""
type ReceivedDirectDebitMandateCanceledRejection implements Rejection {
  id: String!
  message: String!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type ReceivedDirectDebitMandateConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ReceivedDirectDebitMandateEdge list"""
  edges: [ReceivedDirectDebitMandateEdge!]!
}

"""Implements the Relay Edge interface"""
type ReceivedDirectDebitMandateEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The received direct debit mandate"""
  node: ReceivedDirectDebitMandate!
}

"""
Rejection returned if the received direct debit mandate is not a B2b mandate
"""
type ReceivedDirectDebitMandateNotB2bRejection implements Rejection {
  id: String!
  message: String!
}

"""
Error returned if the received direct debit mandate was not found or if the user does not have the rights to receive information abo
ut the existence of the received direct debit mandate
"""
type ReceivedDirectDebitMandateNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Received Direct Debit Mandate Scheme"""
enum ReceivedDirectDebitMandateScheme {
  """
  When the received direct debit mandate can only be used for SEPA B2B direct debit transactions
  """
  SepaDirectDebitB2b

  """
  When the received direct debit mandate can only be used for SEPA Core direct debit transactions
  """
  SepaDirectDebitCore
}

"""Received Direct Debit Mandate Statuses"""
enum ReceivedDirectDebitMandateStatus {
  """When the received direct debit mandate is enabled"""
  Enabled

  """When the received direct debit mandate is suspended"""
  Suspended

  """When the received direct debit mandate is canceled"""
  Canceled

  """
  When the received direct debit mandate requires the initiation of a consent process
  """
  ConsentInitiationPending

  """When the received direct debit mandate is pending consent completion"""
  ConsentPending
}

"""Received Direct Debit Mandate status information"""
interface ReceivedDirectDebitMandateStatusInfo {
  """Received Direct Debit Mandate status"""
  status: ReceivedDirectDebitMandateStatus!
}

"""Received Direct Debit Mandate Canceled status information"""
type ReceivedDirectDebitMandateStatusInfoCanceled implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always Canceled for type ReceivedDirectDebitMandateStatusInfoCanceled)
  """
  status: ReceivedDirectDebitMandateStatus!

  """Date of cancellation"""
  canceledAt: DateTime!
}

"""
Received Direct Debit Mandate ConsentInitiationPending status information
"""
type ReceivedDirectDebitMandateStatusInfoConsentInitiationPending implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentInitiationPending)
  """
  status: ReceivedDirectDebitMandateStatus!
}

"""Received Direct Debit Mandate ConsentPending status information"""
type ReceivedDirectDebitMandateStatusInfoConsentPending implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentPending)
  """
  status: ReceivedDirectDebitMandateStatus!

  """The consent required to consent to a received direct debit mandate"""
  consent: Consent!
}

"""Received Direct Debit Mandate Enabled status information"""
type ReceivedDirectDebitMandateStatusInfoEnabled implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always Enabled for type ReceivedDirectDebitMandateStatusInfoEnabled)
  """
  status: ReceivedDirectDebitMandateStatus!

  """
  Date at which the received direct debit mandate has been moved to the enabled status
  """
  enabledAt: DateTime!
}

"""Received Direct Debit Mandate Suspended status information"""
type ReceivedDirectDebitMandateStatusInfoSuspended implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always Suspended for type ReceivedDirectDebitMandateStatusInfoSuspended)
  """
  status: ReceivedDirectDebitMandateStatus!

  """
  Date of the last time the received direct debit mandate has been moved to the suspended status
  """
  suspendedAt: DateTime!
}

"""RejectedMerchantPaymentMethodStatusInfo"""
type RejectedMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method rejected date"""
  rejectedAt: Date!
}

"""RejectedMerchantPaymentProductStatusInfo"""
type RejectedMerchantPaymentProductStatusInfo implements MerchantPaymentProductStatusInfo {
  status: MerchantPaymentProductStatus!

  """Merchant Payment Product rejected date"""
  rejectedAt: Date!
}

"""RejectedMerchantProfileStatusInfo"""
type RejectedMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  rejectedAt: Date!
}

"""Rejected Verification Reason"""
enum RejectedVerificationReason {
  HolderDidNotMatch
}

"""Rejected Information"""
type RejectedVerificationStatusInfo implements AccountVerificationStatusInfo {
  """Rejected Reason"""
  reason: RejectedVerificationReason!

  """Date at which the verification was rejected"""
  rejectedAt: DateTime!

  """Account verification status (Rejected)"""
  status: AccountVerificationStatus!
}

interface Rejection {
  message: String!
}

"""Success payload type"""
type ReleaseReservedBalanceSuccessPayload {
  transactionId: ID!
}

"""
The channels that can be used to send the OTP and the end of provisioning message
"""
enum ResponseChannel {
  SMS
}

"""Account membership restricted to"""
type RestrictedTo {
  """first name"""
  firstName: String!

  """last name"""
  lastName: String!

  """birth date"""
  birthDate: Date

  """phone number"""
  phoneNumber: String!
}

"""
Percentage over a number of business days, that is applied to all funds collected to compute a Reserved amount
This amount cannot be used over the corresponding business days
"""
type RollingReserve {
  """Percentage of the funding amount to be reserved"""
  percentage: Int!

  """Number of business days the computed amount is reserved"""
  rollingDays: Int!
}

"""
To make your integration with Swan as seamless as possible, we allow you to create as many Sandbox users as you want from Swan.
Sandbox users make it possible to simulate the different processes you may encounter with your real users, once you go live.
You can simulate different onboarding scenarios and processes, or practice managing the user rights of your accounts.

Read more about sandbox users [on the documentation](https://docs.swan.io/concept/user#sandbox-users)
"""
type SandboxUser {
  """Sandbox user ID"""
  id: ID!

  """
  Mobile phone number with the international format
  Example: +33689788967
  """
  mobilePhoneNumber: PhoneNumber

  """Last name"""
  lastName: String

  """First name"""
  firstName: String

  """List of first names"""
  allFirstNames: [String!]

  """Birth Date"""
  birthDate: Date

  """
  [Alpha-3 birth country representation](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  """
  birthCountryCCA3: CCA3

  """
  [Alpha-3 nationality representation](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  Ex: FRA for french nationality
  """
  nationalityCCA3: CCA3

  """
  `true` if identificationStatus is ValidIdentity.
  `false` otherwise.
  """
  idVerified: Boolean

  """
  Saves you considerable time during the development phase,
  by automatically allowing consent,
  removing the need to repeatedly get consent.
  """
  autoConsent: Boolean!

  """
  Preferred notification channel
  
  When it is "null" it means that the preferences have not been updated. Default SMS in use
  """
  preferredNotificationChannel: PreferredNotificationChannel

  """Verification status is now is now an Account-Holder's attribute"""
  verificationStatus: VerificationStatus @deprecated(reason: "Verification status is now is now an Account-Holder's attribute. Updating this status should be done on the account holder level instead of sandbox users.")

  """
  List of identification levels available for the user.
  
  Whenever TRUE, it means the identification was successful for the associated level.
  """
  identificationLevels: IdentificationLevels

  """Let you simulate every use case of our identity verification process."""
  identificationStatus: IdentificationStatus!

  """Indicates if sandbox user is logged or not"""
  isActive: Boolean
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)).
"""
type SandboxUserConnection implements Connection {
  """Total number of element in the list."""
  totalCount: Int!

  """Information about the current, the previous and the next page."""
  pageInfo: PageInfo!

  """SandboxUserEdge list."""
  edges: [SandboxUserEdge!]!
}

"""Implements the Relay Edge interface."""
type SandboxUserEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism."""
  cursor: String!

  """The sandbox user."""
  node: SandboxUser!
}

"""Rejection returned when sandbox user doesn't exist"""
type SandboxUserNotFoundRejection implements Rejection {
  """Rejection message"""
  message: String!

  """Sandbox user ID"""
  userId: String!
}

"""
Field we can use when ordering that can be applied when listing sandbox users results
"""
enum SandboxUsersOrderByFieldInput {
  createdAt
  updatedAt
}

input SandboxUsersOrderByInput {
  field: SandboxUsersOrderByFieldInput
  direction: OrderByDirection
}

"""Rejection returned when adding a B2B mandate with an Individual debtor"""
type SchemeWrongRejection implements Rejection {
  message: String!
}

"""Sepa beneficiary account"""
input SepaBeneficiaryInput {
  """International Bank Account Number"""
  iban: IBAN!

  """
  Full name of the beneficiary (min 2 characters, max 70 characters). The name should not include any special characters.
  """
  name: String!

  """beneficiary address"""
  address: AddressInput

  """
  `true` if this new beneficiary is the account holder himself in another financial institution.
  """
  isMyOwnIban: Boolean!

  """
  `true` if this new beneficiary will be saved to the beneficiary list of the debited account.
  """
  save: Boolean!
}

"""
SEPA Creditor Identifier
format :
    1  2: ISO Country Code
    3  4: Check Digit
    5  7: Creditor Business Code  you (Creditor) choose this. The default is ZZZ
    8 - 35: Creditor National Identifier  a consecutive number that will be assigned by country
example:
    FR11ABC123456
"""
scalar SepaCreditorIdentifier

"""List of recalled reasons"""
enum SepaCreditTransferRecalledReasonCodeEnum {
  BeneficiaryAccountIncorrect
  NotSpecifiedByOriginator
  TransactionAmountIncorrect
}

"""List of Recall reasons"""
enum SepaCreditTransferRecallReasonCodeEnum {
  BeneficiaryAccountIncorrect
  NotSpecifiedByOriginator
  TechnicalIssueOccurred
  TransactionAmountIncorrect
  TransactionDuplicated
  TransactionFraudulent
}

"""List of rejection reasons"""
enum SepaCreditTransferRejectionReasonCodeEnum {
  BeneficiaryBankBicInvalid
  BeneficiaryBankBicNotFound
  BeneficiaryBankNotReachable
}

"""List of return reasons"""
enum SepaCreditTransferReturnedReasonCodeEnum {
  BankOperationCodeInvalid
  BeneficiaryAccountBlocked
  BeneficiaryAccountClosed
  BeneficiaryAccountNotFound
  BeneficiaryAddressMissing
  BeneficiaryBankEriNotAllowed
  BeneficiaryBankNotRegisteredCsm
  BeneficiaryDeceased
  BeneficiaryNameOrAddressInsufficientByRegulatory
  BicIncorrect
  NotSpecified
  NotSpecifiedByBeneficiary
  OriginatorAccountOrIdInsufficientByRegulatory
  OriginatorNameOrAddressInsufficientByRegulatory
  PotentialHitBeneficiaryByRegulatory
  TransactionDuplicated
  TransactionNotAllowedOnAccountType
}

"""List of return reasons"""
enum SepaCreditTransferReturnReasonCodeEnum {
  NotSpecifiedByBeneficiary
}

"""SDD Account input"""
input SepaDirectDebitAccount {
  """Address input"""
  address: AddressInput

  """
  Your Swan IBAN if you want to receive or send a credit transfer in or from your Swan account
  """
  iban: IBAN!

  """Name of the account holder"""
  name: String!

  """SEPA creditor identifier"""
  identifier: SepaCreditorIdentifier!

  """Creditor ultime name"""
  ultimateName: String
}

"""List of SDD cancel reasons"""
enum SepaDirectDebitCancelReasonCodeEnum {
  AgentIncorrect
  InvestigationRequestReceived
  NotSpecifiedByOriginator
  PaymentUndue
  TransactionDuplicated
}

interface SEPADirectDebitMandate {
  """
  Unique identifier of the received direct debit mandate, generated by Swan
  """
  id: ID!
}

"""List of SDD reject reasons"""
enum SepaDirectDebitRejectReasonCodeEnum {
  NotSpecifiedByPayer
}

"""List of SDD return reasons"""
enum SepaDirectDebitReturnReasonCodeEnum {
  DebtorAccountBlocked
  DebtorAccountClosed
  MandateInvalid
  NotSpecifiedByBank
  NotSpecifiedByPayer
  RegulatorReason
  TransactionDuplicated
  TransactionNotAllowedOnAccountType
}

"""List of SDD reverse reasons"""
enum SepaDirectDebitReverseReasonCodeEnum {
  NotSpecifiedByBank
  NotSpecifiedByOriginator
  TransactionDuplicated
}

"""Payment direct debit mandate for SEPA"""
type SEPAPaymentDirectDebitMandate implements SEPADirectDebitMandate & PaymentDirectDebitMandate & PaymentMandate {
  """Unique identifier of the SEPA Direct Debit Payment Mandate"""
  id: ID!

  """Unique reference of the SEPA Direct Debit Payment Mandate"""
  reference: String!

  """SEPA Direct Debit Payment Mandate scheme"""
  scheme: SEPAPaymentMandateScheme!

  """SEPA Direct Debit Payment Mandate status information"""
  statusInfo: PaymentMandateStatusInfo!

  """SEPA Direct Debit Payment Mandate sequence"""
  sequence: SEPAPaymentMandateSequence!

  """SEPA Direct Debit Payment Mandate PDF document URL"""
  mandateDocumentUrl: String!

  """SEPA Direct Debit Payment Mandate debtor information"""
  debtor: SEPAPaymentMandateDebtor!

  """SEPA direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """SEPA Direct Debit Payment Mandate creditor information"""
  creditor: SEPAPaymentMandateCreditor!

  """Signature date of the SEPA Direct Debit Payment Mandate"""
  signatureDate: Date

  """Creation date of the SEPA Direct Debit Payment Mandate"""
  createdAt: DateTime!

  """Last Update date of the SEPA Direct Debit Payment Mandate"""
  updatedAt: DateTime!

  """
  Date of the the last transaction executed for the concerned SEPA Direct Debit Payment Mandate
  """
  executedAt: DateTime

  """Expiry date of the SEPA Direct Debit Payment Mandate"""
  expiredAt: Date

  """Account Holder information"""
  accountHolder: AccountHolder!
}

type SEPAPaymentMandateCreditor implements PaymentMandateCreditor {
  """SEPA Direct Debit Payment Mandate creditor UUID"""
  id: ID!

  """SEPA Direct Debit Payment Mandate Sepa Creditor Idenfier (SCI)"""
  identifier: SepaCreditorIdentifier!

  """SEPA Direct Debit Payment Mandate creditor name"""
  name: String!

  """SEPA Direct Debit Payment Mandate creditor address"""
  address: Address!
}

type SEPAPaymentMandateDebtor implements PaymentMandateDebtor {
  """SEPA Direct Debit Payment Mandate debtor name"""
  name: String!

  """SEPA Direct Debit Payment Mandate debtor IBAN"""
  iban: IBAN!

  """SEPA Direct Debit Payment Mandate debtor e-mail"""
  email: String!

  """SEPA Direct Debit Payment Mandate debtor country"""
  country: CCA3!

  """
  SEPA Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries
  """
  address: Address
}

enum SEPAPaymentMandateScheme {
  """SEPA Direct Debit Core"""
  SepaDirectDebitCore

  """SEPA Direct Debit B2B"""
  SepaDirectDebitB2b
}

"""SEPA Direct Debit Payment Mandate Sequence"""
enum SEPAPaymentMandateSequence {
  """
  The SEPA Direct Debit Payment Mandate can be used for recurrent collections
  """
  Recurrent

  """The SEPA Direct Debit Payment Mandate can be used only once"""
  OneOff
}

"""Received direct debit mandate for SEPA"""
type SEPAReceivedDirectDebitMandate implements ReceivedDirectDebitMandate & SEPADirectDebitMandate {
  """
  Unique identifier of the received SEPA direct debit mandate, generated by Swan
  """
  id: ID!

  """Version of the received SEPA direct debit mandate"""
  version: String!

  """Creation date of the received SEPA direct debit mandate"""
  createdAt: DateTime!

  """Last Update date of the received SEPA direct debit mandate"""
  updatedAt: DateTime!

  """Received SEPA direct debit Unique Mandate Reference (UMR)"""
  reference: String!

  """Received SEPA direct debit mandate scheme"""
  scheme: SEPAReceivedDirectDebitMandateScheme!

  """Received SEPA direct debit mandate sequence"""
  sequence: SEPAReceivedDirectDebitMandateSequence!

  """Received SEPA direct debit creditor"""
  creditor: SEPAReceivedDirectDebitMandateCreditor!

  """Received SEPA direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """
  Date of the last SEPA direct debit transaction executed for the concerned received SEPA direct debit mandate
  """
  executedAt: DateTime

  """Date of signature of the received SEPA direct debit mandate"""
  signatureDate: Date

  """
  Expiry date of the received SEPA direct debit mandate, computed automatically (36 months from the executedAt date)
  """
  expiredAt: Date

  """Mandate status information of the received SEPA direct debit mandate"""
  statusInfo: ReceivedDirectDebitMandateStatusInfo!

  """Account of the received SEPA direct debit mandate debtor"""
  account: Account

  """Iban of the received SEPA direct debit mandate debtor"""
  iban: IBAN!

  """Mandate name"""
  name: String
}

"""SEPA received direct debit mandate creditor"""
type SEPAReceivedDirectDebitMandateCreditor {
  """SEPA Creditor identifier (SCI)"""
  identifier: String!

  """Name of the SEPA creditor"""
  name: String!

  """Address of the SEPA creditor"""
  address: Address!
}

"""Received SEPA direct debit mandate scheme"""
enum SEPAReceivedDirectDebitMandateScheme {
  """
  When the received SEPA direct debit mandate can only be used for SEPA B2B direct debit transactions
  """
  SepaDirectDebitB2b

  """
  When the received SEPA direct debit mandate can only be used for SEPA Core direct debit transactions
  """
  SepaDirectDebitCore
}

"""SEPA received direct debit mandate sequence"""
enum SEPAReceivedDirectDebitMandateSequence {
  """
  When the authorisation is given once by the SEPA Debtor to collect only one single SEPA direct debit
  """
  OneOff

  """
  When the authorisation by the Debtor can be used for regular SEPA direct debits initiated by the Creditor
  """
  Recurrent
}

"""Received SEPA direct debit mandate type"""
enum SEPAReceivedDirectDebitMandateType {
  """
  When the received SEPA direct debit mandate can only be used for SEPA B2B direct debit transactions
  """
  B2B

  """
  When the received SEPA direct debit mandate can only be used for SEPA Core direct debit transactions
  """
  Core
}

"""
SEPA Identifier
max 35 Latin characters as follow :
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    0 1 2 3 4 5 6 7 8 9
    / - ? : ( ) . , '  +
with some follow extra rules :
    Content must not start or end with a /
    Content must not contain //s
"""
scalar SepaReference

"""Book an incoming check simulation input"""
input SimulateIncomingCheckBookingInput {
  """Transaction ID to be booked"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingCheckBookingPayload = SimulateIncomingCheckBookingSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingCheckBookingSuccessPayload {
  transactionId: ID!
}

type SimulateIncomingCheckRejectionErrorPayload {
  reason: String!
}

"""Reject incoming Check simulation input"""
input SimulateIncomingCheckRejectionInput {
  """Transaction ID to be Rejected"""
  transactionId: ID!

  """Rejection reason code"""
  reasonCode: IncomingCheckRejectionReasonCodeEnum
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingCheckRejectionPayload = SimulateIncomingCheckRejectionSuccessPayload | SimulateIncomingCheckRejectionErrorPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingCheckRejectionSuccessPayload {
  transactionId: ID!
}

"""Return a booked incoming check simulation input"""
input SimulateIncomingCheckReturnInput {
  """Transaction ID to be booked"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingCheckReturnPayload = SimulateIncomingCheckReturnSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingCheckReturnSuccessPayload {
  transactionId: ID!
}

"""Book an outgoing transfer simulation input"""
input SimulateIncomingInternalDirectDebitBookingInput {
  """Transaction ID to be booked"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingInternalDirectDebitBookingPayload = SimulateIncomingInternalDirectDebitBookingSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingInternalDirectDebitBookingSuccessPayload {
  transactionId: ID!
}

type SimulateIncomingInternalDirectDebitRejectErrorPayload {
  reason: String!
}

"""Reject incoming SEPA Direct Debit simulation input"""
input SimulateIncomingInternalDirectDebitRejectInput {
  """Transaction ID to be Rejected"""
  transactionId: ID!

  """Rejection reason code"""
  reasonCode: IncomingInternalDirectDebitRejectReasonCodeEnum
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingInternalDirectDebitRejectPayload = SimulateIncomingInternalDirectDebitRejectSuccessPayload | SimulateIncomingInternalDirectDebitRejectErrorPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingInternalDirectDebitRejectSuccessPayload {
  transactionId: ID!
}

"""Recall an incoming transfer simulation input"""
input SimulateIncomingSepaCreditTransferAcceptedRecallInput {
  """Reason code for incoming transfer recall"""
  reasonCode: SepaCreditTransferRecallReasonCodeEnum!

  """Transaction ID to be recalled"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingSepaCreditTransferAcceptedRecallPayload = SimulateIncomingSepaCreditTransferAcceptedRecallSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingSepaCreditTransferAcceptedRecallSuccessPayload {
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingSepaCreditTransferReceptionPayload = SimulateIncomingSepaCreditTransferReceptionSuccessPayload | ForbiddenRejection

"""Success payload type"""
type SimulateIncomingSepaCreditTransferReceptionSuccessPayload {
  transactionId: ID!
}

"""Return an incoming transfer simulation input"""
input SimulateIncomingSepaCreditTransferReturnInput {
  """Reason code for incoming transfer return"""
  reasonCode: SepaCreditTransferReturnReasonCodeEnum!

  """Transaction ID to be returned"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingSepaCreditTransferReturnPayload = SimulateIncomingSepaCreditTransferReturnSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingSepaCreditTransferReturnSuccessPayload {
  transactionId: ID!
}

"""Book an outgoing transfer simulation input"""
input SimulateIncomingSepaDirectDebitBookingInput {
  """Transaction ID to be booked"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingSepaDirectDebitBookingPayload = SimulateIncomingSepaDirectDebitBookingSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingSepaDirectDebitBookingSuccessPayload {
  transactionId: ID!
}

type SimulateIncomingSepaDirectDebitRejectErrorPayload {
  reason: String!
}

"""Reject incoming SEPA Direct Debit simulation input"""
input SimulateIncomingSepaDirectDebitRejectInput {
  """Transaction ID to be Rejected"""
  transactionId: ID!

  """Rejection reason code"""
  reasonCode: IncomingSepaDirectDebitRejectReasonCodeEnum
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingSepaDirectDebitRejectPayload = SimulateIncomingSepaDirectDebitRejectSuccessPayload | SimulateIncomingSepaDirectDebitRejectErrorPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingSepaDirectDebitRejectSuccessPayload {
  transactionId: ID!
}

type SimulateIncomingSepaDirectDebitReturnErrorPayload {
  reason: String!
}

"""Return incoming SEPA Direct Debit simulation input"""
input SimulateIncomingSepaDirectDebitReturnInput {
  """Transaction ID to be returned"""
  transactionId: ID!

  """Return reason code"""
  reasonCode: IncomingSepaDirectDebitReturnReasonCodeEnum
}

"""Union of Success payload and potential rejections"""
union SimulateIncomingSepaDirectDebitReturnPayload = SimulateIncomingSepaDirectDebitReturnSuccessPayload | SimulateIncomingSepaDirectDebitReturnErrorPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateIncomingSepaDirectDebitReturnSuccessPayload {
  transactionId: ID!
}

input SimulateInvoiceGenerationInput {
  accountId: ID!
}

union SimulateInvoiceGenerationPayload = SimulateInvoiceGenerationSuccessPayload | AccountNotFoundRejection | AccountNotEligibleRejection

type SimulateInvoiceGenerationSuccessPayload {
  invoice: Invoice!
}

"""Request a card authorization simulation input"""
input SimulateOutgoingCardAuthorizationInput {
  amount: AmountInput!

  """Authorization request type"""
  authorizationType: CardAuthorizationType

  """Card ID"""
  cardId: String!

  """Card transaction category"""
  cardTransactionCategory: CardTransactionCategory

  """Simulation card type"""
  cardType: SimulationCardType

  """Merchant"""
  merchant: Merchant

  """Original amount"""
  originalAmount: AmountInput

  """Authorization wanted outcome"""
  outcome: CardAuthorizationOutcome

  """Terminal ID"""
  terminalId: String = "SWAN01"

  """Expiration date time"""
  expirationDateTime: DateTime

  """"""
  allowsPartialAuthorization: Boolean = false
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingCardAuthorizationPayload = SimulateOutgoingCardAuthorizationSuccessPayload | SimulateOutgoingCardAuthorizationRejectPayload | CardNotFoundRejection | ForbiddenRejection

"""Reject payload type"""
type SimulateOutgoingCardAuthorizationRejectPayload {
  transactionId: ID!
  reason: SimulateOutgoingCardAuthorizationRejectPayloadReason!
}

"""Reject payload reason"""
enum SimulateOutgoingCardAuthorizationRejectPayloadReason {
  NotHeld
}

"""Input to simulate a release of a card authorization"""
input SimulateOutgoingCardAuthorizationReleaseInput {
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingCardAuthorizationReleasePayload = SimulateOutgoingCardAuthorizationReleaseSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingCardAuthorizationReleaseSuccessPayload {
  transactionId: ID!
}

"""Success payload type"""
type SimulateOutgoingCardAuthorizationSuccessPayload {
  transactionId: ID!
}

"""Credit a card simulation input"""
input SimulateOutgoingCardCreditInput {
  """Amount"""
  amount: AmountInput!

  """Card ID"""
  cardId: String!

  """Card type"""
  cardType: SimulationCardType

  """Original amount"""
  originalAmount: AmountInput

  """Terminal Id"""
  terminalId: String

  """Merchant Id"""
  merchantId: String

  """Merchant Category Code"""
  merchantCategoryCode: String

  """Merchant Name"""
  merchantName: String

  """Merchant City"""
  merchantCity: String

  """Merchant Country"""
  merchantCountry: CCA3
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingCardCreditPayload = SimulateOutgoingCardCreditSuccessPayload | CardNotFoundRejection | ForbiddenRejection

"""Reverse a credit simulation input"""
input SimulateOutgoingCardCreditReverseInput {
  """Amount"""
  amount: AmountInput

  """Original amount"""
  originalAmount: AmountInput

  """Transaction ID to be reversed"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingCardCreditReversePayload = SimulateOutgoingCardCreditReverseSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingCardCreditReverseSuccessPayload {
  transactionId: ID!
}

"""Success payload type"""
type SimulateOutgoingCardCreditSuccessPayload {
  transactionId: ID!
}

"""Debit a card simulation input"""
input SimulateOutgoingCardDebitInput {
  """Amount"""
  amount: AmountInput

  """Originalmount"""
  originalAmount: AmountInput

  """Transaction ID to be debited"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingCardDebitPayload = SimulateOutgoingCardDebitSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection | CardNotFoundRejection

"""Debit Reversal simulation input"""
input SimulateOutgoingCardDebitReverseInput {
  """Amount"""
  amount: AmountInput

  """Originalmount"""
  originalAmount: AmountInput

  """Transaction ID to be reversed"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingCardDebitReversePayload = SimulateOutgoingCardDebitReverseSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingCardDebitReverseSuccessPayload {
  transactionId: ID!
}

"""Success payload type"""
type SimulateOutgoingCardDebitSuccessPayload {
  transactionId: ID!
}

"""Recall an outgoing transfer simulation input"""
input SimulateOutgoingSepaCreditTransferAcceptedRecallInput {
  """Recall reason code"""
  reasonCode: SepaCreditTransferRecalledReasonCodeEnum!

  """Transaction ID to be recalled"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaCreditTransferAcceptedRecallPayload = SimulateOutgoingSepaCreditTransferAcceptedRecallSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaCreditTransferAcceptedRecallSuccessPayload {
  transactionId: ID!
}

"""Book an outgoing transfer simulation input"""
input SimulateOutgoingSepaCreditTransferBookingInput {
  """Transaction ID to be booked"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaCreditTransferBookingPayload = SimulateOutgoingSepaCreditTransferBookingSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaCreditTransferBookingSuccessPayload {
  transactionId: ID!
}

"""Reject an outgoing transfer simulation input"""
input SimulateOutgoingSepaCreditTransferRejectionInput {
  """Rejection reason code"""
  reasonCode: SepaCreditTransferRejectionReasonCodeEnum!

  """Transaction ID to be rejected"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaCreditTransferRejectionPayload = SimulateOutgoingSepaCreditTransferRejectionSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaCreditTransferRejectionSuccessPayload {
  transactionId: ID!
}

"""Return an outgoing transfer simulation input"""
input SimulateOutgoingSepaCreditTransferReturnInput {
  """Return reason code"""
  reasonCode: SepaCreditTransferReturnedReasonCodeEnum!

  """Transaction ID to be returned"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaCreditTransferReturnPayload = SimulateOutgoingSepaCreditTransferReturnSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaCreditTransferReturnSuccessPayload {
  transactionId: ID!
}

"""Cancel a direct debit instruction simulation input"""
input SimulateOutgoingSepaDirectDebitCancelInput {
  """Cancelation reason code"""
  reasonCode: SepaDirectDebitCancelReasonCodeEnum!

  """Transaction ID to be cancelled"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaDirectDebitCancelPayload = SimulateOutgoingSepaDirectDebitCancelSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaDirectDebitCancelSuccessPayload {
  transactionId: ID!
}

"""Receive a direct debit instruction simulation input"""
input SimulateOutgoingSepaDirectDebitReceptionInput {
  """Amount"""
  amount: AmountInput!

  """Creditor account"""
  creditor: SepaDirectDebitAccount!

  """Debtor IBAN. It should be your Swan IBAN"""
  debtorIban: IBAN!

  """SEPA end to end reference"""
  endToEndId: SepaReference

  """
  Requested execution date with date time format (ISO 8601 with time information). It can't be in the past
  ex: 2021-04-12T16:28:22.867Z
  """
  executionDate: DateTime!

  """Mandate amendment info"""
  mandateAmendment: MandateAmendment

  """SEPA mandate reference"""
  mandateReference: SepaReference!

  """SEPA direct debit mandate sequence"""
  mandateSequence: SEPAReceivedDirectDebitMandateSequence!

  """Received SEPA direct debit mandate type"""
  mandateType: SEPAReceivedDirectDebitMandateType!

  """Displayed label in Swan account"""
  label: String
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaDirectDebitReceptionPayload = SimulateOutgoingSepaDirectDebitReceptionSuccessPayload | ForbiddenRejection

"""Success payload type"""
type SimulateOutgoingSepaDirectDebitReceptionSuccessPayload {
  transactionId: ID!
}

"""Reject a received direct debit instruction simulation input"""
input SimulateOutgoingSepaDirectDebitRejectInput {
  """Rejection reason code"""
  reasonCode: SepaDirectDebitRejectReasonCodeEnum!

  """Transaction ID to be rejected"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaDirectDebitRejectPayload = SimulateOutgoingSepaDirectDebitRejectSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaDirectDebitRejectSuccessPayload {
  transactionId: ID!
}

"""Request a direct debit refund simulation"""
input SimulateOutgoingSepaDirectDebitReturnInput {
  """Refund reason code"""
  reasonCode: SepaDirectDebitReturnReasonCodeEnum!

  """Transaction ID to be returned"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaDirectDebitReturnPayload = SimulateOutgoingSepaDirectDebitReturnSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaDirectDebitReturnSuccessPayload {
  transactionId: ID!
}

"""Receive a direct debit reversal simulation"""
input SimulateOutgoingSepaDirectDebitReverseInput {
  """Reversal reason code"""
  reasonCode: SepaDirectDebitReverseReasonCodeEnum!

  """Transaction ID to be reversed"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateOutgoingSepaDirectDebitReversePayload = SimulateOutgoingSepaDirectDebitReverseSuccessPayload | ForbiddenRejection | TransactionNotFoundRejection

"""Success payload type"""
type SimulateOutgoingSepaDirectDebitReverseSuccessPayload {
  transactionId: ID!
}

"""Input to simulate delivery of a physical card"""
input SimulatePhysicalCardDeliveryInput {
  """Unique identifier of a card"""
  cardId: ID!

  """
  Alphanumeric string with the tracking identifier of the delivery supplier.
  """
  trackingNumber: String
}

"""Release reserved balance input"""
input SimulateReleaseReservedBalanceInput {
  """Transaction ID to be release"""
  transactionId: ID!
}

"""Union of Success payload and potential rejections"""
union SimulateReleaseReservedBalancePayload = ForbiddenRejection | TransactionNotFoundRejection | ReleaseReservedBalanceSuccessPayload

input SimulateUpdateMerchantProfileInput {
  """ID of the Merchant Profile to update"""
  merchantProfileId: ID!

  """Desired status of the Merchant Profile"""
  merchantProfileStatus: MerchantProfileStatus

  """
  Input to apply changes to the current underlying payment product
  DEPRECATED : Use merchantPaymentMethod instead
  """
  merchantPaymentProduct: [UpdateMerchantPaymentProductInput!]

  """Input to apply changes to the current underlying payment method"""
  merchantPaymentMethod: [UpdateMerchantPaymentMethodInput!]
}

"""SimulateUpdateMerchantProfilePayload"""
union SimulateUpdateMerchantProfilePayload = SimulateUpdateMerchantProfileSuccessPayload | NotFoundRejection | MerchantProfileWrongStatusRejection

"""SimulateUpdateMerchantProfileSuccessPayload"""
type SimulateUpdateMerchantProfileSuccessPayload {
  merchantProfile: MerchantProfile!
}

enum SimulationCardType {
  Physical
  Virtual
}

"""
A rejection returned when the simulation couldn't be performed because of a functional error
"""
type SimulationRejection {
  code: SimulationRejectionCode!
  message: String!
}

enum SimulationRejectionCode {
  CouldNotProvisionCard
  CouldNotUpdateDeliveryInformation
  CouldNotObtainIdentifier
}

"""
The response to a simulation call.
Will alway be true and mean that the simulation was successfully executed
"""
union SimulationResponse = SimulationSuccessfulResponse | SimulationRejection | ValidationRejection

"""
The response to a simulation call.
Will alway be true and mean that the simulation was successfully executed
"""
type SimulationSuccessfulResponse {
  noop: Boolean
}

"""Spending"""
type Spending {
  """period concerned"""
  period: SpendingLimitPeriod!

  """amount spent during the period"""
  amount: Amount
}

"""Spending limits"""
type SpendingLimit {
  """type of limit (defined by the Partner, defined by Swan, etc.)"""
  type: SpendingLimitType!

  """period concerned"""
  period: SpendingLimitPeriod!

  """sum of amount of spending authorized during the period"""
  amount: Amount!
}

"""Inputs when editing spending limit configuration"""
input SpendingLimitInput {
  """period concerned"""
  period: SpendingLimitPeriodInput!

  """sum of amount of spending authorized during the period"""
  amount: AmountInput!
}

"""Available period to compute spending limits"""
enum SpendingLimitPeriod {
  Monthly
  Weekly
  Daily
  Always
}

"""Available period to compute spending limits"""
enum SpendingLimitPeriodInput {
  Monthly
  Weekly
  Daily
  Always
}

"""Available type of spending limits"""
enum SpendingLimitType {
  """for the account holder - defined by the partner"""
  AccountHolder

  """for the partner - defined by Swan"""
  Partner
}

"""Rejection returned when Standing Order is not found"""
type StandingOrderNotFoundRejection implements Rejection {
  message: String!
}

"""Supporting document used for compliance"""
type SupportingDocument {
  """Unique identifier of the document"""
  id: String!

  """Supporting document status information"""
  statusInfo: SupportingDocumentStatusInfo!

  """Type of supporting Document"""
  supportingDocumentType: SupportingDocumentType

  """Purpose of supporting document"""
  supportingDocumentPurpose: SupportingDocumentPurposeEnum!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!
}

"""
Collection of supporting documents used for compliance

Fetching SupportingDocument is restricted to Project access token
"""
type SupportingDocumentCollection {
  """Unique identifier of the supporting document collection"""
  id: String!

  """Status of the supporting document collection"""
  statusInfo: SupportingDocumentCollectionStatusInfo!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  List of supported documents contained in the supporting document collection
  """
  supportingDocuments: [SupportingDocument]!

  """
  List of required supporting document purposes for this supporting document collection
  """
  requiredSupportingDocumentPurposes: [SupportingDocumentPurpose!]!
}

"""Supporting document collection with Approved status"""
type SupportingDocumentCollectionApprovedStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the supporting document collection is approved"""
  status: SupportingDocumentCollectionStatus!

  """Date on which the supporting document collection has been approved"""
  approvedAt: DateTime!
}

"""Supporting document collection with Canceled status"""
type SupportingDocumentCollectionCanceledStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the supporting document collection is canceled"""
  status: SupportingDocumentCollectionStatus!

  """Date on which the supporting document collection has been canceled"""
  canceledAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type SupportingDocumentCollectionConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """SupportingDocumentCollectionEdge list"""
  edges: [SupportingDocumentCollectionEdge!]!
}

"""Implements the Relay Edge interface"""
type SupportingDocumentCollectionEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The supporting document collection"""
  node: SupportingDocumentCollection!
}

"""Rejection returned if the supporting document collection was not found"""
type SupportingDocumentCollectionNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Supporting document collection with PendingReview status"""
type SupportingDocumentCollectionPendingReviewStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """
  When the supporting document collection is completed and in compliance review
  """
  status: SupportingDocumentCollectionStatus!
}

"""Supporting document collection with Rejected status"""
type SupportingDocumentCollectionRejectedStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the supporting document collection is rejected"""
  status: SupportingDocumentCollectionStatus!

  """Date on which the supporting document collection has been rejected"""
  rejectedAt: DateTime!
}

"""Verification status of a supporting document collection"""
enum SupportingDocumentCollectionStatus {
  """When the supporting document collection is created and on going"""
  WaitingForDocument

  """
  When the supporting document collection is completed and in compliance review
  """
  PendingReview

  """When the supporting document collection is approved. Final status"""
  Approved

  """When the supporting document collection is canceled. Final status"""
  Canceled

  """When the supporting document collection is rejected. Final status"""
  Rejected
}

"""
Rejection returned if supporting document cannot be deleted because its supporting document collection status is not WaitingForDocument
"""
type SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection implements Rejection {
  message: String!
  supportingDocumentCollectionStatus: SupportingDocumentCollectionStatus!
  supportingDocumentCollection: SupportingDocumentCollection!
}

"""
Rejection returned if supporting document cannot be updated because its supporting document collection status is not WaitingForDocument
"""
type SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection implements Rejection {
  message: String!
  supportingDocumentCollectionStatus: SupportingDocumentCollectionStatus!
  supportingDocumentCollection: SupportingDocumentCollection!
}

interface SupportingDocumentCollectionStatusInfo {
  """Status of the supporting document collection"""
  status: SupportingDocumentCollectionStatus!
}

"""Rejection returned if the status transition is not allowed"""
type SupportingDocumentCollectionStatusNotAllowedRejection implements Rejection {
  oldStatus: SupportingDocumentCollectionStatus!
  newStatus: SupportingDocumentCollectionStatus!
  message: String!
}

"""Supporting document collection with WaitingForUpload status"""
type SupportingDocumentCollectionWaitingForDocumentStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the Supporting Document Collection is created"""
  status: SupportingDocumentCollectionStatus!
}

"""Supporting document with NotUploaded status."""
type SupportingDocumentNotUploadedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has not been updated on time."""
  status: SupportingDocumentStatus!
}

type SupportingDocumentPostField {
  key: String!
  value: String!
}

"""Details of a supporting document purpose"""
type SupportingDocumentPurpose {
  """Technical name of the purpose"""
  name: SupportingDocumentPurposeEnum!

  """
  Corresponding supporting document types accepted for this supporting document purpose
  """
  acceptableSupportingDocumentTypes: [SupportingDocumentType!]!
}

"""Supporting document purpose"""
enum SupportingDocumentPurposeEnum {
  """Proof of association registration"""
  AssociationRegistration

  """Banking"""
  Banking

  """Proof of company registration"""
  CompanyRegistration

  """Other"""
  Other

  """Signed power of attorney document to give the power to act on behalf."""
  PowerOfAttorney

  """Proof of company address"""
  ProofOfCompanyAddress

  """Proof of company income"""
  ProofOfCompanyIncome

  """Proof of identity"""
  ProofOfIdentity

  """Proof of individual address"""
  ProofOfIndividualAddress

  """Proof of individual income"""
  ProofOfIndividualIncome

  """Proof of origin of funds"""
  ProofOfOriginOfFunds

  """Signed status"""
  SignedStatus

  """UBO Declaration"""
  UBODeclaration

  """Sworn statement"""
  SwornStatement
}

"""Supporting document with Refused status"""
type SupportingDocumentRefusedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has been refused by Swan"""
  status: SupportingDocumentStatus!

  """An unique URL and one-time URL to download the Document"""
  downloadUrl: String!

  """Date on which the supporting document collection has been refused"""
  refusedAt: DateTime!

  """Reason why the supporting document has been refused"""
  reason: String!

  """Original file name"""
  filename: String!
}

"""Verification status of a document"""
enum SupportingDocumentStatus {
  """Document is not uploaded yet."""
  WaitingForUpload

  """Document has been uploaded but not verified by Swan yet."""
  Uploaded

  """Document has been uploaded and verified by Swan."""
  Validated

  """Document has been refused by Swan."""
  Refused

  """Document has not been uploaded on time."""
  NotUploaded
}

interface SupportingDocumentStatusInfo {
  """Status of the supporting document"""
  status: SupportingDocumentStatus!
}

"""Specific type for document"""
enum SupportingDocumentType {
  """Selfie"""
  Selfie

  """Passport"""
  Passport

  """NationalIdCard"""
  NationalIdCard

  """Resident permit"""
  ResidentPermit

  """Driving license"""
  DrivingLicense

  """Water, Electricity or Gas Bill issued within the last 3 months"""
  UtilityBill

  """Telephone Bill issued within the last 3 months"""
  PhoneBill

  """Rental Receipt issued within the last 3 months"""
  RentReceipt

  """Home Insurance contract"""
  HomeInsurance

  """
  Income Tax return or tax-exemption certificate dating less than 2 years
  """
  IncomeTaxReturn

  """A pay slip dating less than 3 months"""
  PaySlip

  """Commercial registry extract issued within the last 3 months"""
  RegisterExtract

  """Legal document required for companys formation"""
  ArticlesOfIncorporation

  """Share Deposit Certificate"""
  CapitalShareDepositCertificate

  """Ultimate Beneficial Owner Declaration"""
  UBODeclaration

  """Association registration proof for french association"""
  JOAFFEExtract

  """
  Lease agreement in the name of the business or Proof of Individual Address if the company is hosted by one of the legal representative
  """
  CompanyLeaseAgreement

  """Bank Statement"""
  BankStatement

  """
  Document with details such as bank name, address, account number and account holder
  """
  BankAccountDetails

  """Signed power of attorney document to give the power to act on behalf"""
  PowerOfAttorney

  """
  Document submitted to your tax bureau at the end of the last business period
  """
  CorporateIncomeTaxReturn

  """Other"""
  Other

  """By Laws"""
  ByLaws

  """Account statement"""
  AccountStatement

  """Deed of donation"""
  DeedOfDonation

  """Deed of sale"""
  DeedOfSale

  """Deed of succession"""
  DeedOfSuccession

  """Loan contract"""
  LoanContract

  """Notarial deed"""
  NotarialDeed

  """Sworn statement"""
  SwornStatement
}

"""Supporting document with Uploaded status"""
type SupportingDocumentUploadedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has been uploaded but not verified by Swan yet"""
  status: SupportingDocumentStatus!

  """An unique URL and one-time URL to download the Document"""
  downloadUrl: String!

  """Original file name"""
  filename: String!
}

type SupportingDocumentUploadInfo {
  url: String!
  fields: [SupportingDocumentPostField!]!
}

"""Supporting document with Validated status"""
type SupportingDocumentValidatedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has been uploaded and verified by Swan"""
  status: SupportingDocumentStatus!

  """An unique URL and one-time URL to download the Document"""
  downloadUrl: String!

  """Date on which the supporting document has been validated"""
  validatedAt: DateTime!

  """Original file name"""
  filename: String!
}

"""Supporting document with WaitingForUpload status"""
type SupportingDocumentWaitingForUploadStatusInfo implements SupportingDocumentStatusInfo {
  """When the document is not uploaded yet"""
  status: SupportingDocumentStatus!

  """
  Info to upload the document : url and fields to add along file in form (POST)
  """
  upload: SupportingDocumentUploadInfo!
}

"""
Define a reason with a message and a specific type for suspend account action
"""
type SuspendAccountReason implements Reason {
  type: SuspendAccountReasonType!
  message: String
}

"""Input version"""
input SuspendAccountReasonInput {
  type: SuspendAccountReasonType!
  message: String
}

"""Specific type for suspend account action"""
enum SuspendAccountReasonType {
  """Simple suspend request"""
  SuspendRequested
}

"""SuspendAccountStatusReason"""
union SuspendAccountStatusReason = SuspendAccountReason

"""StatusInfo when funding limit settings has been suspended"""
type SuspendedFundingLimitSettingsStatusInfo implements FundingLimitSettingsStatusInfo {
  status: FundingLimitSettingsStatus!
  reason: String!
}

"""SuspendedMerchantPaymentMethodStatusInfo"""
type SuspendedMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method suspended date"""
  suspendedAt: Date!
}

"""SuspendedMerchantPaymentProductStatusInfo"""
type SuspendedMerchantPaymentProductStatusInfo implements MerchantPaymentProductStatusInfo {
  status: MerchantPaymentProductStatus!

  """Merchant Payment Product suspended date"""
  suspendedAt: Date!
}

"""SuspendedMerchantProfileStatusInfo"""
type SuspendedMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  suspendedAt: Date!
}

"""Swan account beneficiary"""
input SwanAccountBeneficiaryInput {
  """account number to be credited"""
  accountNumber: AccountNumber!

  """full name of the beneficiary  (max 70 characters)"""
  name: String!

  """
  `true` if this new beneficiary will be saved to the beneficiary list of the debited account.
  """
  save: Boolean!
}

type ThreeDsConsent implements DetailedConsent {
  id: ID!
  projectId: String
  requireSCA: Boolean!
  status: ConsentStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  startedAt: DateTime
  expiredAt: DateTime
  consentResponses: [ConsentResponse!]!
  purpose: DetailedConsentPurpose!
  serviceToHook: String!
  consentOperations: [ConsentOperation!]!
  env: EnvType!
  identityId: String!
  state: String
  branding: Branding!
  operationsSHA256HexDigest: String
  merchantName: String!
  merchantId: String!
  merchantCategoryCode: String
  merchantAppRedirectUrl: String
  monextCardId: String!
  maskedCardNumber: String!
  amount: AmountWithCurrency!
  challenge: String
}

scalar TokenRequestorId

"""Rejection returned if too many items are given"""
type TooManyItemsRejection implements Rejection {
  message: String!
}

"""Rejection returned if the transaction was not found"""
type TransactionNotFoundRejection implements Rejection {
  transactionId: ID!
  message: String!
}

enum TransactionSide {
  Credit
  Debit
}

"""Quality of the account holder doing the onboarding"""
enum TypeOfRepresentation {
  """The account holder is the legal representative"""
  LegalRepresentative

  """The account holder has a power of attorney"""
  PowerOfAttorney
}

"""Input of the updateAccountHolderFundingLimits mutation"""
input UpdateAccountHolderFundingLimitsInput {
  """ID of the funding limit's account holder to update"""
  accountHolderId: ID!

  """Interval in number of calendar days where the limit is applied"""
  fundingLimitRollingDays: Int!

  """Global funding amount authorized during the interval"""
  fundingLimitAmount: AmountInput!

  """Instant funding amount authorized"""
  instantFundingLimitAmount: AmountInput!
}

"""Response of the updateAccountHolderFundingLimits mutation"""
union UpdateAccountHolderFundingLimitsPayload = UpdateAccountHolderFundingLimitsSuccessPayload | InternalErrorRejection

type UpdateAccountHolderFundingLimitsSuccessPayload {
  accountHolderId: ID!
}

input UpdateAccountHolderInput {
  accountHolderId: ID!
  verificationStatus: VerificationStatus
}

union UpdateAccountHolderPayload = UpdateAccountHolderSuccessPayload | AccountHolderNotFoundRejection | ValidationRejection

type UpdateAccountHolderSuccessPayload {
  accountHolder: AccountHolder!
}

"""Inputs to update the account verification status"""
input UpdateAccountVerificationStatusInput {
  """The unique identifier of the account verification"""
  accountVerificationId: ID!

  """The new status that the account verification should take"""
  newStatus: AccountVerificationStatus!
}

"""Union type return by the addReceivedSepaDirectDebitB2bMandate mutation"""
union UpdateAccountVerificationStatusPayload = UpdateAccountVerificationStatusSuccessPayload | ForbiddenRejection

"""
Return type in case of a successful response of the updateAccountVerificationStatus mutation
"""
type UpdateAccountVerificationStatusSuccessPayload {
  """The updated account verification"""
  accountVerification: AccountVerification!
}

input UpdateFundingLimitSettingsChangeRequestInput {
  fundingLimitSettingsChangeRequestId: ID!
  status: FundingLimitSettingsChangeRequestStatus
  reason: String
  approvedInstantFundingLimit: FundingLimitAmountInput
  approvedFundingLimit: FundingLimitAmountInput
}

union UpdateFundingLimitSettingsChangeRequestPayload = UpdateFundingLimitSettingsChangeRequestSuccessPayload | ForbiddenRejection | FundingLimitSettingsChangeRequestStatusNotAllowedRejection | FundingLimitSettingsChangeRequestNotFoundRejection | ValidationRejection

type UpdateFundingLimitSettingsChangeRequestSuccessPayload {
  fundingLimitSettingsChangeRequest: FundingLimitSettingsChangeRequest!
}

"""Update Merchant Profile Status Input"""
input UpdateMerchantPaymentMethodInput {
  methodType: MerchantPaymentMethodType!

  """Status to which to move the related payment product"""
  status: MerchantPaymentMethodStatus!
}

"""Update Merchant Profile Internal Direct Debit Status Input"""
input UpdateMerchantPaymentProductInput {
  productType: MerchantPaymentProductType!

  """Status to which to move the related payment product"""
  status: MerchantPaymentProductStatus!
}

input UpdateSandboxUserInput {
  id: ID!

  """First name"""
  firstName: String!

  """Last name"""
  lastName: String!

  """List of first names"""
  allFirstNames: [String!]

  """Birth date"""
  birthDate: Date!

  """
  [Alpha-3 birth country representation](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  """
  birthCountryCCA3: CCA3

  """
  [Alpha-3 nationality representation](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  Ex: FRA for french nationality
  """
  nationalityCCA3: CCA3!

  """
  Verification status is now is now an Account-Holder's attribute
  @deprecated(reason: "Verification status is now is now an Account-Holder's attribute. Updating this status should be done on the account holder level instead of sandbox users.")
  """
  verificationStatus: VerificationStatus

  """Let you simulate every use case of our identity verification process."""
  identificationStatus: IdentificationStatus

  """Identification levels."""
  identificationLevels: IdentificationLevelsInput

  """
  Saves you considerable time during the development phase,
  by automatically allowing consent,
  removing the need to repeatedly get consent.
  """
  autoConsent: Boolean!
}

union UpdateSandboxUserPayload = UpdateSandboxUserSuccessPayload | ForbiddenRejection | NationalityNotFoundRejection | SandboxUserNotFoundRejection

type UpdateSandboxUserSuccessPayload {
  sandboxUser: SandboxUser!
}

input UpdateSupportingDocumentCollectionStatusInput {
  supportingDocumentCollectionId: ID!
  status: SupportingDocumentCollectionStatus!
}

union UpdateSupportingDocumentCollectionStatusPayload = UpdateSupportingDocumentCollectionStatusSuccessPayload | ForbiddenRejection | SupportingDocumentCollectionStatusNotAllowedRejection | SupportingDocumentCollectionNotFoundRejection | InternalErrorRejection | ValidationRejection

type UpdateSupportingDocumentCollectionStatusSuccessPayload {
  supportingDocumentCollection: SupportingDocumentCollection!
}

scalar Upload

"""
URL that follows the WHATWG URL Standard.

[Examples of parsed URLs](https://url.spec.whatwg.org/#example-url-parsing) may be found in the Standard itself.
"""
scalar URL

"""The User is the unique user, natural person, of the Swan app."""
type User {
  """unique identifier of the user"""
  id: ID!

  """
  mobile phone number with the international format (Example: +33689788967)
  """
  mobilePhoneNumber: PhoneNumber

  """first name"""
  firstName: String

  """last name"""
  lastName: String

  """list of first names"""
  allFirstNames: [String!]

  """birth date"""
  birthDate: Date

  """nationality"""
  nationalityCCA3: CCA3

  """`true` if Swan has verified the user's identity"""
  idVerified: Boolean!

  """the methods used to authenticate this user"""
  authenticators: [Authenticator!]

  """
  Identification status
  
  Each attempt to go through our identity verification process will update this value.
  
  This field is only available for the current user.
  """
  identificationStatus: IdentificationStatus

  """
  List of identification levels available for the user.
  
  Whenever TRUE, it means the identification was successful for the associated level.
  """
  identificationLevels: IdentificationLevels

  """
  Preferred notification channel
  
  When it is "null" it means that the preferences have not been updated. Default SMS in use
  """
  preferredNotificationChannel: PreferredNotificationChannel

  """Creation date of the user"""
  createdAt: DateTime!

  """Last update date of the user"""
  updatedAt: DateTime!

  """The list of account memberships"""
  accountMemberships(first: Int! = 50, before: String, after: String, filters: AccountMembershipsFilterInput): AccountMembershipConnection!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type UserConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """UserEdge list"""
  edges: [UserEdge!]!
}

type UserConsentSettings {
  """Preferred notification channel"""
  preferredNotificationChannel: PreferredNotificationChannel!

  """User identifier"""
  userId: String!

  """Project identifier"""
  projectId: String!
}

"""Implements the Relay Edge interface"""
type UserEdge implements Edge {
  """
  Opaque identifier pointing to this consent node in the pagination mechanism
  """
  cursor: String!

  """The consent"""
  node: User!
}

"""A detail of a validation error : what field is errored and why"""
type ValidationError {
  """
  Onboarding property that is not matching requirements to allow a finalization
  """
  field: String!

  """Constraints that are not matched on the Onboarding property"""
  errors: [FieldValidationError!]
}

type ValidationFieldError {
  code: ValidationFieldErrorCode!
  message: String!
  path: [String!]!
}

enum ValidationFieldErrorCode {
  InvalidString
  InvalidType
  TooLong
  TooShort
}

"""Rejection returned if an input contains invalid data"""
type ValidationRejection implements Rejection {
  fields: [ValidationFieldError!]!
  message: String!
}

"""Verification Flow."""
enum VerificationFlow {
  """
  When you ask the account holder to start the verification process at the beginning of the relationship to get an unlimited account.
  """
  Upfront

  """
  When you ask the account holder the minimum required to comply the law at the beginning of the relationship.
  """
  Progressive
}

"""Verification status of an account holder"""
enum VerificationStatus {
  """
  When the account holder has not started to answer the verification process.
  """
  NotStarted

  """
  When Swan is waiting for information about the account holder to continue the verification process.
  """
  WaitingForInformation

  """When the verification process is pending."""
  Pending

  """When the account holder is verified."""
  Verified

  """When the account holder is refused."""
  Refused
}

"""Enabled Information"""
type VerifiedStatusInfo implements AccountVerificationStatusInfo {
  """Date at which the verification was verified"""
  verifiedAt: DateTime!

  """Account verification status (Verified)"""
  status: AccountVerificationStatus!
}

"""
Virtual IBAN can be used by the account holder to receive SCT (Sepa Credit Transfer) or to be debited by SDD (Sepa Direct Debit).
"""
type VirtualIBANEntry {
  """Unique identifier of a Virtual IBAN entry"""
  id: ID!

  """International Bank Account Number"""
  IBAN: IBAN!

  """Bank Identifier Code"""
  BIC: BIC!

  """Label (could be used to identify)"""
  label: String

  """Status of the Iban"""
  status: IBANStatus!

  """`true` if the Virtual IBAN refuses all Sepa Direct Debit received"""
  blockSDD: Boolean!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type VirtualIBANEntryConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """VirtualIBANEntryEdge list"""
  edges: [VirtualIBANEntryEdge!]!
}

"""Implements the Relay Edge interface"""
type VirtualIBANEntryEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The virtual iban entry"""
  node: VirtualIBANEntry!
}

"""Wallet Provider"""
enum WalletProviderType {
  ApplePay
  GooglePay
}

scalar WalletToken

type WebBankingSettings {
  canViewAccountDetails: Boolean
  canViewAccountStatement: Boolean
  canManageVirtualIbans: Boolean
  canInitiatePaymentsToNewBeneficiaries: Boolean
  canViewPaymentList: Boolean
  canOrderVirtualCards: Boolean
  canOrderPhysicalCards: Boolean
  canViewMembers: Boolean
  canAddNewMembers: Boolean
}

"""Rejection returned when a parameter has a wrong value"""
type WrongValueProvidedRejection implements Rejection {
  message: String!
  valueProvided: String!
  parameterName: String!
}