"""
Whether you call it a wallet, monetary account, payment account or bank account, the notion of account is fundamental at Swan. All payment flows necessarily go through an account.
"""
type Account {
  """Unique identifier of an account"""
  id: ID!

  """Unique account number"""
  number: AccountNumber!

  """Account name"""
  name: String!

  """Account holder"""
  holder: AccountHolder!

  """Cash account type"""
  cashAccountType: CashAccountType!

  """Country of the account"""
  country: AccountCountry!

  """Payment level"""
  paymentLevel: PaymentLevel!

  """
  Bank Identifier Code
  Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited`
  """
  BIC: BIC!

  """
  International Bank Account Number
  Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited`
  """
  IBAN: IBAN

  """Currency"""
  currency: Currency!

  """`true` if the main IBAN refuses all Sepa Direct Debit received"""
  blockSDD: Boolean

  """Status of the account"""
  statusInfo: AccountStatusInfo!

  """Partnership status"""
  partnershipStatusInfo: PartnershipStatusInfo

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """List of Virtual IBAN"""
  virtualIbanEntries(first: Int! = 50, before: String, after: String): VirtualIBANEntryConnection!

  """List of account membership for this account"""
  memberships(first: Int! = 50, before: String, after: String, filters: MembershipsFilterInput, orderBy: AccountMembershipOrderByInput): AccountMembershipConnection!

  """`true`if a consent is required to fetch new transactions"""
  requiredConsentToFetchNewTransactions: Boolean!

  """Language used for account statements"""
  language: AccountLanguage!

  """Legal representative account membership"""
  legalRepresentativeMembership: AccountMembership!

  """
  Type of the account : EMoney if account holder has not finished the KYC requirements, PaymentService otherwise
  """
  paymentAccountType: PaymentAccountType!

  """Date of the account going from eMoney to PaymentService"""
  upgradedAt: DateTime

  """Link to the account's bank details"""
  bankDetails: String

  """Legal Documents linked to the account"""
  legalDocuments(first: Int! = 50, after: String, filters: LegalDocumentsFilterInput): LegalDocumentConnection

  """A list of balances regarding an account."""
  balances: AccountBalances

  """
  A list of statements of an account.
  The list is ordered by lastUpdateAt
  """
  statements(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: StatementFiltersInput
  ): StatementConnection

  """A list of transactions of an account."""
  transactions(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput

    """
    When the list of elements needs to be sorted (default value UpdatedAt desc)
    """
    orderBy: TransactionsOrderByInput
  ): TransactionConnection

  """
  A list of invoices of an account.
  The list is ordered by creation date (from newest to oldest)
  """
  invoices(
    """number of elements in the list (default value 10)"""
    first: Int! = 10

    """When the list of elements needs to start after an element"""
    after: String
  ): InvoiceConnection

  """A list of receive Direct Mandates of an account."""
  receivedDirectDebitMandates(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be ordered"""
    orderBy: AccountReceivedDirectDebitOrderByInput

    """When the list of elements needs to be filtered"""
    filters: AccountReceivedDirectDebitMandateFiltersInput
  ): ReceivedDirectDebitMandateConnection

  """List of merchant profiles created on the account"""
  merchantProfiles(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be ordered"""
    orderBy: MerchantProfileOrderByInput

    """When the list of elements needs to be filtered"""
    filters: MerchantProfileFiltersInput
  ): MerchantProfileConnection

  """A list of standing orders regarding an account."""
  standingOrders(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to start at a specific offset"""
    offset: Int

    """When the list of elements needs to be ordered"""
    orderBy: AccountStandingOrderOrderByInput

    """When the list of elements needs to be filtered"""
    filters: AccountStandingOrderFiltersInput
  ): StandingOrderConnection!

  """List of funding source created on the account"""
  fundingSources(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be ordered"""
    orderBy: FundingSourceOrderByInput

    """When the list of elements needs to be filtered"""
    filters: FundingSourceFiltersInput
  ): FundingSourceConnection
}

"""A list of balances regarding an account."""
type AccountBalances {
  """
  Balance composed of booked, pending transactions and rolling reserve used known at the time of calculation.
  """
  available: Amount!

  """Balance just composed of pending transactions."""
  pending: Amount!

  """Balance just composed of booked transactions."""
  booked: Amount!

  """Balance just composed of rolling reserve used in booked transactions."""
  reserved: Amount!
}

"""Account Closed status information"""
type AccountClosedStatus implements AccountStatusInfo {
  """Account status (always Closed for type AccountClosedStatus)"""
  status: AccountStatus!

  """
  Reason why the account is suspended
  @Deprecated
  """
  reason: String!

  """Reason why the account is currently closed"""
  reasonInfo: CloseAccountStatusReason!
}

"""Account Closing status information"""
type AccountClosingStatus implements AccountStatusInfo {
  """Account status (always Closing for type AccountClosingStatus)"""
  status: AccountStatus!

  """
  Reason why the account is suspended
  @Deprecated
  """
  reason: String!

  """Reason why the account is currently in closing"""
  reasonInfo: CloseAccountStatusReason!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type AccountConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """AccountEdge list"""
  edges: [AccountEdge!]!
}

"""
Refers to the country of the account. It will determine the country code of the local IBAN of the account.

Available Account Country: CCA3
"""
enum AccountCountry {
  """French account with a French IBAN, starting with FR."""
  FRA

  """German account with a German IBAN, starting with DE."""
  DEU

  """Spanish account with a Spanish IBAN, starting with ES."""
  ESP

  """Dutch account with a Dutch IBAN, starting with DU."""
  NLD
}

"""Implements the Relay Edge interface"""
type AccountEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The account"""
  node: Account!
}

input AccountFilterInput {
  """Account Status we want to filter on"""
  status: [AccountStatus!]

  """Account Payment Levels we want to filter on"""
  paymentLevels: [PaymentLevel!]

  """Searches name, account number, and IBAN"""
  search: String
}

enum AccountFundingLimitsReachedReason {
  """Account Holder instant funding limit exceeded"""
  InstantFundingLimitExceededRejection

  """Account Holder funding limit exceeded"""
  FundingLimitExceededRejection

  """Project instant funding limit exceeded"""
  ProjectInstantFundingLimitExceededRejection

  """Project funding limit exceeded"""
  ProjectFundingLimitExceededRejection

  """Global instant funding limit exceeded"""
  GlobalInstantFundingLimitExceededRejection

  """Global funding limit exceeded"""
  GlobalFundingLimitExceededRejection

  """Insufficient funds rejection"""
  InsufficientFundsRejection
}

"""
The account holder is the person who owns the money stored in the account. The account holder can be one of your customers, whether it is a natural person or a legal person, or quite simply you.
"""
type AccountHolder {
  """Unique identifier of the account holder."""
  id: ID!

  """
  Verification status.
  *Banking regulations require financial institutions such as Swan to know and verify their customers in order to comply with their anti-money laundering and terrorist financing obligations. In banking jargon, we talk about KYC (Know Your Customers) procedure*
  """
  verificationStatus: VerificationStatus!

  """Account holder type information."""
  info: AccountHolderInfo!

  """Account holder status information."""
  statusInfo: AccountHolderStatusInfo

  """Residency address."""
  residencyAddress: AddressInfo!

  """Created date."""
  createdDate: DateTime!

  """Updated date."""
  updatedDate: DateTime!

  """List of accounts owned by the account holder."""
  accounts(after: String, before: String, first: Int! = 50, orderBy: AccountOrderByInput): AccountConnection!

  """List of supporting document collection for an account holder"""
  supportingDocumentCollections(first: Int! = 50, before: String, after: String): SupportingDocumentCollectionConnection!

  """List of funding limit settings change request for an account holder"""
  fundingLimitSettingsChangeRequests(first: Int! = 50, before: String, after: String): FundingLimitSettingsChangeRequestConnection!

  """Account holder onboarding"""
  onboarding: Onboarding

  """List of external account owned by the account holder"""
  externalAccounts(first: Int! = 50, before: String, after: String): ExternalAccountConnection!

  """A list of Payment Mandates for an account holder."""
  paymentMandates(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """
    When the list of elements needs to be ordered, by default, the list will be ordered by the latest updated Payment Mandate
    """
    orderBy: PaymentMandateOrderByInput

    """When the list of elements needs to be filtered"""
    filters: PaymentMandateFiltersInput
  ): PaymentMandateConnection

  """Funding limit settings"""
  fundingLimitSettings: FundingLimitSettings
}

"""Account Holder Canceled Status Information"""
type AccountHolderCanceledStatusInfo implements AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!

  """Reason why the account holder is suspended."""
  reason: String!
}

type AccountHolderCompanyInfo implements AccountHolderInfo {
  """Account holder type (always Company for type AccountHolderCompanyInfo)"""
  type: AccountHolderType!

  """Name of the company."""
  name: String!

  """Registration number of the company (SIRET, ...)."""
  registrationNumber: String

  """Registration date of the company."""
  companyRegistrationDate: Date

  """Legal form of the company (SAS, SCI, SASU, ...)."""
  companyType: CompanyType

  """Business activity."""
  businessActivity: BusinessActivity!

  """
  Business activity description.
  This must be 1024 characters long maximum.
  """
  businessActivityDescription: String!

  """Estimated monthly payment volume (euro)."""
  monthlyPaymentVolume: MonthlyPaymentVolume!

  """
  The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
  
  The ultimate beneficiary is :
  - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
  - either the natural person (s) who exercise, by other means, a power of control of the company;
  """
  individualUltimateBeneficialOwners: [IndividualUltimateBeneficialOwner!]!

  """
  Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT
  """
  vatNumber: String

  """Tax Identification Number"""
  taxIdentificationNumber: String

  """Legal representative personal address"""
  legalRepresentativePersonalAddress: AddressInformation
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)).
"""
type AccountHolderConnection implements Connection {
  """Total number of element in the list."""
  totalCount: Int!

  """Information about the current, the previous and the next page."""
  pageInfo: PageInfo!

  """AccountHolderEdge list."""
  edges: [AccountHolderEdge!]!
}

"""Implements the Relay Edge interface."""
type AccountHolderEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism."""
  cursor: String!

  """The account holder."""
  node: AccountHolder!
}

"""Account Holder Enabled Status Information"""
type AccountHolderEnabledStatusInfo implements AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!
}

input AccountHolderFilterInput {
  status: [AccountHolderStatus!]
  types: [AccountHolderType!]
  verificationStatus: [VerificationStatus!]

  """Searches company name, first name, last name"""
  search: String
  firstName: String
  lastName: String
  birthDate: String
  registrationNumber: String
}

"""Individual account holder."""
type AccountHolderIndividualInfo implements AccountHolderInfo {
  """
  Account holder type (always Individual for type AccountHolderIndividualInfo).
  """
  type: AccountHolderType!

  """Account Holder's first name and last name."""
  name: String!

  """Employment status of the account holder (regulatory questions)."""
  employmentStatus: EmploymentStatus!

  """Monthly income of the account holder (regulatory questions)."""
  monthlyIncome: MonthlyIncome!

  """User of the individual account holder."""
  user: User!

  """Tax Identification Number"""
  taxIdentificationNumber: String
}

"""Account holder types."""
interface AccountHolderInfo {
  """Account holder type"""
  type: AccountHolderType!

  """Account holder name"""
  name: String!
}

"""Rejection returned when the Account Holder was not found"""
type AccountHolderNotFoundRejection implements Rejection {
  message: String!
}

"""
Field we can use when ordering that can be applied when listing account holders
"""
enum AccountHolderOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing account holders"""
input AccountHolderOrderByInput {
  field: AccountHolderOrderByFieldInput
  direction: OrderByDirection
}

"""Account holder status."""
enum AccountHolderStatus {
  """When the account holder is enabled."""
  Enabled

  """When the account holder is suspended."""
  Suspended

  """When the account holder is canceled."""
  Canceled
}

"""Account Holder Status Information"""
interface AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!
}

"""Account Holder Suspended Status Information"""
type AccountHolderSuspendedStatusInfo implements AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!

  """Reason why the account holder is suspended."""
  reason: String!
}

"""Account holder type"""
enum AccountHolderType {
  """Individual (Natural person)"""
  Individual

  """Company (Legal person)"""
  Company
}

"""
Rejection returned if the account holder type is individual.
An individual account holder can't create a b2b received direct debit mandate.
"""
type AccountHolderTypeIndividualRejection implements Rejection {
  message: String!
}

"""Language: ISO 639-1 language code"""
enum AccountLanguage {
  de
  en
  fr
  it
  nl
  es
  pt
}

"""
An account membership represents the rights of a user for a given account.

*Each account is administered by an account membership having the capacity of legal representative. He has the possibility of delegating rights on this account to other users.*
"""
type AccountMembership {
  """Unique identifier of an account membership"""
  id: ID!

  """email"""
  email: String!

  """user of this account membership"""
  user: User

  """
  `true` if this account membership having the capacity of the legal representative of the account holder.
  """
  legalRepresentative: Boolean!

  """
  `true` if this account membership can view account balances and transactions history
  """
  canViewAccount: Boolean!

  """`true` if this account membership can add or canceled beneficiaries"""
  canManageBeneficiaries: Boolean!

  """`true` if this account membership can initiate payments"""
  canInitiatePayments: Boolean!

  """
  `true` if this account membership can invite, update, suspend or resume memberships
  """
  canManageAccountMembership: Boolean!

  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean!

  """status of the account membership"""
  statusInfo: AccountMembershipStatusInfo!

  """account of the account membership"""
  account: Account

  """Periodic Spending limit list"""
  spendingLimits: [SpendingLimit!]

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  version of the account membership started from '1' and incremented at every updates
  """
  version: String!

  """Residency address of the member"""
  residencyAddress: AddressInfo

  """Tax Identification Number of the member"""
  taxIdentificationNumber: String

  """List of accepted identification level"""
  acceptedIdentificationLevels: [IdentificationLevel]!

  """Recommended identification level"""
  recommendedIdentificationLevel: IdentificationLevel!

  """
  Indicate if the identity bound to the account membership has required identification level
  """
  hasRequiredIdentificationLevel: Boolean

  """Disabled date"""
  disabledAt: DateTime

  """account membership's cards"""
  cards(
    first: Int! = 50
    before: String
    after: String

    """When the list of elements needs to be ordered"""
    orderBy: CardOrderByInput

    """When the list of elements needs to be filtered"""
    filters: CardFiltersInput
  ): CardConnection!

  """Periodic Spending"""
  spending: Spending
}

"""when a user is binded with the error to the account membership"""
type AccountMembershipBindingUserErrorStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always BindingUserError for type AccountMembershipBindingUserErrorStatusInfo)
  """
  status: AccountMembershipStatus!

  """
  `true` if the first name of the user binded doesn't match with the invitation
  """
  firstNameMatchError: Boolean!

  """`true` if Swan hasn't verified the user's identity"""
  idVerifiedMatchError: Boolean!

  """
  `true` if the last name of the user binded doesn't match with the invitation
  """
  lastNameMatchError: Boolean!

  """
  `true` if the phone number of the user binded doesn't match with the invitation
  """
  phoneNumberMatchError: Boolean!

  """
  `true` if the birth date of the user binded doesn't match with the invitation
  """
  birthDateMatchError: Boolean!

  """restricted to a user"""
  restrictedTo: RestrictedTo!
}

type AccountMembershipCannotBeDisabledRejection implements Rejection {
  accountMembershipId: String!
  message: String!
}

type AccountMembershipCannotBeUpdatedRejection implements Rejection {
  id: String!
  message: String!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type AccountMembershipConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """AccountMembershipEdge list"""
  edges: [AccountMembershipEdge!]!
}

"""when the user has to consent to invite a new account membership"""
type AccountMembershipConsentPendingStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always ConsentPending for type AccountMembershipConsentPendingStatusInfo)
  """
  status: AccountMembershipStatus!

  """The consent required to invite this account membership"""
  consent: Consent!

  """restricted to a user"""
  restrictedTo: RestrictedTo!
}

"""when the account membership is disabled"""
type AccountMembershipDisabledStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always Disabled for type AccountMembershipDisabledStatusInfo)
  """
  status: AccountMembershipStatus!

  """reason why the account membership is disabled"""
  reason: String!
}

"""Implements the Relay Edge interface"""
type AccountMembershipEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The account membership"""
  node: AccountMembership!
}

"""when the account membership is enabled"""
type AccountMembershipEnabledStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always Enabled for type AccountMembershipEnabledStatusInfo)
  """
  status: AccountMembershipStatus!
}

"""
when a new account membership is invited and there is no user binded yet
"""
type AccountMembershipInvitationSentStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always InvitationSent for type AccountMembershipInvitationSentStatusInfo)
  """
  status: AccountMembershipStatus!

  """restricted to a user"""
  restrictedTo: RestrictedTo!
}

"""
Rejection returned when the Account Membership is not allowed to use an operation.
"""
type AccountMembershipNotAllowedRejection implements Rejection {
  message: String!
}

type AccountMembershipNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Rejection returned if invitation has not been sent to user yet"""
type AccountMembershipNotReadyToBeBoundRejection implements Rejection {
  id: String!
  message: String!
}

"""
Field we can use when ordering that can be applied when listing account memberships
"""
enum AccountMembershipOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing account memberships"""
input AccountMembershipOrderByInput {
  field: AccountMembershipOrderByFieldInput
  direction: OrderByDirection
}

"""
Filters that can be applied when listing accounts (Only applied in user context)
"""
input AccountMembershipsFilterInput {
  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean

  """Can the user initiate payments on this account"""
  canInitiatePayments: Boolean

  """Can the user manage account membership"""
  canManageAccountMembership: Boolean

  """Can the user manage beneficiaries"""
  canManageBeneficiaries: Boolean

  """Can the user view account"""
  canViewAccount: Boolean

  """Account memberships status/statuses we're looking for"""
  status: [AccountMembershipStatus!]

  """Filtered by email"""
  email: String

  """Filtered by first name"""
  firstName: String

  """Filtered by last name"""
  lastName: String

  """Searches email, first name, last name, and id"""
  search: String
}

"""List of account memberships permission"""
enum AccountMembershipsPermission {
  canInitiatePayments
  canManageAccountMembership
  canManageCards
  canManageBeneficiaries
  canViewAccount
}

"""AccountMembership enabled"""
enum AccountMembershipStatus {
  """when the consent to invite the account membership is pending"""
  ConsentPending

  """when the account membership is invited"""
  InvitationSent

  """when the user binded with errors to the account membership"""
  BindingUserError

  """when the account membership is enabled"""
  Enabled

  """when the account membership is suspended"""
  Suspended

  """when the account membership is disabled"""
  Disabled
}

"""here are the different account membership status:"""
interface AccountMembershipStatusInfo {
  """AccountMembership status"""
  status: AccountMembershipStatus!
}

"""when the account membership is suspended"""
type AccountMembershipSuspendedStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always Suspended for type AccountMembershipSuspendedStatusInfo)
  """
  status: AccountMembershipStatus!

  """reason why the account membership is suspended"""
  reason: String!
}

"""Thrown when an related account is not eligible to the feature"""
type AccountNotEligibleRejection implements Rejection {
  message: String!
}

"""
Rejection returned if the account was not found or if the user does not have the rights to know that the card exists
"""
type AccountNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Swan account number"""
scalar AccountNumber

"""Account Opened status information"""
type AccountOpenedStatus implements AccountStatusInfo {
  """Account status (always Opened for type AccountOpenedStatus)"""
  status: AccountStatus!
}

"""Fields that can be used when ordering accounts"""
enum AccountOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing accounts"""
input AccountOrderByInput {
  field: AccountOrderByFieldInput
  direction: OrderByDirection
}

"""
Filter that can be passed to get the received direct debit mandate in a specific data range
"""
input AccountReceivedDirectDebitMandateFiltersInput {
  """To filter on status values"""
  status: [ReceivedDirectDebitMandateStatus!]

  """To filter on scheme values"""
  scheme: [ReceivedDirectDebitMandateScheme!]
}

"""
Field we can use when ordering that can be applied when listing receives direct debit mandate results
"""
enum AccountReceivedDirectDebitOrderByFieldInput {
  createdAt
  updatedAt
}

"""
Order that can be applied when listing receives direct debit mandate results
"""
input AccountReceivedDirectDebitOrderByInput {
  field: AccountReceivedDirectDebitOrderByFieldInput
  direction: OrderByDirection
}

"""Filters that can be applied when listing Standing orders"""
input AccountStandingOrderFiltersInput {
  status: [StandingOrderStatus!]
}

"""
Field we can use when ordering that can be applied when listing standing order results
"""
enum AccountStandingOrderOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing standing order results"""
input AccountStandingOrderOrderByInput {
  field: AccountStandingOrderOrderByFieldInput
  direction: OrderByDirection
}

enum AccountStatus {
  """When the account is opened"""
  Opened

  """When the account is suspended"""
  Suspended

  """When the account is currently closing"""
  Closing

  """When the account is closed"""
  Closed
}

interface AccountStatusInfo {
  """Account status"""
  status: AccountStatus!
}

"""Account Suspended status information"""
type AccountSuspendedStatus implements AccountStatusInfo {
  """Account status (always Suspended for type AccountSuspendedStatus)"""
  status: AccountStatus!

  """
  Reason why the account is suspended
  @Deprecated
  """
  reason: String!

  """Reason why the account is currently suspend"""
  reasonInfo: SuspendAccountStatusReason!
}

"""Account Verification"""
interface AccountVerification {
  """Creation date of the account verification"""
  createdAt: DateTime!

  """Unique identifier of the Account Verification"""
  id: ID!

  """Account Verification Status Information"""
  statusInfo: AccountVerificationStatusInfo!

  """Last update date of the account verification"""
  updatedAt: DateTime!
}

"""
Rejection returned when the external account has already been rejected.

In such a case, contact Swan directly to resolve the situation for this specific account holder.
"""
type AccountVerificationAlreadyRejectedRejection implements Rejection {
  message: String!
}

"""Account Verification Status"""
enum AccountVerificationStatus {
  """
  We are waiting for the end user to send a credit transfer from his external iban to any Swan owned iban
  """
  PendingVerification

  """
  We could not automatically match the external iban based on last received transfer.
  Manuel review process is underway
  """
  PendingReview

  """Account has been verified"""
  Verified

  """Account verification has been rejected"""
  Rejected
}

"""Account Verification Status Information"""
interface AccountVerificationStatusInfo {
  """Account verification status"""
  status: AccountVerificationStatus!
}

"""
Rejection returned when the Account Verification is not in the expected status
"""
type AccountVerificationWrongStatusRejection implements Rejection {
  message: String!
}

input ActivatePhysicalCardInput {
  """Unique identifier present on physical card"""
  identifier: String!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ActivatePhysicalCardPayload = ActivatePhysicalCardSuccessPayload | BadAccountStatusRejection | PhysicalCardNotFoundRejection | PhysicalCardWrongStatusRejection | CannotActivatePhysicalCardRejection | ForbiddenRejection | CardNotFoundRejection | UserNotCardHolderRejection | ValidationRejection

type ActivatePhysicalCardSuccessPayload {
  """The consent required to activate this physical card"""
  consent: Consent!

  """The physicalCard to activate"""
  physicalCard: PhysicalCard!
}

type ActiveMerchantPaymentLinkStatusInfo implements MerchantPaymentLinkStatusInfo {
  status: MerchantPaymentLinkStatus!

  """
  The date when the payment link expires.
  The payment link expires 24 hours after it was created.
  """
  expiresAt: DateTime!
}

"""Inputs to add a new account membership"""
input AddAccountMembershipInput {
  """Unique identifier of a given account"""
  accountId: ID!

  """Email address"""
  email: String!

  """Restricted to a user if necessary"""
  restrictedTo: RestrictedToInput!

  """
  `true` if this account membership can view account balances and transactions history
  """
  canViewAccount: Boolean!

  """`true` if this account membership can add or canceled beneficiaries"""
  canManageBeneficiaries: Boolean!

  """`true` if this account membership can initiate payments"""
  canInitiatePayments: Boolean!

  """
  `true` if this account membership can invite, update, suspend or resume account membership
  """
  canManageAccountMembership: Boolean!

  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Residency address of the member to be added"""
  residencyAddress: ResidencyAddressInput

  """Tax Identification Number of the user added"""
  taxIdentificationNumber: String
}

union AddAccountMembershipPayload = AddAccountMembershipSuccessPayload | BadAccountStatusRejection | ForbiddenRejection | InvalidPhoneNumberRejection | PermissionCannotBeGrantedRejection | ValidationRejection

"""Inputs to add a new account membership"""
input AddAccountMembershipsInput {
  """Unique identifier of a given account"""
  accountId: ID!

  """Memberships to add to the account"""
  memberships: [MembershipInfoInput!]!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union AddAccountMembershipsPayload = AddAccountMembershipsSuccessPayload | BadAccountStatusRejection | ForbiddenRejection | InvalidPhoneNumberRejection | PermissionCannotBeGrantedRejection | TooManyItemsRejection | ValidationRejection

type AddAccountMembershipsSuccessPayload {
  accountMemberships: [AccountMembership!]!
}

type AddAccountMembershipSuccessPayload {
  accountMembership: AccountMembership!
}

"""Inputs to add a new card"""
input AddCardInput {
  """Unique identifier of a given account membership"""
  accountMembershipId: ID!

  """Card expiration date  if `null` it does not have an expiration date"""
  cardContractExpiryDate: DateTime

  """`true` if this card allows cash withdrawals"""
  withdrawal: Boolean!

  """`true` if this card allows payments outside of the country"""
  international: Boolean!

  """
  `true` if this card allows transactions outside of the card's main currency
  """
  nonMainCurrencyTransactions: Boolean!

  """`true` if this card allows transactions at eCommerce sites"""
  eCommerce: Boolean!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Card name"""
  name: String

  """`true` to show the card confidential information in the same request"""
  viewCardNumber: Boolean

  """The id of the card product to use to create the new card."""
  cardProductId: ID

  """Spending limit"""
  spendingLimit: SpendingLimitInput
}

union AddCardPayload = AddCardSuccessPayload | AccountMembershipNotAllowedRejection | BadAccountStatusRejection | CardProductDisabledRejection | CardProductSuspendedRejection | EnabledCardDesignNotFoundRejection | ForbiddenRejection | MissingMandatoryFieldRejection | ValidationRejection

"""Input to add a new cards"""
input AddCardsInput {
  """The configuration of all the cards you want to add"""
  cards: [CardConfigInput!]!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """The id of the card product to use to create the new cards."""
  cardProductId: ID
}

union AddCardsPayload = AddCardsSuccessPayload | AddingCardsToDifferentAccountsRejection | BadAccountStatusRejection | TooManyItemsRejection | AccountMembershipNotAllowedRejection | CardProductSuspendedRejection | CardProductNotApplicableToPhysicalCardsRejection | CardProductDisabledRejection | EnabledCardDesignNotFoundRejection | MissingMandatoryFieldRejection | ValidationRejection

type AddCardsSuccessPayload {
  """The newly created cards"""
  cards: [Card!]!
}

type AddCardSuccessPayload {
  """The new card added"""
  card: Card!
}

"""Input to add a new cards"""
input AddCardsWithGroupDeliveryInput {
  """Address to deliver the printed physical cards"""
  groupDeliveryAddress: CompleteAddressWithContactInput!

  """The configuration of all the cards you want to add"""
  cards: [CardConfigWithGroupDeliveryInput!]!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """The id of the card product to use to create the new cards."""
  cardProductId: ID
}

union AddCardsWithGroupDeliveryPayload = AddCardsWithGroupDeliverySuccessPayload | AddingCardsToDifferentAccountsRejection | BadAccountStatusRejection | TooManyItemsRejection | AccountMembershipNotAllowedRejection | CardProductSuspendedRejection | CardProductNotApplicableToPhysicalCardsRejection | CardProductDisabledRejection | EnabledCardDesignNotFoundRejection | MissingMandatoryFieldRejection | ValidationRejection

type AddCardsWithGroupDeliverySuccessPayload {
  """The newly created cards"""
  cards: [Card!]!
}

"""Inputs to add a new digital card"""
input AddDigitalCardInput {
  """Unique identifier of a card"""
  cardId: ID!

  """Provider for which to generate a digitalCard"""
  walletProvider: WalletProviderType!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

"""Payload returned on mutation completion"""
union AddDigitalCardPayload = AddDigitalCardSuccessPayload | CardNotFoundRejection | CardCanNotBeDigitalizedRejection | ApplePayNotAllowedForProjectRejection | BadAccountStatusRejection | AccountMembershipNotAllowedRejection | UserNotCardHolderRejection | CardProductDisabledRejection | EnabledCardDesignNotFoundRejection | MissingMandatoryFieldRejection | ValidationRejection

type AddDigitalCardSuccessPayload {
  """
  Digital Card used for ApplePay or GooglePay
  
  The consent can be found in the digital card status information.
  """
  digitalCard: PendingDigitalCard!
}

"""Input to add a Direct Debit Funding Source"""
input AddDirectDebitFundingSourceInput {
  """Scheme of the underlying payment mandate"""
  scheme: SEPADirectDebitScheme!

  """
  Id of the account on which to create a funding source.
  Money will be funded to this account when an `initiateFundingRequest` is done using this funding source
  """
  accountId: ID!

  """
  IBAN to use in the direct debit transaction that will be triggered when funding the account.
  Money will be debited from this IBAN when an `initiateFundingRequest` is done using this funding source
  """
  iban: IBAN!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Name to give to this funding source"""
  name: String
}

"""Add Direct Debit Funding Source Payload"""
union AddDirectDebitFundingSourcePayload = AddDirectDebitFundingSourceSuccessPayload | ForbiddenRejection | NotFoundRejection | AccountVerificationAlreadyRejectedRejection | IBANNotReachableRejection | ValidationRejection

"""Add Direct Debit Funding Source Success Payload"""
type AddDirectDebitFundingSourceSuccessPayload {
  """The created funding source"""
  fundingSource: FundingSource!
}

input AddExternalAccountBalanceInput {
  """Unique identifier of a given external account"""
  externalAccountId: ID!

  """Amount of the balance"""
  amount: AmountInput!

  """Type of the balance"""
  type: ExternalAccountBalanceType!

  """Last changed Date"""
  lastChangedAt: DateTime!
}

union AddExternalAccountBalancePayload = AddExternalAccountBalanceSuccessPayload | ValidationRejection | ExternalAccountBalanceAlreadyExistsRejection | ForbiddenRejection

type AddExternalAccountBalanceSuccessPayload {
  """The added external balance"""
  externalAccountBalance: ExternalAccountBalance!
}

input AddExternalAccountInput {
  """Unique identifier of a given account holder"""
  accountHolderId: ID!

  """External account identifier"""
  externalId: String!

  """Name of the account"""
  name: String

  """Type of account"""
  cashAccountType: CashAccountType!

  """Bank Identifier Code"""
  BIC: BIC!

  """International Bank Account Number"""
  IBAN: IBAN!

  """Currency"""
  currency: Currency!

  """Account Holder name"""
  holderName: String!

  """Country"""
  country: CCA3!

  """Original Created date"""
  originalCreatedAt: DateTime!

  """Usage information of the account"""
  usage: ExternalAccountUsage!

  """Source of the account information"""
  source: String!

  """Balances"""
  balances: [ExternalAccountBalanceInput!]
}

union AddExternalAccountPayload = AddExternalAccountSuccessPayload | ValidationRejection | IbanValidationRejection | ExternalAccountAlreadyExistsRejection | ForbiddenRejection

type AddExternalAccountSuccessPayload {
  """The added external account"""
  externalAccount: ExternalAccount!
}

"""Inputs to add a new request for funding limit settings change"""
input AddFundingLimitSettingsChangeRequestInput {
  """Requested amount settings for the instant funding limit"""
  instantFundingLimit: FundingLimitAmountInput!

  """Requested amount settings for the funding limit"""
  fundingLimit: FundingLimitAmountInput!

  """Unique identifier of a given account holder"""
  accountHolderId: ID!
}

"""Payload returned on mutation completion"""
union AddFundingLimitSettingsChangeRequestPayload = AddFundingLimitSettingsChangeRequestSuccessPayload | FundingLimitSettingsChangeRequestBadAmountRejection | AccountHolderNotFoundRejection | ForbiddenRejection | ValidationRejection

"""Add Funding Limit Settings Change Request Success Payload"""
type AddFundingLimitSettingsChangeRequestSuccessPayload {
  """The new request for funding limit settings change"""
  fundingLimitSettingsChangeRequest: FundingLimitSettingsChangeRequest!
}

"""
Rejection returned if the attempting to add cards to different accounts.
"""
type AddingCardsToDifferentAccountsRejection implements Rejection {
  message: String!
}

"""Inputs to add an Internal Direct Debit Payment Mandate"""
input AddInternalDirectDebitPaymentMandateInput {
  """The ID of the concerned merchant payment method"""
  paymentMethodId: ID!

  """Determines whether the payment mandate is a one-off or recurring"""
  sequence: InternalDirectDebitSequence

  """Reference of the payment mandate"""
  reference: String

  """Language that will be used to produce the mandate PDF document"""
  language: MandateLanguage

  """ID of the Swan account of the debtor"""
  debtorAccountId: ID!

  """Signature date of the Internal Direct Debit mandate"""
  signatureDate: Date

  """Custom name of the Internal Direct Debit mandate"""
  name: String
}

"""Union type return by the addInternalDirectDebitPaymentMandate mutation"""
union AddInternalDirectDebitPaymentMandatePayload = AddInternalDirectDebitPaymentMandateSuccessPayload | ForbiddenRejection | NotFoundRejection | DebtorAccountNotAllowedRejection | DebtorAccountClosedRejection | SchemeWrongRejection | PaymentMandateReferenceAlreadyUsedRejection | InternalErrorRejection

"""
Return type in case of a successful response of the addInternalDirectDebitPaymentMandate mutation
"""
type AddInternalDirectDebitPaymentMandateSuccessPayload {
  paymentMandate: InternalPaymentDirectDebitMandate!
}

"""Input to add a Merchant Profile"""
input AddMerchantProfileInput {
  """ID of the Swan account which the merchantProfile is associated to"""
  accountId: ID!

  """
  Business name of the merchant, i.e. name that will be displayed on debtors' bank statements
  """
  merchantName: String!

  """Url of the merchant's website"""
  merchantWebsite: String

  """base64 encoded merchant's logo"""
  merchantLogo: String

  """
  Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
  """
  productType: ProductType!

  """Expected annual activity volumes for all payment methods."""
  expectedMonthlyPaymentVolume: AmountInput!

  """expected average basket value."""
  expectedAverageBasket: AmountInput!
}

"""Add Merchant Profile Payload"""
union AddMerchantProfilePayload = AddMerchantProfileSuccessPayload | ForbiddenRejection | AccountNotFoundRejection | InternalErrorRejection

"""Add Merchant Profile Success Payload"""
type AddMerchantProfileSuccessPayload {
  """Merchant Profile"""
  merchantProfile: MerchantProfile!
}

input AddOrUpdateExternalAccountBalanceInput {
  """Unique identifier of a given external account"""
  externalAccountId: ID!

  """Amount of the balance"""
  amount: AmountInput!

  """Type of the balance"""
  type: ExternalAccountBalanceType!

  """Last changed Date"""
  lastChangedAt: DateTime!
}

union AddOrUpdateExternalAccountBalancePayload = AddOrUpdateExternalAccountBalanceSuccessPayload | ValidationRejection | ForbiddenRejection

type AddOrUpdateExternalAccountBalanceSuccessPayload {
  """The added external balance"""
  externalAccountBalance: ExternalAccountBalance!
}

"""Inputs to add a received internal direct debit mandate B2b."""
input AddReceivedInternalDirectDebitB2bMandateInput {
  """The associated Payment Mandate ID"""
  paymentMandateId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """
  Label that will be displayed along with this received direct debit mandate in the web banking
  """
  name: String
}

"""
Union type return by the addReceivedInternalDirectDebitB2bMandate mutation
"""
union AddReceivedInternalDirectDebitB2bMandatePayload = AddReceivedInternalDirectDebitB2bMandateSuccessPayload | ForbiddenRejection | PaymentMandateMandateNotFoundRejection | AccountHolderTypeIndividualRejection

"""
Return type in case of a successful response of the addReceivedInternalDirectDebitB2bMandate mutation
"""
type AddReceivedInternalDirectDebitB2bMandateSuccessPayload {
  """The received direct debit mandate is added"""
  receivedDirectDebitMandate: ReceivedDirectDebitMandate!
}

"""Inputs to add a received sepa direct debit mandate B2b."""
input AddReceivedSepaDirectDebitB2bMandateInput {
  """The unique identifier of the received direct debit mandate"""
  mandateReference: String!

  """The Sepa Creditor Identifier of the creditor"""
  creditorIdentifier: String!

  """The name of the creditor"""
  creditorName: String!

  """The Swan Iban of the debtor"""
  iban: String!

  """
  Label that will be displayed along with this received direct debit mandate in the web banking
  """
  name: String

  """Sequence of the mandate"""
  sequence: SEPAReceivedDirectDebitMandateSequence!

  """Date of signature of the mandate"""
  signatureDate: Date

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

"""Union type return by the addReceivedSepaDirectDebitB2bMandate mutation"""
union AddReceivedSepaDirectDebitB2bMandatePayload = AddReceivedSepaDirectDebitB2bMandateSuccessPayload | ForbiddenRejection | AccountNotFoundRejection | AccountHolderTypeIndividualRejection

"""
Return type in case of a successful response of the addReceivedSepaDirectDebitB2bMandate mutation
"""
type AddReceivedSepaDirectDebitB2bMandateSuccessPayload {
  """The received direct debit mandate is added"""
  receivedDirectDebitMandate: ReceivedDirectDebitMandate!
}

"""Address Information"""
type Address {
  """address line 1"""
  addressLine1: String

  """addressLine2"""
  addressLine2: String

  """city"""
  city: String

  """postal code (max 10 characters)"""
  postalCode: String

  """state"""
  state: String

  """country"""
  country: CCA3
}

"""Address information."""
type AddressInfo {
  """Address line 1."""
  addressLine1: String

  """Address line 2."""
  addressLine2: String

  """City."""
  city: String

  """Postal code."""
  postalCode: String

  """State."""
  state: String

  """Country."""
  country: CCA3
}

"""Address"""
type AddressInformation {
  """Address"""
  addressLine1: String!

  """Address"""
  addressLine2: String

  """City"""
  city: String!

  """Country"""
  country: CCA3!

  """Postal code"""
  postalCode: String!

  """State"""
  state: String
}

"""Address"""
input AddressInformationInput {
  """Address"""
  addressLine1: String!

  """Address"""
  addressLine2: String

  """City"""
  city: String!

  """Country"""
  country: CCA3!

  """Postal code"""
  postalCode: String!

  """State"""
  state: String
}

"""Address Information"""
input AddressInput {
  """address line 1 (max 100 characters)"""
  addressLine1: String

  """address line 2 (max 100 characters)"""
  addressLine2: String

  """city (max 100 characters)"""
  city: String

  """postal code (max 10 characters)"""
  postalCode: String

  """state (max 100 characters)"""
  state: String

  """country code"""
  country: CCA3!
}

input AddSepaDirectDebitPaymentMandateInput {
  """
  Specifies payment ID of a SEPA Direct Debit CORE or B2B payment method.
  """
  paymentMethodId: ID!

  """Determines whether the payment mandate is a one-off or recurring"""
  sequence: DirectDebitSequence!

  """Unique reference of the SEPA Direct Debit Payment Mandate."""
  reference: String

  """Language that will be used to produce the mandate PDF document"""
  language: MandateLanguage!

  """Signature date of the SEPA Direct Debit Payment Mandate"""
  signatureDate: Date!

  """Debtor of the SEPA Direct Debit Payment Mandate"""
  debtor: SepaPaymentMandateDebtorInput!

  """Custom name of the SEPA Direct Debit Payment Mandate"""
  name: String
}

"""Union type return by the addSepaDirectDebitPaymentMandate mutation"""
union AddSepaDirectDebitPaymentMandatePayload = AddSepaDirectDebitPaymentMandateSuccessPayload | ForbiddenRejection | NotFoundRejection | DebtorAccountNotAllowedRejection | DebtorAccountClosedRejection | SchemeWrongRejection | PaymentMandateReferenceAlreadyUsedRejection | ValidationRejection | PaymentMethodNotCompatibleRejection | InternalErrorRejection

"""
Return type in case of a successful response of the addSepaDirectDebitPaymentMandate mutation
"""
type AddSepaDirectDebitPaymentMandateSuccessPayload {
  paymentMandate: SEPAPaymentDirectDebitMandate!
}

"""Inputs to add a new card"""
input AddSingleUseVirtualCardInput {
  """Unique identifier of a given account membership"""
  accountMembershipId: ID!

  """Spending limit"""
  spendingLimit: SpendingLimitInput!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Card name"""
  name: String

  """`true` to show the card confidential information in the same request"""
  viewCardNumber: Boolean

  """The id of the card product to use to create the new card."""
  cardProductId: ID
}

union AddSingleUseVirtualCardPayload = AddSingleUseVirtualCardSuccessForUserPayload | AddSingleUseVirtualCardSuccessForProjectOwnerPayload | BadAccountStatusRejection | AccountMembershipNotAllowedRejection | CardProductSuspendedRejection | CardProductDisabledRejection | EnabledCardDesignNotFoundRejection | MissingMandatoryFieldRejection | ValidationRejection

"""Input to add a new single-use virtual cards"""
input AddSingleUseVirtualCardsInput {
  """The configuration of all the cards you want to add"""
  cards: [SingleUseVirtualCardConfigInput!]!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """The id of the card product to use to create the new cards."""
  cardProductId: ID
}

union AddSingleUseVirtualCardsPayload = AddSingleUseVirtualCardsSuccessPayload | AddingCardsToDifferentAccountsRejection | TooManyItemsRejection | BadAccountStatusRejection | AccountMembershipNotAllowedRejection | CardProductSuspendedRejection | CardProductDisabledRejection | EnabledCardDesignNotFoundRejection | MissingMandatoryFieldRejection | ValidationRejection

type AddSingleUseVirtualCardsSuccessPayload {
  """The newly created single use virtual cards"""
  cards: [Card!]!
}

type AddSingleUseVirtualCardSuccessForProjectOwnerPayload {
  """The new card added"""
  card: Card!

  """Card confidential"""
  confidential: CardConfidential!
}

type AddSingleUseVirtualCardSuccessForUserPayload {
  """The new card added"""
  card: Card!
}

union AddVirtualIbanEntryPayload = AddVirtualIbanEntrySuccessPayload | AccountNotFoundRejection | BadAccountStatusRejection | ForbiddenRejection | ValidationRejection

type AddVirtualIbanEntrySuccessPayload {
  virtualIbanEntry: VirtualIBANEntry!
}

"""Input to Add a Virtual IBAN"""
input AddVirtualIbanInput {
  """Unique identifier of a given account"""
  accountId: ID!
}

type AllowedValue {
  key: String!
  name: String!
}

"""Input to Allow SDD"""
input AllowSddInput {
  """Unique identifier of a given account"""
  accountId: ID!
}

union AllowSddPayload = AllowSddSuccessPayload | AccountNotFoundRejection | ValidationRejection

type AllowSddSuccessPayload {
  account: Account!
}

input AllowSddVirtualIbanEntryInput {
  ibanEntryId: ID!
}

union AllowSddVirtualIbanEntryPayload = AllowSddVirtualIbanEntrySuccessPayload | BadAccountStatusRejection | ValidationRejection

type AllowSddVirtualIbanEntrySuccessPayload {
  virtualIbanEntry: VirtualIBANEntry!
}

"""Rejection returned if card already has a valid Physical Card"""
type AlreadyValidPhysicalCardRejection implements Rejection {
  message: String!
}

enum AmlRiskLevel {
  Low
  Medium
  High
  TooHigh
}

"""Amount with its currency"""
type Amount {
  """currency"""
  currency: Currency!

  """value of the amount"""
  value: AmountValue!
}

"""Amount with its currency"""
input AmountInput {
  """value of the amount"""
  value: AmountValue!

  """currency"""
  currency: Currency!
}

"""
The amount given with fractional digits, where fractions must be compliant to the currency definition. Up to 14 significant figures. Negative amounts are signed by minus. The decimal separator is a dot.

Example: Valid representations for EUR with up to two decimals are:

1056
5768.2
-1.50
5877.78
"""
scalar AmountValue

"""Rejection return if the project is not configured to allow Apple Pay"""
type ApplePayNotAllowedForProjectRejection implements Rejection {
  id: String!
  message: String!
}

"""Approved Funding Limit"""
type ApprovedFundingLimit {
  """Requested amount settings for the instant funding limit"""
  instantFundingLimit: FundingLimitAmount!

  """Requested amount settings for the funding limit"""
  fundingLimit: FundingLimitAmount!
}

scalar AuditId

"""A method used to authenticate a user"""
type Authenticator {
  """
  Operating System parsed from the user agent (eg AIX, Amiga OS, Android, Arch, Bada, BeOS, BlackBerry, ...)
  """
  os: String

  """
  Device Brand parsed from the user agent (eg: Acer, Alcatel, Amazon, Apple, ...)
  """
  brand: String

  """Device Model parsed from the user agent"""
  model: String

  """Type of authenticator"""
  type: AuthenticatorType!

  """Raw user agent"""
  userAgent: String

  """Accept-Language header used during registration"""
  acceptLanguage: String
}

enum AuthenticatorType {
  """A Swan web authenticator"""
  SwanWeb

  """Deprecated: swan authenticator"""
  Swan
}

scalar AuthorizationId

"""Type of the card authorization transaction"""
enum AuthorizationType {
  """
  Classic authorization, nominal use-case, in order to hold the amount in the available balance that will be debited in the following days
  """
  Classic

  """
  Pre-authorization.
  Usually an authorization in order to hold the amount in the available balance that will be updated in a second time with the final amount (gaz station, car rent, etc)
  """
  PreAuthorization

  """
  Usually an authorization used by a merchant to verify if the card exists and can successfully receive a future authorization
  """
  DataRequest
}

"""Rejection returned if the status account is not valid"""
type BadAccountStatusRejection implements Rejection {
  id: String!
  message: String!
}

type BadRequestRejection implements Rejection {
  message: String!
}

"""Balance Information"""
type Balance {
  """Matching account for this balance"""
  account: Account!

  """A list of balances regarding an account."""
  balances: AccountBalances

  """Last SCT OUT transaction"""
  lastSctOut: SEPACreditTransferTransaction

  """Last SCT IN transaction"""
  lastSctIn: SEPACreditTransferTransaction
}

"""Information about the banking institution"""
type Bank {
  """Bank name"""
  name: String!

  """Bank Branch Code"""
  branch: String

  """Bank local identifier (unique by country)"""
  nationalId: String!

  """Bank BIC code"""
  bic: BIC!

  """Bank address (We might only be able to fill in the country)"""
  address: Address!
}

"""
*SOON TO BE DEPRECATED*
Beneficiary
"""
interface Beneficiary {
  """unique identifier of a beneficiary"""
  id: ID

  """full name of the beneficiary"""
  name: String!

  """
  `true` if this new beneficiary is the account holder himself in an other financial institution.
  """
  isMyOwnIban: Boolean!
}

"""Bank Identifier Code"""
scalar BIC

input BindAccountMembershipInput {
  accountMembershipId: ID!
}

union BindAccountMembershipPayload = BindAccountMembershipSuccessPayload | BadAccountStatusRejection | AccountMembershipNotFoundRejection | AccountMembershipNotReadyToBeBoundRejection | IdentityAlreadyBindToAccountMembershipRejection | RestrictedToUserRejection | ValidationRejection

type BindAccountMembershipSuccessPayload {
  accountMembership: AccountMembership!
}

"""Booked transaction status information"""
type BookedTransactionStatusInfo implements TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!

  """
  The Date when the transaction is posted to an account on the Swan books.
  """
  bookingDate: DateTime!

  """The Date when the transaction is considered effective in accounting"""
  valueDate: DateTime!
}

"""Business activity."""
enum BusinessActivity {
  AdministrativeServices
  Agriculture
  Arts
  BusinessAndRetail
  Construction
  Education
  ElectricalDistributionAndWaterSupply
  FinancialAndInsuranceOperations
  Health
  Housekeeping
  InformationAndCommunication
  LodgingAndFoodServices
  ManufacturingAndMining
  Other
  PublicAdministration
  RealEstate
  ScientificActivities
  Transportation
}

"""Inputs to cancel a card"""
input CancelCardInput {
  """Unique identifier of a card"""
  cardId: ID!
}

union CancelCardPayload = CancelCardSuccessPayload | AccountMembershipNotAllowedRejection | CardNotFoundRejection | ForbiddenRejection | ValidationRejection

type CancelCardSuccessPayload {
  """The canceled card """
  card: Card!
}

"""Input of the `cancelConsent` mutation"""
input CancelConsentInput {
  consentId: ID!
}

"""Payload of the `cancelConsent` mutation"""
union CancelConsentPayload = CancelConsentSuccessPayload | ConsentNotFoundRejection | NotReachableConsentStatusRejection

"""Success payload of the `cancelConsent` mutation"""
type CancelConsentSuccessPayload {
  consent: Consent!
}

"""Inputs to cancel a digital card"""
input CancelDigitalCardInput {
  """Unique identifier of a digital card"""
  digitalCardId: ID!
}

union CancelDigitalCardPayload = CancelDigitalCardSuccessPayload | AccountMembershipNotAllowedRejection | CardNotFoundRejection | DigitalCardNotFoundRejection | ForbiddenRejection | ValidationRejection

type CancelDigitalCardSuccessPayload {
  """The canceled digital card"""
  digitalCard: DigitalCard!
}

"""Funding Source Canceled Reason"""
enum CanceledFundingSourceReason {
  """User has canceled his funding source"""
  UserCanceled

  """Underlying mandate has expired"""
  MandateExpired

  """Underlying mandate has been canceled"""
  MandateCanceled
}

"""Funding Source Canceled status information"""
type CanceledFundingSourceStatusInfo implements FundingSourceStatusInfo {
  """Funding Source Canceled status"""
  status: FundingSourceStatus!

  """Date at which the funding source was enabled"""
  enabledAt: Date

  """Date at which the funding source was canceled"""
  canceledAt: Date!

  """Reason code of the cancellation"""
  reasonCode: CanceledFundingSourceReason!
}

"""
Describes an identification level for the process associated to this identification that has been cancelled by the end-user
"""
type CanceledIdentificationLevelStatusInfo {
  """Always set to `Cancelled`"""
  status: SwanIdentificationStatus!
}

"""CanceledMerchantPaymentMethodStatusInfo"""
type CanceledMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method canceled date"""
  canceledAt: Date!
}

"""CanceledMerchantProfileStatusInfo"""
type CanceledMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  canceledAt: Date!
  enabledAt: Date
}

"""Canceled transaction status information"""
type CanceledTransactionStatusInfo implements TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!

  """The date when the transaction was canceled"""
  canceledDate: DateTime
}

"""Cancel Funding Source Input"""
input CancelFundingSourceInput {
  """ID of the funding source to cancel"""
  id: ID!
}

"""Cancel Funding Source Payload"""
union CancelFundingSourcePayload = CancelFundingSourceSuccessPayload | ForbiddenRejection | NotFoundRejection

"""Cancel Funding Source Success Payload"""
type CancelFundingSourceSuccessPayload {
  """Canceled Funding Source"""
  fundingSource: FundingSource
}

"""Inputs to cancel a physical card"""
input CancelPhysicalCardInput {
  """Unique identifier of a card"""
  cardId: ID!

  """Reason why the physical card is canceled"""
  reason: CancelPhysicalCardReason!
}

union CancelPhysicalCardPayload = CancelPhysicalCardSuccessPayload | AccountMembershipNotAllowedRejection | CardNotFoundRejection | ForbiddenRejection | PhysicalCardNotFoundRejection | ValidationRejection

"""reason why the physical card is canceled"""
enum CancelPhysicalCardReason {
  """When the card holder never received the card"""
  NonReceived

  """When the card has been stolen"""
  Lost

  """When the card has been stolen"""
  Stolen

  """When the card doesn't work anymore"""
  Defected

  """When the card holder wants to block his card"""
  Blocked
}

type CancelPhysicalCardSuccessPayload {
  """The canceled physical card """
  physicalCard: PhysicalCard!
}

input CancelStandingOrderInput {
  standingOrderId: String!
}

union CancelStandingOrderPayload = CancelStandingOrderSuccessPayload | ForbiddenRejection | InternalErrorRejection | StandingOrderNotFoundRejection

type CancelStandingOrderSuccessPayload {
  standingOrder: StandingOrder!
}

"""Cancel transaction"""
input CancelTransactionInput {
  """transaction ID to cancel"""
  transactionId: ID!
}

union CancelTransactionPayload = CancelTransactionSuccessPayload | ForbiddenRejection

type CancelTransactionSuccessPayload {
  message: String!
}

input CancelVirtualIbanEntryInput {
  virtualIbanEntryId: ID!
}

union CancelVirtualIbanEntryPayload = CancelVirtualIbanEntrySuccessPayload | AccountNotFoundRejection | BadAccountStatusRejection | InternalErrorRejection | ValidationRejection

type CancelVirtualIbanEntrySuccessPayload {
  virtualIbanEntry: VirtualIBANEntry!
}

"""Rejection returned when the Physical Card cannot be activated"""
type CannotActivatePhysicalCardRejection implements Rejection {
  message: String!
  identifier: String!
}

"""Capital deposit case for a company."""
type CapitalDepositCase {
  """Unique identifier of a capital deposit case."""
  id: String!

  """List of the companys shareholders."""
  shareholders: [Shareholder!]!

  """Amount of the capital deposit."""
  totalCapitalDepositAmount: Amount!

  """Name of the company."""
  companyName: String!

  """Onboarding information of the company."""
  companyOnboarding: Onboarding

  """Unique identifier of the company account."""
  companyAccountId: String

  """Status of the capital deposit case."""
  status: CapitalDepositCaseStatus!

  """Documents to provide to fulfill the capital deposit case."""
  documents: [CapitalDepositDocument!]!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of elements ([Learn More](https://docs.swan.io/api/pagination))
"""
type CapitalDepositCaseConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """CapitalDepositCaseEdge list"""
  edges: [CapitalDepositCaseEdge!]!
}

"""Implements the Relay Edge interface"""
type CapitalDepositCaseEdge implements Edge {
  """
  Opaque identifier pointing to this capital deposit case node in the pagination mechanism
  """
  cursor: String!

  """The CapitalDepositCase"""
  node: CapitalDepositCase!
}

"""Filters that can be applied when listing capital deposit cases"""
input CapitalDepositCaseFiltersInput {
  """
  Searches company shareholder name, individual shareholder first name, last name, and id
  """
  search: String

  """Status we want to filter on"""
  status: [CapitalDepositCaseStatus!]
}

"""
Field we can use when ordering that can be applied when listing capital deposit cases
"""
enum CapitalDepositCaseOrderByFieldInput {
  id
  createdAt
  updatedAt
}

"""Order that can be applied when listing capital deposit cases"""
input CapitalDepositCaseOrderByInput {
  field: CapitalDepositCaseOrderByFieldInput
  direction: OrderByDirection
}

"""Status of a capital deposit case."""
enum CapitalDepositCaseStatus {
  """
  Technical state when the mutation to create a new capital deposit case is called.
  """
  Initiated

  """
  A new capital deposit case is created and Swan is waiting for the required information to be provided and each shareholder to wire their share of share capital.
  """
  WaitingForRequirements

  """
  Swan is waiting for the notary to provide the Share Deposit Certificate.
  """
  WaitingForShareDepositCertificate

  """Swan is waiting for you to provide the Register Extract."""
  WaitingForRegisterExtract

  """
  Swan is waiting for the notary to wire the share capital on the account of the company being registered.
  """
  WaitingForNotaryTransfer

  """The capital deposit case is completed."""
  Completed
}

"""Document provided for a capital deposit case."""
type CapitalDepositDocument {
  """Unique identifier of a document."""
  id: String!

  """Type of the document."""
  type: CapitalDepositDocumentType!

  """
  Url to download the document, null if it has not already been uploaded.
  """
  downloadUrl: String

  """Date when the last version of the document has been uploaded."""
  uploadedAt: Date

  """Status of the document."""
  status: CapitalDepositDocumentStatus! @deprecated(reason: "use statusInfo.status")

  """Status info of the document."""
  statusInfo: CapitalDepositDocumentStatusInfo!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Information about capital deposit case."""
  relatedCapitalDepositCase: CapitalDepositCase

  """Information about shareholder."""
  relatedShareholder: Shareholder
}

"""
Rejection returned if the document from a capital deposit case cannot be uploaded in its context
@deprecated(reason: "use `CapitalDepositDocumentCanNotBeUploadedRejection` instead")
"""
type CapitalDepositDocumentCanNotBeUploaded implements Rejection {
  id: String!
  message: String!
}

"""
Rejection returned if the document from a capital deposit case cannot be uploaded in its context
"""
type CapitalDepositDocumentCanNotBeUploadedRejection implements Rejection {
  id: String!
  message: String!
}

"""Capital Deposit Document with Pending status"""
type CapitalDepositDocumentPendingStatusInfo implements CapitalDepositDocumentStatusInfo {
  """Pending"""
  status: CapitalDepositDocumentStatus!
}

"""Capital Deposit Document with Refused status"""
type CapitalDepositDocumentRefusedStatusInfo implements CapitalDepositDocumentStatusInfo {
  """Refused"""
  status: CapitalDepositDocumentStatus!

  """Reason for the rejection."""
  reasonCode: DocumentReasonCode!
}

"""Status of the Capital Deposit Case"""
enum CapitalDepositDocumentStatus {
  """Document is not uploaded yet."""
  Pending

  """Document has been uploaded but not verified by Swan yet."""
  Uploaded

  """Document has been uploaded and verified by Swan."""
  Validated

  """Document has been refused by Swan, it must be uploaded again."""
  Refused
}

"""Status info of the document."""
interface CapitalDepositDocumentStatusInfo {
  """Status of the document."""
  status: CapitalDepositDocumentStatus!
}

"""Type of the document."""
enum CapitalDepositDocumentType {
  """Legal document required for companys formation."""
  ArticlesOfIncorporation

  """Commercial registry extract issued within the last 3 months."""
  RegisterExtract

  """Can be either passport, national id card or resident permit."""
  ProofOfIdentity

  """
  Document submitted to your tax bureau at the end of the last business period.
  """
  CorporateIncomeTaxReturn

  """
  Can be a utility bill (water, electricity or gas), a telephone bill or a rental receipt. The document must have been issued within the last 3 months.
  """
  ProofOfIndividualAddress

  """
  Lease agreement in the name of the business or Proof of Individual Address if the company is hosted by one of the legal representative.
  """
  CompanyLeaseAgreement

  """
  Created by the Notary, it certifies the capital of the company to have been deposited with the appropriate share for each shareholder.
  """
  CapitalShareDepositCertificate

  """Signed power of attorney document to give the power to act on behalf."""
  PowerOfAttorney
}

"""Capital Deposit Document with Uploaded status"""
type CapitalDepositDocumentUploadedStatusInfo implements CapitalDepositDocumentStatusInfo {
  """Uploaded"""
  status: CapitalDepositDocumentStatus!
}

"""Capital Deposit Document with Validated status"""
type CapitalDepositDocumentValidatedStatusInfo implements CapitalDepositDocumentStatusInfo {
  """Validated"""
  status: CapitalDepositDocumentStatus!
}

"""Card"""
type Card {
  """Unique identifier of a card"""
  id: ID!

  """Type of a card"""
  type: CardType!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  Account membership to define the card holder and the account linked to the card.
  """
  accountMembership: AccountMembership!

  """Main Currency"""
  mainCurrency: Currency!

  """Card expiration date  if `null` it does not have an expiration date"""
  cardContractExpiryDate: DateTime

  """URL of the card design"""
  cardDesignUrl: String!

  """
  URL of the card with masked card information (like its number) and with full card information if connected user consented beforehand
  """
  cardUrl: String!

  """Card status information"""
  statusInfo: CardStatusInfo!

  """`true` if this card allows cash withdrawals"""
  withdrawal: Boolean!

  """`true` if this card allows payments outside of the country"""
  international: Boolean!

  """
  `true` if this card allows transactions outside of the card's main currency
  """
  nonMainCurrencyTransactions: Boolean!

  """`true` if this card allows transactions at eCommerce sites"""
  eCommerce: Boolean!

  """Periodic Spending limit list"""
  spendingLimits: [SpendingLimit!]

  """Physical card if the card holder has ordered one"""
  physicalCard: PhysicalCard

  """Masked Card Number"""
  cardMaskedNumber: String!

  """Card expiry date with MM/YY format"""
  expiryDate: String

  """Card name"""
  name: String

  """Card product"""
  cardProduct: CardProduct!

  """Issuing Country"""
  issuingCountry: CCA3!

  """Digital Cards linked to this card"""
  digitalCards(
    first: Int! = 50
    after: String

    """When the list of elements needs to be ordered"""
    orderBy: DigitalCardOrderByInput

    """When the list of elements needs to be filtered"""
    filters: DigitalCardFiltersInput
  ): DigitalCardConnection!

  """List of transactions of a card."""
  transactions(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """Periodic Spending"""
  spending: Spending
}

enum CardAuthorizationOutcome {
  Accepted
  AccountClosed
  AccountSuspended
  AtmWithdrawalAmountLimitExceeded
  AtmWithdrawalNumberLimitExceeded
  AuthorizationConsumed
  AuthorizationUpdated
  AuthorizationValidityExceeded
  CardCanceled
  CardExpired
  CardholderCancelation
  CardLost
  CardNotProvidedToCardholderOrClosed
  CardNumberInvalid
  CardOpposedCardStolen
  CardOutOfOrder
  CardTemporarilyLocked
  CardUnknown
  DoNotHonor
  eMoneyAccount
  eMoneyAccountLimitExceeded
  IncorrectPinCodeAttemptsExceeded
  InsufficientFunds
  MerchantInvalid
  MerchantShouldResubmitAuthorization
  MiscellaneousReason
  OriginalTransactionNotFound
  PartialApproval
  PartialCancelation
  PeriodAmountLimitExceeded
  PeriodNumberTransactionLimitExceeded
  PinCodeInvalid
  PinCodeValidationImpossible
  SpendingLimitsReached
  TechnicalError
  TransactionAmountLimitExceeded
  TransactionCurrencyIncorrect
  TransactionInvalid
  TransactionNotAuthorizedForCardholder
  TransactionNotAuthorizedForPointOfSale
}

enum CardAuthorizationType {
  Classic
  PreAuthorization
  DataRequest
}

"""Card Canceled Status Information"""
type CardCanceledStatusInfo implements CardStatusInfo {
  """Card status (always Canceled for type CardCanceledStatusInfo)."""
  status: CardStatus!

  """Reason why the card is canceled"""
  reason: String!
}

"""Card Canceling Status Information"""
type CardCancelingStatusInfo implements CardStatusInfo {
  """Card status (always Canceling for type CardCancelingStatusInfo)."""
  status: CardStatus!

  """Reason why the card is about to be canceled."""
  reason: String!
}

"""Rejection returned if the card could not be digitalized"""
type CardCanNotBeDigitalizedRejection implements Rejection {
  id: String!
  message: String!
}

type CardConfidential {
  """Card number"""
  pan: String!

  """Card verification value"""
  cvv: String!

  """Expiration date"""
  expiryDate: String!
}

input CardConfigInput {
  """Unique identifier of a given account membership"""
  accountMembershipId: ID!

  """Card expiration date  if `null` it does not have an expiration date"""
  cardContractExpiryDate: DateTime

  """`true` if this card allows cash withdrawals"""
  withdrawal: Boolean!

  """`true` if this card allows payments outside of the country"""
  international: Boolean!

  """
  `true` if this card allows transactions outside of the card's main currency
  """
  nonMainCurrencyTransactions: Boolean!

  """`true` if this card allows transactions at eCommerce sites"""
  eCommerce: Boolean!

  """Card name"""
  name: String

  """Spending limit"""
  spendingLimit: SpendingLimitInput!

  """If used a physical card will be printed and sent to the given address"""
  physicalCard: PhysicalCardConfigInput
}

input CardConfigWithGroupDeliveryInput {
  """Unique identifier of a given account membership"""
  accountMembershipId: ID!

  """Card expiration date  if `null` it does not have an expiration date"""
  cardContractExpiryDate: DateTime

  """`true` if this card allows cash withdrawals"""
  withdrawal: Boolean!

  """`true` if this card allows payments outside of the country"""
  international: Boolean!

  """
  `true` if this card allows transactions outside of the card's main currency
  """
  nonMainCurrencyTransactions: Boolean!

  """`true` if this card allows transactions at eCommerce sites"""
  eCommerce: Boolean!

  """Card name"""
  name: String

  """Spending limit"""
  spendingLimit: SpendingLimitInput!

  """`true` when you wish for print an associated physical card"""
  printPhysicalCard: Boolean!

  """Custom options to use for physical cards."""
  physicalCardCustomOptions: PhysicalCardCustomOptionsForGroupDeliveryInput
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type CardConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """CardEdge list"""
  edges: [CardEdge!]!
}

"""when the user has to consent to add this card"""
type CardConsentPendingStatusInfo implements CardStatusInfo {
  """
  Card status (always ConsentPending for type CardConsentPendingStatusInfo)
  """
  status: CardStatus!

  """The consent required to add this card"""
  consent: Consent!
}

type CardDesignBackground {
  """Unique identifier of a project card design background"""
  id: ID!

  """Card design background name"""
  name: String!

  """Card design background type"""
  type: String!

  """Card design background text color"""
  cardTextColor: String!

  """Card design background url"""
  cardBackgroundUrl: String!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!
}

"""Project Card Design Background Type"""
enum CardDesignBackgroundType {
  """when Card design background is black"""
  Black

  """when Card design background is light"""
  Silver

  """when Card design background is customized"""
  Custom
}

"""Card designs Status"""
enum CardDesignStatus {
  """when card design are in Draft"""
  Draft

  """when card design are Enabled"""
  Enabled

  """when card design are Disabled"""
  Disabled

  """when card design are ToReview"""
  ToReview
}

"""Implements the Relay Edge interface"""
type CardEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The Card entry"""
  node: Card!
}

"""Card Enabled Status Information"""
type CardEnabledStatusInfo implements CardStatusInfo {
  """Card status (always Enabled for type CardEnabledStatusInfo)."""
  status: CardStatus!
}

"""Filters that can be applied when listing cards"""
input CardFiltersInput {
  """
  The status of the card.
  
  @deprecated(reason: "use `statuses` instead")
  """
  status: CardStatus

  """Statuses of the card."""
  statuses: [CardStatus!]

  """
  Type of card
  
  @deprecated(reason: "use `types` instead")
  """
  type: CardType

  """Types of card"""
  types: [CardType!]

  """String searched"""
  search: String

  """
  Account identifier
  
  This filter is only available for User Access Token, for the moment
  """
  accountId: String
}

"""COMING SOON"""
type CardMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

"""
Rejection returned if the card was not found or if the user does not have the rights to know that the account exists
"""
type CardNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Field we can use when ordering that can be applied when listing cards"""
enum CardOrderByFieldInput {
  id
  createdAt
  updatedAt
}

"""Order that can be applied when listing cards"""
input CardOrderByInput {
  field: CardOrderByFieldInput
  direction: OrderByDirection
}

"""when the card is in the process of being ready to use"""
type CardProcessingStatusInfo implements CardStatusInfo {
  """Card status (always Processing for type CardProcessingStatusInfo)"""
  status: CardStatus!
}

"""Card Product"""
type CardProduct {
  id: ID!
  name: String
  projectId: ID!
  status: CardProductStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  applicableToPhysicalCards: Boolean!
  cardDesigns: [CardProductDesign!]!
  defaultCardProduct: Boolean!
  individualSpendingLimit: SpendingLimit!
  companySpendingLimit: SpendingLimit!
}

"""Card design of a Card Product"""
type CardProductDesign {
  """Unique identifier of a card design"""
  id: ID!

  """Design version"""
  version: Int!

  """Logo url svg"""
  cardProjectLogoSvgUrl: String

  """Logo url 300 dpi"""
  cardProjectLogo300dpiUrl: String

  """Logo url 300 dpi"""
  cardProjectLogo600dpiUrl: String

  """Zoom level"""
  zoomRatioProjectLogo: Int

  """Card Design URL"""
  cardDesignUrl: String

  """Accent color"""
  accentColor: String!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Status of the card design"""
  status: CardDesignStatus!

  """Card Background of the Card design"""
  cardBackground: CardDesignBackground!
}

"""Rejection returned if the card product is disabled."""
type CardProductDisabledRejection implements Rejection {
  message: String!
}

"""
Rejection returned if the card product is not applicable to physical card.
"""
type CardProductNotApplicableToPhysicalCardsRejection implements Rejection {
  message: String!
}

type CardProductNotFoundRejection implements Rejection {
  message: String!
}

"""Card Product Status"""
enum CardProductStatus {
  """When card product is waiting for review"""
  PendingReview

  """When card product is Enabled"""
  Enabled

  """When card product is suspended"""
  Suspended

  """When card product is suspended"""
  Disabled
}

"""Rejection returned if the card product is suspended."""
type CardProductSuspendedRejection implements Rejection {
  message: String!
}

type CardProductUsedRejection implements Rejection {
  message: String!
}

"""Card settings for a Project"""
type CardSettings {
  """Unique identifier of a project card settings"""
  id: ID!

  """Flag used to indicate if ApplePay is activated for the project"""
  allowsApplePay: Boolean! @deprecated

  """Settings version"""
  version: Int!

  """Logo url svg"""
  cardProjectLogoSvgUrl: String

  """Logo url 300 dpi"""
  cardProjectLogo300dpiUrl: String

  """Logo url 300 dpi"""
  cardProjectLogo600dpiUrl: String

  """Zoom level"""
  zoomRatioProjectLogo: Int

  """Card Design URL"""
  cardDesignUrl: String

  """Accent color"""
  accentColor: String!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Status of the card settings"""
  status: ProjectCardStatus!

  """Card Background of the Card Settings"""
  cardBackground: CardSettingsBackground!
}

type CardSettingsBackground {
  """Unique identifier of a project card settings"""
  id: ID!

  """Card settings background name"""
  name: String!

  """Card settings background type"""
  type: String!

  """Card settings background text color"""
  cardTextColor: String!

  """Card settings background url"""
  cardBackgroundUrl: String!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!
}

"""Card Settings Background Type"""
enum CardSettingsBackgroundType {
  """when Card background is black"""
  Black

  """when Card background is light"""
  Silver

  """when Card background is customized"""
  Custom
}

"""Card Status"""
enum CardStatus {
  """when the consent to add this card is pending"""
  ConsentPending

  """when the card is in the process of being ready to use"""
  Processing

  """when the card is enabled"""
  Enabled

  """when the card is canceled"""
  Canceled

  """when the card is about to be canceled"""
  Canceling
}

"""Card Status Information"""
interface CardStatusInfo {
  """Status of the card."""
  status: CardStatus!
}

scalar CardToken

"""Card transaction"""
type CardTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!

  """external identifier of the transaction"""
  reference: String!

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """card numbers masked (Primary Account Number)"""
  maskedPan: String!

  """unique identifier of the card"""
  cardId: String!

  """card used for this transaction"""
  card: Card!

  """unique identifier of the terminal"""
  terminalId: String!

  """original amount and currency of the transaction"""
  originalAmount: Amount!

  """currency exchange if any"""
  currencyExchange: [ReportExchangeRate!]!

  """unique identifier of the merchant"""
  merchantId: String!

  """merchant name"""
  merchantName: String!

  """merchant city"""
  merchantCity: String!

  """merchant country"""
  merchantCountry: CCA3

  """merchant postal code"""
  merchantPostalCode: String

  """merchant category code (MCC)"""
  merchantCategoryCode: String!

  """
  merchant category description
  Enum that explains what the MCC corresponds to in a more readable way
  """
  merchantCategoryDescription: MerchantCategoryDescription!

  """category of the payment flow"""
  category: Category!

  """
  type of the authorization.
  Only available for:
  - authorization transaction
  - debit transaction linked to a previous authorization transaction
  """
  authorizationType: AuthorizationType

  """matching account for the transaction"""
  account: Account

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction
}

enum CardTransactionCategory {
  InStore
  eCommerce
  eCommerceWith3DS
  Withdrawal
  Other
}

"""Card Type"""
enum CardType {
  """When card is Virtual"""
  Virtual

  """When card is Virtual and Physical"""
  VirtualAndPhysical

  """When card is Single Use Virtual"""
  SingleUseVirtual
}

"""Rejection returned when the Card is not the expected status"""
type CardWrongStatusRejection implements Rejection {
  message: String!
  identifier: String!
  currentStatus: CardStatus!
  expectedStatus: CardStatus!
}

"""Cash account type (Always Current)"""
enum CashAccountType {
  """When the account is a current account."""
  Current
  CashPayment
  Charges
  CashIncome
  Commission
  ClearingParticipantSettlementAccount
  LimitedLiquiditySavingsAccount
  Loan
  MarginalLending
  MoneyMarket
  NonResidentExternal
  Overdraft
  OverNightDeposit
  OtherAccount
  Settlement
  Salary
  Savings
  Tax
  TransactingAccount
  CashTrading
}

"""Payment flow available options"""
enum Category {
  """In store payment"""
  InStore

  """Online (remote) payment"""
  eCommerce

  """Secured online (remote) payment"""
  eCommerceWith3DS

  """Cash withdraw (atm)"""
  Withdrawal

  """Other payment"""
  Other
}

"""Country code alpha 2 (ISO 3166)"""
scalar CCA2

"""Country code alpha 3 (ISO 3166)"""
scalar CCA3

"""Certificate"""
input Certificate {
  """
  CertificateType
  
  Can be either LEAF or INTERMEDIATE
  """
  key: String!

  """Base64 value of the certificate"""
  value: String!
}

"""CheckMerchantPaymentMethod"""
type CheckMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

input CheckPaymentCollectionInput {
  """ID of the Merchant profile associated to the Swan creditor account"""
  merchantProfileId: ID!

  """
  31-caracter unique identifier located at the bottom of the check.
  CMC7 is composed of 3 sections (check number (7 char.), check issuing bank code (12 char.), check holder account number (12 char.)).
  Combined with RLMC key, it  allows the check traceability.
  """
  cmc7: String!

  """
  2-digit key used to check the integrity of the CMC7 line, located at the bottom right of the check.
  Combined with CMC7 line, it allows the check traceability.
  """
  rlmcKey: String!
}

input CheckPaymentMethodInput {
  """Determine whether the payment method must be activated or not"""
  activate: Boolean = false
}

"""Check transaction"""
type CheckTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain.
  """
  reference: String!

  """payment method identifier used for this transaction: check number"""
  paymentMethodIdentifier: String!

  """
  31-caracter unique identifier located at the bottom of the check.
  CMC7 is composed of 3 sections (check number (7 char.), check issuing bank code (12 char.), check holder account number (12 char.)).
  Combined with RLMC key, it  allows the check traceability.
  """
  cmc7: String!

  """
  2-digit key used to check the integrity of the CMC7 line, located at the bottom right of the check.
  Combined with CMC7 line, it allows the check traceability.
  """
  rlmcKey: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """matching account for the transaction"""
  account: Account

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """reserved amount of the transaction computed with the rolling reserve."""
  reservedAmount: Amount

  """date on which reserved funds become available"""
  reservedAmountReleasedAt: DateTime

  """return reason"""
  returnReason: TransactionReasonCode
}

input CloseAccountInput {
  accountId: ID!
  reason: PartnerCloseAccountReasonInput!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union CloseAccountPayload = CloseAccountSuccessPayload | AccountNotFoundRejection | BadAccountStatusRejection | ForbiddenRejection | InternalErrorRejection | ValidationRejection

"""
Define a reason with a message and a specific type for closing account action
"""
type CloseAccountReason implements Reason {
  type: CloseAccountReasonType!
  message: String
}

"""Specific type for closing account action"""
enum CloseAccountReasonType {
  """Compliance Reason"""
  ComplianceReason

  """Partner Reason"""
  PartnerReason

  """Inactivity"""
  Inactivity
}

"""
Union between PartnerCloseAccountReasonType and InternalCloseAccountReason
"""
union CloseAccountStatusReason = CloseAccountReason

type CloseAccountSuccessPayload {
  consent: Consent!
}

"""
Data provided following the search for company information by siren number
"""
type CompanyInfo {
  siren: String!
  companyName: String!
  headquarters: Headquarters!
  vatNumber: String
  taxIdentificationNumber: String
  legalRepresentativePersonalAddress: AddressInformation
}

"""Company shareholder info."""
type CompanyShareholder {
  """Whether the shareholder is an individual or a company."""
  type: ShareholderType!

  """Company name."""
  name: String!
}

"""Type of company."""
enum CompanyType {
  Association
  Company
  HomeOwnerAssociation
  Other
  SelfEmployed
}

"""Complete Address Information"""
input CompleteAddressInput {
  """address line 1 (max 38 characters)"""
  addressLine1: String!

  """address line 2 (max 38 characters)"""
  addressLine2: String

  """city (max 30 characters)"""
  city: String!

  """postal code (max 10 characters)"""
  postalCode: String!

  """state (max 30 characters)"""
  state: String

  """country code"""
  country: CCA3!
}

"""Complete Address Information with a contact"""
input CompleteAddressWithContactInput {
  """address line 1 (max 38 characters)"""
  addressLine1: String!

  """address line 2 (max 38 characters)"""
  addressLine2: String

  """city (max 30 characters)"""
  city: String!

  """postal code (max 10 characters)"""
  postalCode: String!

  """state (max 30 characters)"""
  state: String

  """country code"""
  country: CCA3!

  """contact first name"""
  firstName: String!

  """contact last name"""
  lastName: String!

  """contact phone number"""
  phoneNumber: PhoneNumber!

  """contact company name (max 38 characters)"""
  companyName: String
}

"""
Complete Digital Card used for ApplePay or GooglePay

Once the pending phase is over, more data will be available in the response
"""
type CompleteDigitalCard implements DigitalCard {
  """Unique identifier of a digital card"""
  id: ID!

  """The type of digitalization that created this digital card."""
  type: DigitalizationType!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Wallet Provider (ApplePay, GooglePay ...)"""
  walletProvider: WalletProvider!

  """
  Device
  In case of a wallet application, some information about the device will be provided
  """
  device: Device!

  """
  Id of the wallet application.
  Will not be present for Merchant
  """
  walletId: String

  """
  Masked DPAN with the last four digits visible
  
  This value is present in the user wallet application
  """
  cardMaskedNumber: String!

  """
  Digital Card status information
  
  In this type the status will be either ConsentPending or Pending
  """
  statusInfo: CompleteDigitalCardStatusInfo!
}

"""Complete Digital Card Status"""
enum CompleteDigitalCardStatus {
  """when the digital card is enabled"""
  Enabled

  """
  when the digital card is suspended
  
  the transactions will be blocked
  """
  Suspended

  """
  when the digital card is canceled
  
  this is a final state
  """
  Canceled
}

"""Complete Digital Card Status Information"""
interface CompleteDigitalCardStatusInfo {
  """Status of the digital card."""
  status: CompleteDigitalCardStatus!
}

type CompletedMerchantPaymentLinkStatusInfo implements MerchantPaymentLinkStatusInfo {
  status: MerchantPaymentLinkStatus!

  """The time when the customer completed the payment."""
  completedAt: DateTime!
}

"""
Relay Connection type, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
interface Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """Edge list"""
  edges: [Edge!]!
}

"""
Some sensitive operation at Swan, such as initiating a payment, require consent
"""
type Consent {
  """unique identifier of the consent"""
  id: ID!

  """`true` if the consent requires a Strong Customer Authentication"""
  requireSCA: Boolean!

  """status of the consent"""
  status: ConsentStatus!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime

  """date when the `consentUrl` was request the first time"""
  startedAt: DateTime

  """date when the consent expire"""
  expiredAt: DateTime

  """purpose of the consent"""
  purpose: ConsentPurpose!

  """Redirect the user to this URL to start the consent flow"""
  consentUrl: String!

  """When the consent flow is finished the user is redirected to this URL"""
  redirectUrl: String!

  """userId who initiated the consent"""
  userId: String!

  """user who initiated the consent"""
  user: User

  """unique hash of the consent"""
  challenge: String
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type ConsentConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ConsentEdge list"""
  edges: [ConsentEdge!]!
}

"""Implements the Relay Edge interface"""
type ConsentEdge implements Edge {
  """
  Opaque identifier pointing to this consent node in the pagination mechanism
  """
  cursor: String!

  """The consent"""
  node: Consent!
}

"""Consent ID with related execution order"""
input ConsentIdWithOrder {
  """
  Execution order. Consents are granted in ascending order. Consents with the same order may be granted in parallel.
  """
  order: Int! = 0

  """Consent ID"""
  consentId: String!
}

"""Rejection returned if a consent was not found"""
type ConsentNotFoundRejection implements Rejection {
  message: String!
  consentId: String!
}

"""Purpose of a consent"""
enum ConsentPurpose {
  """when accepting the partnership conditions"""
  AcceptPartnershipConditions

  """when inviting a new account membership"""
  AddAccountMembership

  """when adding several account memberships"""
  AddAccountMemberships

  """when adding a beneficiary"""
  AddBeneficiary

  """when adding a virtual card"""
  AddCard

  """when adding multiple cards"""
  AddCards

  """when adding a digital card"""
  AddDigitalCard

  """when activating a physical card"""
  ActivatePhysicalCard

  """when closing an account"""
  CloseAccount

  """when initiating a credit transfer"""
  InitPayment

  """when requesting to print physical card"""
  PrintPhysicalCard

  """when resuming an account membership"""
  ResumeAccountMembership

  """when resuming a physical card"""
  ResumePhysicalCard

  """when scheduling a standing order"""
  ScheduleStandingOrder

  """when updating an account membership"""
  UpdateAccountMembership

  """when updating a card"""
  UpdateCard

  """when updating a server consent project settings"""
  UpdateServerConsentProjectSettings

  """when viewing card confidential of a virtual card"""
  ViewCardNumbers

  """when requesting to view physical card PIN"""
  ViewPhysicalCardPin

  """when enabling a mandate"""
  EnableMandate

  """when adding a payment direct debit mandate"""
  AddDirectDebitPaymentMandate

  """when initiating a funding request"""
  InitiateFundingRequest

  """when initiating an instant funding request"""
  InitiateInstantFundingRequest

  """when initiating an international credit transfer"""
  InitiateInternationalCreditTransfer

  """when the consent is a multiple consent"""
  ConsentToMultipleConsents
}

"""
Rejection returned when a the consent is already linked to another multi consent
"""
type ConsentsAlreadyLinkedToMultiConsentRejection implements Rejection {
  message: String!

  """IDs of the consents that are already linked to another multi consent"""
  consentIds: [String!]!
}

input ConsentsFiltersInput {
  userId: String
}

"""
Rejection returned when all provided consents are not in created status
"""
type ConsentsNotAllInCreatedStatusRejection implements Rejection {
  message: String!

  """IDs of the consents that are not in created status"""
  consentIds: [String!]!
}

"""Rejection returned when a consent ID passed as input does not exist."""
type ConsentsNotFoundRejection implements Rejection {
  message: String!
  ids: [String!]!
}

"""Status of a consent"""
enum ConsentStatus {
  """when the user accepted"""
  Accepted

  """when the user refused"""
  CustomerRefused

  """when the operation is committing"""
  OperationCommitting

  """when the user credentials were refused"""
  CredentialRefused

  """when the consent is created"""
  Created

  """when the consentUrl has been requested"""
  Started

  """when the consent is expired"""
  Expired

  """when something went wrong"""
  Failed

  """when the user or the project decided to cancel the consent"""
  Canceled
}

type ConsentTypeNotSupportedByServerConsentRejection implements Rejection {
  message: String!
}

"""Inputs to create a capital deposit case."""
input CreateCapitalDepositCaseInput {
  """
  Name ("Dnomination sociale") of the company being registered and for which the capital is being deposited.
  """
  companyName: String!

  """Array of shareholders of type company ("personne morale")."""
  companyShareholders: [OnboardCompanyShareholderInput]!

  """Array of shareholders of type individual ("personne physique")."""
  individualShareholders: [OnboardIndividualShareholderInput]!

  """Amount of the capital deposit."""
  totalCapitalDepositAmount: AmountInput!

  """Information required for the onboarding of a company."""
  onboardingCapitalDepositCompany: OnboardCompanyAccountHolderInput!
}

union CreateCapitalDepositCasePayload = CreateCapitalDepositCaseSuccessPayload | ForbiddenRejection | BadRequestRejection | InternalErrorRejection

type CreateCapitalDepositCaseSuccessPayload {
  capitalDepositCase: CapitalDepositCase!
}

input CreateMerchantPaymentLinkInput {
  """The Merchant Profile to link this Payment Link to"""
  merchantProfileId: ID!

  """Amount to be paid to sucessfully complete the payment."""
  amount: AmountInput!

  """
  Merchant Website URL to redirect the user to when the payment is completed.
  """
  redirectUrl: URL!

  """URL to redirect the user to if they cancel their payment"""
  cancelRedirectUrl: URL!

  """
  The customer billing Address
  These fields should be completed also to pre-fill a SEPA direct debit mandate.
  
  We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes
  """
  billingAddress: AddressInput

  """
  The date when the payment link expires.
  If not specified, the default time will be 24 hours
  """
  expiresAt: DateTime

  """
  A date that reflects the time at which the user asked the transaction to be executed.
  For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
  For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
  
  Default value means that the execution will be as soon as possible
  """
  requestedExecutionAt: DateTime

  """
  Controls if the payment mandate created from this payment link is for one-time use or can be reused
  This is applicable for card and SEPA Direct Debit payment methods only.
  If not specified, the default value is OneOff.
  """
  sequence: SequenceType

  """
  Any string that you want to be attached to this payment link.
  Usually something to help you reference the link in an external system.
  """
  externalReference: String

  """
  Optional field intended to provide a way for you to include a reference number or code.
  The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different.
  """
  reference: String

  """
  Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page.
  """
  label: String

  """
  The language used for the payment page.
  Default is the browser's language, or English if not available.
  """
  language: Language

  """
  We will use the information specified here to prefill the payment link fields
  depending on the payment method the end user chooses.
  Keep in mind that your end customer will be able to edit these fields.
  """
  customer: CustomerInput

  """
  List of payment methods enabled for this payment link.
  If the array is empty, Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit)
  If you want to make payment possible via SEPA Direct Debit, the list should be populated either by a SEPA Direct Debit CORE or B2B.
  """
  paymentMethodIds: [String!]
}

union CreateMerchantPaymentLinkPayload = CreateMerchantPaymentLinkSuccessPayload | MerchantProfileWrongStatusRejection | MerchantPaymentMethodNotActiveRejection | PaymentMethodNotCompatibleRejection | InternalErrorRejection | ForbiddenRejection | ValidationRejection

type CreateMerchantPaymentLinkSuccessPayload {
  merchantPaymentLink: MerchantPaymentLink!
}

"""Input of the `createMultiConsent` mutation"""
input CreateMultiConsentInput {
  """A list of consent IDs with their related execution orders"""
  orderedConsentIds: [ConsentIdWithOrder!]!

  """URL the user is redirected to after consent has been given"""
  redirectUrl: String!
}

"""Payload of the `createMultiConsent` mutation"""
union CreateMultiConsentPayload = CreateMultiConsentSuccessPayload | ConsentsNotAllInCreatedStatusRejection | ConsentsNotFoundRejection | TooManyChildConsentsRejection | ConsentsAlreadyLinkedToMultiConsentRejection

"""Success payload of the `createMultiConsent` mutation"""
type CreateMultiConsentSuccessPayload {
  consent: Consent
}

"""Credit transfer"""
input CreditTransferInput {
  """if the transfer will credit a beneficiary already created"""
  beneficiaryId: ID

  """if the transfer will credit a new swan account beneficiary"""
  swanAccountBeneficiary: SwanAccountBeneficiaryInput

  """if the transfer will credit a new SEPA beneficiary"""
  sepaBeneficiary: SepaBeneficiaryInput

  """amount of the transfer"""
  amount: AmountInput!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35})
  """
  reference: String

  """label (max 140 characters)"""
  label: String

  """
  requested date at which the credit transfer will try to be executed, if `null` the credit transfer is executed right away
  """
  requestedExecutionAt: DateTime

  """
  an arbitrary identifier that you can define to easily identify this transaction later
  """
  externalReference: String

  """
  if the transfer will execute as instant and fallbacked to a regular one if an error happend during the instant transfer
  """
  mode: CreditTransferMode
}

enum CreditTransferMode {
  InstantWithoutFallback
  InstantWithFallback
  Regular
}

"""Custom information for a CSV statement"""
type CsvStatement implements StatementInfo {
  """statement type"""
  type: StatementType

  """temporary public url on which the file can be accessed"""
  url: String

  """date at which the link will not be useable anymore"""
  expiresAt: DateTime
}

"""currency code alpha 3 (ISO 4217)"""
scalar Currency

type Customer {
  """
  A customer id present in a third-party system.
  Alows to link a customer to a payment link and by extension, to a Merchant Payment.
  """
  externalCustomerId: String
  name: String
  iban: String
}

input CustomerInput {
  """
  A customer ID present in a third-party system.
  Alows to link a customer to a payment link and by extension, to a merchant payment.
  """
  externalCustomerId: String

  """Customer name"""
  name: String

  """Customer IBAN"""
  iban: String
}

"""Date with YYYY-MM-DD format"""
scalar Date

type DateField implements Field {
  example: String
  key: String!
  name: String!
  required: Boolean!
  validationRegex: String
}

"""
Date time (ISO 8601 with time information)
ex: 2021-04-12T16:28:22.867Z
"""
scalar DateTime

"""Rejection returned when the Debtor is closed"""
type DebtorAccountClosedRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the Debtor does not belong to the same project as the creditor
"""
type DebtorAccountNotAllowedRejection implements Rejection {
  message: String!
}

input DeleteSupportingDocumentInput {
  """Id of the supporting document to delete"""
  id: ID!
}

union DeleteSupportingDocumentPayload = DeleteSupportingDocumentSuccessPayload | ForbiddenRejection | InternalErrorRejection | SupportingDocumentCollectionNotFoundRejection | SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection | SupportingDocumentNotFoundRejection | SupportingDocumentStatusDoesNotAllowDeletionRejection | ValidationRejection

type DeleteSupportingDocumentSuccessPayload {
  id: String!
}

input DenySddInput {
  accountId: ID!
}

union DenySddPayload = DenySddSuccessPayload | BadAccountStatusRejection | AccountNotFoundRejection | InvalidArgumentRejection | ValidationRejection

type DenySddSuccessPayload {
  account: Account!
}

input DenySddVirtualIbanEntryInput {
  ibanEntryId: ID!
}

union DenySddVirtualIbanEntryPayload = DenySddVirtualIbanEntrySuccessPayload | BadAccountStatusRejection | ValidationRejection

type DenySddVirtualIbanEntrySuccessPayload {
  virtualIbanEntry: VirtualIBANEntry!
}

"""Device"""
type Device {
  """The type of device. It can be a Phone, Tablet, Watch"""
  type: String

  """
  Device name
  End user defined name of the device on which the card id provided
  """
  name: String

  """Secure Element ID"""
  SEID: String
}

"""Digital Card used for ApplePay or GooglePay"""
interface DigitalCard {
  """Unique identifier of a digital card"""
  id: ID!

  """The type of digitalization that created this digital card."""
  type: DigitalizationType!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Wallet Provider (ApplePay, GooglePay ...)"""
  walletProvider: WalletProvider!
}

"""Digital Card Canceled Status Information"""
type DigitalCardCanceledStatusInfo implements CompleteDigitalCardStatusInfo {
  """Card status (always Canceled for type DigitalCardCanceledStatusInfo)."""
  status: CompleteDigitalCardStatus!

  """Enable Date"""
  enabledAt: DateTime!

  """Cancel Date"""
  canceledAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type DigitalCardConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """CardEdge list"""
  edges: [DigitalCardEdge!]!
}

"""Digital Card ConsentPending Status Information"""
type DigitalCardConsentPendingStatusInfo implements PendingDigitalCardStatusInfo {
  """
  Digital Card status (always ConsentPending for type DigitalCardConsentPendingStatusInfo).
  """
  status: PendingDigitalCardStatus!

  """A reference to the consent to validate"""
  consent: Consent!
}

"""Digital Card Declined Status Information"""
type DigitalCardDeclinedStatusInfo implements PendingDigitalCardStatusInfo {
  """
  Digital Card status (always Declined for type DigitalCardDeclinedStatusInfo).
  """
  status: PendingDigitalCardStatus!
}

"""Implements the Relay Edge interface"""
type DigitalCardEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The Card entry"""
  node: DigitalCard!
}

"""Digital Card Enabled Status Information"""
type DigitalCardEnabledStatusInfo implements CompleteDigitalCardStatusInfo {
  """
  Digital Card status (always Enabled for type DigitalCardEnabledStatusInfo).
  """
  status: CompleteDigitalCardStatus!

  """Enable Date"""
  enabledAt: DateTime!
}

"""Filters that can be applied when listing digitalCards"""
input DigitalCardFiltersInput {
  """The id of the digitalCard"""
  id: String

  """
  The status of the digital card. It can be a CompleteDigitalCardStatus or a PendingDigitalCardStatus
  """
  status: String

  """
  The Secure Element ID
  Mostly present on APple Devices
  """
  SEID: String

  """The digital card masker number"""
  cardMaskedNumber: String

  """The ID of the wallet provider in the scheme system"""
  walletProviderId: String

  """Either ApplePay, GooglePay or Merchant"""
  walletProviderName: String

  """The wallet application ID in the user phone"""
  walletId: String
}

"""Rejection returned when the Digital Card does not exist"""
type DigitalCardNotFoundRejection implements Rejection {
  message: String!
  identifier: String!
}

"""
Field we can use when ordering that can be applied when listing digital cards
"""
enum DigitalCardOrderByFieldInput {
  id
  createdAt
  updatedAt
}

"""Order that can be applied when listing digital cards"""
input DigitalCardOrderByInput {
  field: DigitalCardOrderByFieldInput
  direction: OrderByDirection
}

"""Digital Card Pending Status Information"""
type DigitalCardPendingStatusInfo implements PendingDigitalCardStatusInfo {
  """
  Digital Card status (always Pending for type DigitalCardPendingStatusInfo).
  """
  status: PendingDigitalCardStatus!
}

"""Digital Card Suspended Status Information"""
type DigitalCardSuspendedStatusInfo implements CompleteDigitalCardStatusInfo {
  """
  Digital Card status (always Suspended for type DigitalCardSuspendedStatusInfo).
  """
  status: CompleteDigitalCardStatus!

  """Enable Date"""
  enabledAt: DateTime!

  """Suspend Date"""
  suspendedAt: DateTime!
}

"""Digitalization Type"""
enum DigitalizationType {
  """
  This digital card was created by direct input of the PAN into a wallet application
  
  This direct input can also be done using the device camera
  """
  Manual

  """
  This digital card was created based on a PAN stored into a merchant application (ex: iTunes)
  """
  CardOnFile

  """This digital card was created by an in app provisioning"""
  InApp

  """We could not get the source of the digitalization"""
  Unknown
}

"""Direct Debit Account Verification"""
type DirectDebitAccountVerification implements AccountVerification {
  """Creation date of the account verification"""
  createdAt: DateTime!

  """IBAN of the account to cross check with account holder information"""
  iban: IBAN!

  """Unique identifier of the Account Verification"""
  id: ID!

  """Account Verification Status Information"""
  statusInfo: AccountVerificationStatusInfo!

  """Last update date of the account verification"""
  updatedAt: DateTime!
}

"""Funding Source with Direct Debit Mandate"""
type DirectDebitFundingSource implements FundingSource {
  """ID of the Funding Source"""
  id: ID!

  """Name of the Funding Source"""
  name: String

  """Funding Source status information"""
  statusInfo: FundingSourceStatusInfo!

  """
  IBAN to use in the direct debit transaction that will be triggered when funding the account.
  Money will be debited from this IBAN when an `initiateFundingRequest` is done using this funding source
  """
  iban: IBAN!

  """Created date"""
  createdAt: DateTime!

  """Last updated date"""
  updatedAt: DateTime!

  """
  Can be queried to check the status of the account verification for this funding source.
  If the account verification is PendingVerification, you should ask your account holder to wire some money from his external account to any swan account
  """
  accountVerification: DirectDebitAccountVerification!

  """
  Can be queried to check the status of payment payment Mandate.
  If the payment mandate is ConsentPending, you should confirm it to enable this funding source
  """
  paymentMandate: PaymentDirectDebitMandate!
}

enum DirectDebitSequence {
  OneOff
  Recurring
}

"""Input to disable an account membership"""
input DisableAccountMembershipInput {
  """Unique identifier of the account membership to disable"""
  accountMembershipId: ID!
}

union DisableAccountMembershipPayload = DisableAccountMembershipSuccessPayload | AccountMembershipCannotBeDisabledRejection | AccountMembershipNotFoundRejection | ForbiddenRejection | InternalErrorRejection | LegalRepresentativeAccountMembershipCannotBeDisabledRejection | UserNotAllowedToDisableItsOwnAccountMembershipRejection | ValidationRejection

type DisableAccountMembershipSuccessPayload {
  accountMembership: AccountMembership
}

"""StatusInfo when funding limit settings has been disabled"""
type DisabledFundingLimitSettingsStatusInfo implements FundingLimitSettingsStatusInfo {
  status: FundingLimitSettingsStatus!
  reason: String!
}

"""EnabledMerchantPaymentMethodStatusInfo"""
type DisabledMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method disabled date"""
  disabledAt: Date!
}

"""Retrieved document extracted from the identity verification"""
interface DocumentFile {
  downloadUrl: String!
}

"""From which side the document picture was taken"""
enum DocumentFileSide {
  SideA
  SideB
  BothSides
  Unknown
}

"""Reason code of the document."""
enum DocumentReasonCode {
  """Company name in document doesnt match our records"""
  CompanyNameMismatch

  """Declared amount in document doesnt match the amount received"""
  DeclaredAmountMismatch

  """Document must be dated less than 3 months ago"""
  ExpiredDocument

  """Address in document doesnt match our records"""
  InvalidAddress

  """Default value when none of the other values is appropriate"""
  InvalidDocument

  """Name of shareholder is not clearly visible or is missing"""
  InvalidOrMissingData

  """Missing identity document of accommodation provider"""
  MissingAccommodationProviderId

  """
  Missing identity document and proof of accommodation from accommodation provider
  """
  MissingAccommodationProviderIdLetter

  """Missing proof of accommodation from accommodation provider"""
  MissingAccommodationProviderLetter

  """Document cant be accepted as a proof of address"""
  UnacceptableDocument
}

"""The type of the document"""
enum DocumentType {
  IdCard
  Passport
  ResidencePermit
  DriversLicense
  Face
  Report
}

"""The document corresponding to a driver's license"""
type DriversLicenseDocument {
  """Unique identifier of the driver's license document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """List of the associated files"""
  files: [DriversLicenseDocumentFile!]!
}

"""The file associated to the driver's license document"""
type DriversLicenseDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!

  """From which side the deiver's license's picture was taken"""
  side: DocumentFileSide!
}

"""
Edge type containing the node and cursor. The node is not defined in the interface because generic is not supported by GraphQL
but all implementation contains its own node property according to the paginated type.
"""
interface Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

scalar EmailAddress

"""Employment status."""
enum EmploymentStatus {
  Craftsman
  Employee
  Entrepreneur
  Farmer
  Manager
  Practitioner
  Retiree
  ShopOwner
  Student
  Unemployed
}

"""
Rejection returned if the card product don't have a card design enabled
"""
type EnabledCardDesignNotFoundRejection implements Rejection {
  message: String!
}

"""StatusInfo when the funding limit settings is enabled"""
type EnabledFundingLimitSettingsStatusInfo implements FundingLimitSettingsStatusInfo {
  status: FundingLimitSettingsStatus!
}

"""Funding Source Enabled status information"""
type EnabledFundingSourceStatusInfo implements FundingSourceStatusInfo {
  """Funding Source Enabled status"""
  status: FundingSourceStatus!

  """Date at which the funding source was enabled"""
  enabledAt: Date!
}

"""EnabledMerchantPaymentMethodStatusInfo"""
type EnabledMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method enabled date"""
  enabledAt: Date!
}

"""EnabledMerchantProfileStatusInfo"""
type EnabledMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  enabledAt: Date!
}

"""
Inputs to enable a received direct debit mandate, i.e. to move its status back from suspended.
"""
input EnableReceivedDirectDebitMandateInput {
  """The received direct debit id to enable"""
  receivedDirectDebitMandateId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String
}

"""Union type return by the enableReceivedDirectDebitMandate mutation"""
union EnableReceivedDirectDebitMandatePayload = EnableReceivedDirectDebitMandateSuccessPayload | ReceivedDirectDebitMandateNotFoundRejection | ReceivedDirectDebitMandateCanceledRejection | ForbiddenRejection

"""
Return type in case of a successful response of the enableReceivedDirectDebitMandate mutation
"""
type EnableReceivedDirectDebitMandateSuccessPayload {
  """
  The received direct debit mandate is enable, i.e that it is moved back to from the suspended to the enabled status
  """
  receivedDirectDebitMandate: ReceivedDirectDebitMandate!
}

enum EnvType {
  Live
  Sandbox
}

"""
Describes an identification level for the process associated to this identification that has expired and is no longer considered valid
"""
type ExpiredIdentificationLevelStatusInfo {
  """Always set to `Expired`"""
  status: SwanIdentificationStatus!

  """When this identification level expired"""
  expiredAt: Date!
}

type ExpiredMerchantPaymentLinkStatusInfo implements MerchantPaymentLinkStatusInfo {
  status: MerchantPaymentLinkStatus!

  """
  The date when the payment link expired.
  The payment link expires 24 hours after it was created.
  """
  expiredAt: DateTime!
}

type ExternalAccount {
  """Unique identifier of an external account"""
  id: ID!

  """External account identifier following ISO-20022 standard"""
  externalId: String!

  """Name of the account"""
  name: String

  """Type of the account"""
  cashAccountType: CashAccountType!

  """Bank Identifier Code"""
  BIC: BIC!

  """International Bank Account Number"""
  IBAN: IBAN!

  """Currency"""
  currency: Currency!

  """Account Holder name"""
  holderName: String!

  """Country"""
  country: CCA3!

  """Original Created date"""
  originalCreatedAt: DateTime!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """A list of balances regarding an external account."""
  balances(first: Int! = 90, before: String, after: String): ExternalBalanceConnection!

  """Source used for this account"""
  source: ExternalAccountDataSource!

  """Financial institution"""
  institution: FinancialInstitution

  """Usage information of the account"""
  usage: ExternalAccountUsage!

  """Account holder for the external account"""
  accountHolder: AccountHolder
}

type ExternalAccountAlreadyExistsRejection implements Rejection {
  iban: String!
  accountHolderId: String!
  message: String!
}

type ExternalAccountBalance {
  """Unique identifier of an external balance"""
  id: ID!

  """Amount with currency"""
  amount: Amount

  """Type of Balance"""
  type: ExternalAccountBalanceType!

  """Last changed Date"""
  lastChangedAt: DateTime!
}

type ExternalAccountBalanceAlreadyExistsRejection implements Rejection {
  type: ExternalAccountBalanceType!
  lastChangedAt: DateTime!
  message: String!
}

input ExternalAccountBalanceInput {
  """Amount with currency"""
  amount: AmountInput!

  """Type of Balance"""
  type: ExternalAccountBalanceType!

  """Last changed Date"""
  lastChangedAt: DateTime!
}

enum ExternalAccountBalanceType {
  """
  Balance of the account at the end of the pre-agreed account reporting period
  """
  ClosingBooked

  """
  Balance of the account at the previously closed account reporting period
  """
  PreviouslyClosedBooked

  """
  Available balance calculated in the course of the account servicer's business day, at the time specified, and subject to further changes during the business day
  """
  InterimAvailable

  """
  Balance composed of booked entries and pending items known at the time of calculation
  """
  Expected

  """Value-date balance"""
  ValueDate

  """Other balance"""
  Other
}

"""
Implements the Relay Connection interface, used to paginate the list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type ExternalAccountConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ExternalAccountEdge list"""
  edges: [ExternalAccountEdge!]!
}

type ExternalAccountDataSource {
  type: ExternalAccountDataSourceType!
  name: String!
}

enum ExternalAccountDataSourceType {
  """When manually added by the partner"""
  Push
}

"""Implements the Relay Edge interface"""
type ExternalAccountEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The external account"""
  node: ExternalAccount!
}

enum ExternalAccountUsage {
  Private
  Association
  Organization
  Unknown
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type ExternalBalanceConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ExternalBalanceEdge list"""
  edges: [ExternalBalanceEdge!]!
}

"""Implements the Relay Edge interface"""
type ExternalBalanceEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The external balance"""
  node: ExternalAccountBalance!
}

"""The document corresponding to a face photo"""
type FacePhotoDocument {
  """
  Unique identifier of the face photo document. For privacy reasons, no temporary download url is exposed for this document
  """
  id: String!

  """The type of the document"""
  type: DocumentType!
}

"""Fee creditor"""
interface FeeCreditor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

interface FeeDebtor {
  """full name of the debtor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Fee creditor for Incoming transaction"""
type FeeInCreditor implements FeeCreditor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Fee debtor for Incoming transaction"""
type FeeInDebtor implements FeeDebtor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Fee creditor for Outgoing transaction"""
type FeeOutCreditor implements FeeCreditor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Fee debtor for Outgoing transaction"""
type FeeOutDebtor implements FeeDebtor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

type FeeSettingsNotFoundRejection implements Rejection {
  message: String!
}

"""Fees type"""
enum FeesTypeEnum {
  """Other banking fee"""
  BankingFee

  """Card transaction in foreign currency"""
  CardPaymentsOutsideSEPA

  """Cash withdrawal in foreign currency"""
  CashWithdrawalsOutsideSEPA

  """Cash withdrawal"""
  CashWithdrawalsWithinSEPA

  """Deposit of a physical check"""
  CheckDeposit

  """Rejection or return of a physical check"""
  CheckIncident

  """Drafting circulation letter"""
  CirculationLetterDraftingFee

  """Drafting Confirmation letter"""
  ConfirmationLetterDraftingFee

  """Direct debit rejection"""
  DirectDebitRejection

  """
  Incoming credit transfers not denominated and executed in euros on group 1 currencies
  """
  InternationalCreditTransferInGroup1

  """
  Incoming credit transfers not denominated and executed in euros on group 2 currencies
  """
  InternationalCreditTransferInGroup2

  """
  Incoming credit transfers not denominated and executed in euros on group 3 currencies
  """
  InternationalCreditTransferInGroup3

  """
  Incoming credit transfers not denominated and executed in euros on group 4 currencies
  """
  InternationalCreditTransferInGroup4

  """
  Outgoing credit transfers not denominated and executed in euros on group 1 currencies
  """
  InternationalCreditTransferOutGroup1

  """
  Outgoing credit transfers not denominated and executed in euros on group 2 currencies
  """
  InternationalCreditTransferOutGroup2

  """
  Outgoing credit transfers not denominated and executed in euros on group 3 currencies
  """
  InternationalCreditTransferOutGroup3

  """
  Outgoing credit transfers not denominated and executed in euros on group 4 currencies
  """
  InternationalCreditTransferOutGroup4

  """Improper use of account"""
  ImproperUseOfAccount

  """Delivery of physical cards with an express delivery provider"""
  PhysicalCardDeliveryExpress

  """Delivery of physical cards within France"""
  PhysicalCardDeliveryFrance

  """Delivery of physical cards outside of France"""
  PhysicalCardDeliveryIntl

  """Process of printing physical cards"""
  PhysicalCardPrinting

  """Processing judicial or administrative seizure"""
  ProcessingJudicialOrAdministrativeSeizure

  """B2B SEPA Direct Debit up to 200"""
  SepaDirectDebitInB2bLevel1

  """B2B SEPA Direct Debit more than 200"""
  SepaDirectDebitInB2bLevel2

  """Core SEPA Direct Debit up to 200"""
  SepaDirectDebitInCoreLevel1

  """Core SEPA Direct Debit more than 200"""
  SepaDirectDebitInCoreLevel2

  """Return of a Core SEPA Direct Debit"""
  SepaDirectDebitInCoreReturn

  """Unauthorized overdraft"""
  UnauthorizedOverdraft
}

"""Fee Transaction"""
type FeeTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire reference chain.
  """
  reference: String!

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """feesType"""
  feesType: FeesTypeEnum!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """creditor information"""
  creditor: FeeCreditor!

  """debtor information"""
  debtor: FeeDebtor!

  """matching account for the transaction"""
  account: Account

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction
}

interface Field {
  key: String!
  name: String!
  required: Boolean!
}

enum FieldValidationError {
  Missing
}

input FinalizeOnboardingInput {
  onboardingId: String!
}

union FinalizeOnboardingPayload = FinalizeOnboardingSuccessPayload | InternalErrorRejection | ForbiddenRejection | OnboardingNotCompletedRejection | ValidationRejection

type FinalizeOnboardingSuccessPayload {
  onboarding: Onboarding!
}

type FinancialInstitution {
  id: ID!
  name: String!
  country: CCA3!
}

type ForbiddenRejection implements Rejection {
  message: String!
}

type FundingLimit {
  """Maximum Funding Amount authorized"""
  amount: Amount!

  """Funding Amount that has already been used during the interval"""
  funding: Amount

  """Interval in number of calendar days where the limit is applied"""
  rollingDays: Int!
}

"""Funding Limit Amount"""
type FundingLimitAmount {
  """The amount settings"""
  amount: Amount!
}

"""Funding Limit Amount Input"""
input FundingLimitAmountInput {
  """The amount settings"""
  amount: AmountInput!
}

"""Rejection returned when the Account Holder Funding has been exceeded"""
type FundingLimitExceededRejection implements Rejection {
  message: String!
}

type FundingLimitSettings {
  """Instant funding limit"""
  instantFundingLimit: InstantFundingLimit

  """Periodic funding limit"""
  fundingLimit: FundingLimit

  """Related change request"""
  fundingLimitSettingsChangeRequest: FundingLimitSettingsChangeRequest

  """Status of the resource"""
  statusInfo: FundingLimitSettingsStatusInfo!
}

"""Funding Limit Settings Change Request"""
type FundingLimitSettingsChangeRequest {
  """Unique identifier of a funding limit settings change request"""
  id: ID!

  """Requested amount settings for the instant funding limit"""
  instantFundingLimit: FundingLimitAmount!

  """Requested amount settings for the funding limit"""
  fundingLimit: FundingLimitAmount!

  """
  Approved amount settings for the the instant funding limit and the funding limit
  """
  approved: ApprovedFundingLimit

  """Status of the request"""
  statusInfo: FundingLimitSettingsChangeRequestStatusInfo!

  """Date of creation"""
  createdAt: Date

  """Date of last update"""
  updatedAt: Date
}

"""
StatusInfo when funding limit settings change request has been approved
"""
type FundingLimitSettingsChangeRequestApprovedStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
  reason: String!
}

"""Funding Limit Settings Change Request Bad Amount Rejection"""
type FundingLimitSettingsChangeRequestBadAmountRejection implements Rejection {
  message: String!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type FundingLimitSettingsChangeRequestConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """FundingLimitSettingsChangeRequestEdge list"""
  edges: [FundingLimitSettingsChangeRequestEdge!]!
}

"""Implements the Relay Edge interface"""
type FundingLimitSettingsChangeRequestEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The FundingLimitSettingsChangeRequest"""
  node: FundingLimitSettingsChangeRequest!
}

"""
Filters that can be applied when listing funding limit settings change requests
"""
input FundingLimitSettingsChangeRequestFiltersInput {
  """The ids of the funding limit settings change requests"""
  id: [String!]

  """Status we want to filter on"""
  status: [FundingLimitSettingsChangeRequestStatus!]
}

"""
Field we can use when ordering that can be applied when listing funding limit settings change requests
"""
enum FundingLimitSettingsChangeRequestOrderByFieldInput {
  id
  createdAt
  updatedAt
}

"""
Order that can be applied when listing funding limit settings change requests
"""
input FundingLimitSettingsChangeRequestOrderByInput {
  field: FundingLimitSettingsChangeRequestOrderByFieldInput
  direction: OrderByDirection
}

"""StatusInfo when funding limit settings change request is pending"""
type FundingLimitSettingsChangeRequestPendingStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
}

"""
StatusInfo when funding limit settings change request has been rejected
"""
type FundingLimitSettingsChangeRequestRefusedStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
  reason: String!
}

"""Funding Limit Settings Change Request Status"""
enum FundingLimitSettingsChangeRequestStatus {
  """When the request is in waiting for information"""
  WaitingForInformation

  """When the request is in pending"""
  Pending

  """When the request is approved"""
  Approved

  """When the request is refused"""
  Refused
}

"""
Object containing details about funding limit settings change request status
"""
interface FundingLimitSettingsChangeRequestStatusInfo {
  """Current limit settings change request status."""
  status: FundingLimitSettingsChangeRequestStatus!
}

"""
StatusInfo when funding limit settings change request is waiting for more information
"""
type FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
}

"""Possible values for funding limit settings status"""
enum FundingLimitSettingsStatus {
  """When the funding limit settings is enabled"""
  Enabled

  """When the funding limit settings is suspended"""
  Suspended

  """When the funding limit settings is disabled"""
  Disabled
}

"""Object containing details about funding limit settings status"""
interface FundingLimitSettingsStatusInfo {
  """Current funding limit settings."""
  status: FundingLimitSettingsStatus!
}

"""Funding Source"""
interface FundingSource {
  """ID of the Funding Source"""
  id: ID!

  """Name of the Funding Source"""
  name: String

  """Funding Source status information"""
  statusInfo: FundingSourceStatusInfo!

  """Created date"""
  createdAt: DateTime!

  """Last updated date"""
  updatedAt: DateTime!
}

"""Please see the Connection interface"""
type FundingSourceConnection implements Connection {
  pageInfo: PageInfo!
  edges: [FundingSourceEdge!]!
  totalCount: Int!
}

"""Please see the Connection interface"""
type FundingSourceEdge implements Edge {
  node: FundingSource!
  cursor: String!
}

"""Filters that can be applied when listing Funding Sources"""
input FundingSourceFiltersInput {
  status: [FundingSourceStatus!]!
}

type FundingSourceNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""
Field we can use when ordering that can be applied when listing funding source results
"""
enum FundingSourceOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing funding source results"""
input FundingSourceOrderByInput {
  field: FundingSourceOrderByFieldInput
  direction: OrderByDirection
}

"""Funding Source Statuses"""
enum FundingSourceStatus {
  Pending
  Enabled
  Canceled
  Rejected
  Suspended
}

"""Funding Source status information"""
interface FundingSourceStatusInfo {
  """Funding Source Pending status"""
  status: FundingSourceStatus!
}

"""
Rejection returned when the Funding Source is not in the expected status
"""
type FundingSourceWrongStatusRejection implements Rejection {
  message: String!
  currentStatus: FundingSourceStatus!
  expectedStatus: FundingSourceStatus!
}

"""Inputs to generate an account"""
input GenerateAccountStatementInput {
  """Unique identifier of an account"""
  accountId: ID!

  """starting date of the date window"""
  openingDate: DateTime!

  """ending date of the date window"""
  closingDate: DateTime!

  """language to generate the statement in (default to account's language)"""
  language: AccountLanguage

  """Type of statement to generate"""
  statementType: StatementType = PDF
}

input GenerateCapitalDepositDocumentUploadUrlInput {
  """Unique identifier of the document."""
  documentId: ID!

  """
  Unique identifier of the capitalDepositCase associated to the document.
  """
  capitalDepositCaseId: ID!

  """Filename of the document."""
  filename: String!
}

union GenerateCapitalDepositDocumentUploadUrlPayload = GenerateCapitalDepositDocumentUploadUrlSuccessPayload | CapitalDepositDocumentCanNotBeUploaded | CapitalDepositDocumentCanNotBeUploadedRejection | ForbiddenRejection | BadRequestRejection | InternalErrorRejection

type GenerateCapitalDepositDocumentUploadUrlSuccessPayload {
  """URL to be used to upload the document."""
  uploadUrl: String
}

input GenerateSupportingDocumentUploadUrlInput {
  """Unique identifier of a supporting document collection"""
  supportingDocumentCollectionId: ID!

  """Type of document"""
  supportingDocumentType: SupportingDocumentType

  """Name of the document which will be sent"""
  filename: String!

  """Purpose of document"""
  supportingDocumentPurpose: SupportingDocumentPurposeEnum
}

union GenerateSupportingDocumentUploadUrlPayload = GenerateSupportingDocumentUploadUrlSuccessPayload | SupportingDocumentCollectionNotFoundRejection | ForbiddenRejection | InternalErrorRejection | SupportingDocumentUploadNotAllowedRejection | ValidationRejection

type GenerateSupportingDocumentUploadUrlSuccessPayload {
  """Id of the supporting document created for this uploadUrl"""
  supportingDocumentId: String!

  """
  Info to upload the document : url and fields to add along file in form (POST)
  """
  upload: SupportingDocumentUploadInfo!
}

"""Rejection returned when the Global Funding has been exceeded"""
type GlobalFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the Global Instant Funding limit has been exceeded
"""
type GlobalInstantFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""Input of the `grantConsentWithServerSignature` mutation"""
input GrantConsentWithServerSignatureInput {
  """ID of the consent to grant"""
  consentId: ID!

  """Consent challenge signed with server consent credentials"""
  signature: String!
}

"""Payload of the `grantConsentWithServerSignature` mutation"""
union GrantConsentWithServerSignaturePayload = GrantConsentWithServerSignatureSuccessPayload | ConsentNotFoundRejection | NotReachableConsentStatusRejection | ForbiddenRejection | ConsentTypeNotSupportedByServerConsentRejection | ServerConsentNotAllowedForConsentOperationRejection | ProjectNotFoundRejection | ServerConsentNotAllowedForProjectRejection | ServerConsentProjectSettingsNotFoundRejection | ServerConsentProjectCredentialMissingRejection | ServerConsentProjectCredentialNotFoundRejection | ServerConsentCredentialsNotValidOrOutdatedRejection | ServerConsentSignatureNotValidRejection

"""Success payload of the `grantConsentWithServerSignature` mutation"""
type GrantConsentWithServerSignatureSuccessPayload {
  consent: Consent!
}

type Headquarters {
  town: String!
  zipCode: String!
  address: String!
}

scalar HexColorCode

"""International Bank Account Number"""
scalar IBAN

"""Rejection returned when the IBAN is not reachable"""
type IBANNotReachableRejection implements Rejection {
  message: String!
}

"""Rejection returned when the IBAN is not valid"""
type IBANNotValidRejection implements Rejection {
  message: String!
}

"""Virtual IBAN Status"""
enum IBANStatus {
  """When the virtual IBAN accept to receive Sepa payments"""
  Enabled

  """When the virtual IBAN refuse definitely to receive Sepa payments"""
  Canceled

  """When the virtual IBAN refuse temporarily to receive Sepa payments"""
  Suspended
}

"""ibanValidation input"""
input IbanValidationInput {
  """IBAN to validate"""
  iban: IBAN!
}

type IbanValidationRejection implements Rejection {
  message: String!
}

"""IbanValidationResult"""
union IbanValidationResult = ValidIban | InvalidIban

"""The document corresponding to an ID card"""
type IdCardDocument {
  """Unique identifier of the ID card document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """The date at which the ID card was issued"""
  issueDate: Date

  """The date at which the ID card expires"""
  expiryDate: Date

  """Machine-readable zone code of the ID card"""
  mrz: String

  """Number of the ID card"""
  number: String

  """List of the associated files"""
  files: [IdCardDocumentFile!]!
}

"""The file associated to the ID card document"""
type IdCardDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!

  """From which side the ID card's picture was taken"""
  side: DocumentFileSide!
}

"""
The identification represents an ongoing identification process or its result
"""
type Identification {
  """Unique identifier of the identification"""
  id: String!

  """Creation date of the identification"""
  createdAt: DateTime!

  """Last update date of the identification"""
  updatedAt: DateTime!

  """The global status of the identification"""
  status: SwanIdentificationStatus!

  """The process that was used for this identification"""
  process: IdentificationProcess!

  """
  The status and results associated to the available identification processes
  """
  levels: IdentificationLevelStatusesInfo!

  """
  The available documents related to the identification (id doc, selfie, report...)
  """
  documents: [IdentificationDocument!]

  """
  The identity document type used for the current identification (passport, id card ...)
  """
  identityDocumentType: IdentityDocumentType
}

"""
Fields we can use when ordering that can be applied when listing identifications
"""
type IdentificationConnection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo

  """IdentificationEdge list"""
  edges: [IdentificationEdge!]!
}

"""Union representing all the possible identification document types"""
union IdentificationDocument = IdCardDocument | PassportDocument | ResidencePermitDocument | DriversLicenseDocument | FacePhotoDocument | ReportDocument

"""Implements the Relay Edge interface"""
type IdentificationEdge implements Edge {
  """The identification entry"""
  node: Identification!

  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

"""
Filter that can be passed to get the identifications in specific data ranges
"""
input IdentificationFiltersInput {
  """To filter on status values"""
  statuses: [SwanIdentificationStatus!]

  """To filter on level values"""
  levels: [IdentificationLevel!]

  """To filter on process values"""
  processes: [IdentificationProcess!]
}

"""The various reasons that can lead to an invalid identification level"""
enum IdentificationInvalidReason {
  """Face must be fully present in the photo"""
  AbsentOrIncompleteFace

  """Applicant used a device that has been technically altered / modified"""
  AlteredDevice

  """Light on actual document is insufficient"""
  BadDocumentLighting

  """
  Something about the document is damaged (could be as tiny as a bent corner)
  """
  DamagedDocument

  """Expiry date of document has passed"""
  ExpiredDocument

  """Attempt to commit fraud detected"""
  FraudDetected

  """
  Video quality isnt sufficient or video is missing required information
  """
  InadequateVideo

  """Lighting on applicants face is insufficient"""
  InsufficientApplicantLighting

  """Applicant isnt meeting movement requirements"""
  InsufficientApplicantLiveness

  """Internet connection quality is insufficient"""
  InsufficientConnectionQuality

  """Video of document doesnt meet movement requirements"""
  InsufficientDocumentLiveness

  """Document is blurry or otherwise distorted"""
  InsufficientDocumentReadability

  """Face is blurry or otherwise distorted"""
  InsufficientFaceReadability

  """Video is blurry or otherwise distorted"""
  InsufficientVideoReadability

  """There was a technical error"""
  InternalError

  """Address is not valid or accepted"""
  InvalidAddress

  """Identification data is invalid or missing"""
  InvalidOrMissingData

  """Applicant seems to be doing verification against their will"""
  InvoluntaryIdentification

  """Geolocation data is required but not available"""
  MissingGeolocationData

  """Applicant appears on unacceptable news list"""
  NegativeNewsHit

  """Applicants identity does not match the expected ID info"""
  NonMatchingIdentity

  """Applicant presented a duplicate of the document (digital or paper)"""
  NonOriginalDocument

  """Applicant appears on a sanctions list"""
  SanctionListHit

  """Applicant required to provide a second document"""
  SecondDocumentRequired

  """There was a technical error with the electronic signature process"""
  TechnicalSignatureError

  """The time to complete the signature timed out"""
  TimeoutSignatureFlow

  """Document not on list of acceptable document types"""
  UnacceptableDocument

  """Applicant is under the minimum required age"""
  UnderageApplicant
}

"""Possible value for the field IdentificationLevel"""
enum IdentificationLevel {
  """Human identity verification"""
  Expert

  """Identity verification with Qualified Electronic Signature"""
  QES

  """Identity verification with PVID"""
  PVID
}

"""User identification levels input payload."""
enum IdentificationLevelInput {
  """Identity verified by an expert (Ubble-like)"""
  Expert

  """
  Identity verified by an expert with a Remote Identity Verification Service
  """
  PVID

  """
  Identity verified by an expert and a Qualified Electronic Signature has been done
  """
  QES
}

"""Identification levels"""
type IdentificationLevels {
  PVID: Boolean!
  QES: Boolean!
  expert: Boolean!
}

"""
The status and results associated to the available identification processes
"""
type IdentificationLevelStatusesInfo {
  """The status and results associated to the expert level"""
  expert: IdentificationLevelStatusInfo!

  """
  The status and results associated to the Qualified Electronic Signature level
  """
  qes: IdentificationLevelStatusInfo!

  """
  The status and results associated to the Remote Identity Verification Service level
  """
  pvid: IdentificationLevelStatusInfo!
}

"""
Union representing all the possible statuses: not supported, not started, pending, valid, invalid, cancelled, expired
Each variant contains its relevant data, for example invalid contains a `reason` field, expired contains an `expiredAt` field, valid contains a `documents` field
"""
union IdentificationLevelStatusInfo = NotSupportedIdentificationLevelStatusInfo | NotStartedIdentificationLevelStatusInfo | StartedIdentificationLevelStatusInfo | PendingIdentificationLevelStatusInfo | ValidIdentificationLevelStatusInfo | InvalidIdentificationLevelStatusInfo | CanceledIdentificationLevelStatusInfo | ExpiredIdentificationLevelStatusInfo

"""Process of the identification"""
enum IdentificationProcess {
  """Identity verified by an expert"""
  Expert

  """
  Identity verified by an expert and a Qualified Electronic Signature has been done
  """
  QES

  """
  Identity verified by an expert with a Remote Identity Verification Service
  """
  PVID
}

"""
Fields we can use when ordering that can be applied when listing identifications
"""
enum IdentificationsOrderByField {
  createdAt
  updatedAt
}

"""Order that can be applied when listing identifications"""
input IdentificationsOrderByInput {
  """The field by which the Identification list should be ordered"""
  field: IdentificationsOrderByField

  """The order in which the Identification list should be ordered"""
  direction: OrderByDirection
}

"""Identification status"""
enum IdentificationStatus {
  """The user hasn't started the identity verification process yet."""
  Uninitiated

  """
  The user has gone through the identity verification process, but we are still processing their information.
  """
  Processing

  """
  The user has gone through the identity verification process, and we have determined that their identity is valid.
  The user now needs to go through the QES process to complete their identification.
  """
  ReadyToSign

  """
  The user has gone through the identity verification process, and we have determined that their identity is valid.
  """
  ValidIdentity

  """
  The user has gone through the identity verification process, but we were unable to determine if their
  identity is valid because the quality of the provided documents was insufficient.
  The user will have to start a new identification, which will update this status to `Processing`.
  """
  InsufficientDocumentQuality

  """
  The user has gone through the identity verification process, but we have determined that their identity is invalid.
  The user will have to start a new identification, which will update this status to `Processing`.
  """
  InvalidIdentity
}

"""
Rejection returned if identity and the account memberships are already bind
"""
type IdentityAlreadyBindToAccountMembershipRejection implements Rejection {
  accountId: String!
  identityId: String!
  message: String!
}

"""The type of the identity document"""
enum IdentityDocumentType {
  IdCard
  Passport
  ResidencePermit
  DriversLicense
}

"""Data used for in app provisioning"""
type InAppProvisioningData {
  """Cryptographic OTP used to pre-validate digitalization"""
  activationData: String!

  """
  Base64 public key used with the wallet provider public key to encrypt the card data
  """
  ephemeralPublicKey: String!

  """Encrypted card data"""
  encryptedData: String!

  """IV used to encrypt the card Data (Useful for Google Pay)"""
  iv: String

  """
  public key fingerprint of the key used to encrypt card data (Useful for Google Pay)
  """
  publicKeyFingerprint: String

  """
  hash algorithm used during encryption of the card data (Useful for Google Pay)
  """
  oaepHashingAlgorithm: String
}

"""Individual shareholder info."""
type IndividualShareholder {
  """Whether the shareholder is an individual or a company."""
  type: ShareholderType!

  """First name of the shareholder."""
  firstName: String!

  """Last name of the shareholder."""
  lastName: String!

  """Birth date of the shareholder."""
  birthDate: String!

  """CCA3 code for the country of nationality of the shareholder."""
  nationality: CCA3!
}

"""
Individual Ultimate Beneficial Owner
You need to describe the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company.
Please describe the company (s) that owns the company that wishes to open an account, when an individual holds in fine more than 25%
"""
type IndividualUltimateBeneficialOwner {
  """individual first name"""
  firstName: String

  """individual last name"""
  lastName: String

  """individual birth date"""
  birthDate: DateTime

  """individual birth city"""
  birthCity: String

  """individual birth city postal code"""
  birthCityPostalCode: String

  """individual birth country code"""
  birthCountryCode: CCA3

  """Information relating to the type of the UBO"""
  info: IndividualUltimateBeneficialOwnerInfo!

  """Individual beneficial owner Tax or Identification Number"""
  taxIdentificationNumber: String

  """Individual beneficial owner residency Address"""
  residencyAddress: AddressInformation

  """Individual beneficial owner title (Mr/Ms)"""
  title: TitleEnum
}

"""Define the type of the UBO"""
interface IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!
}

input IndividualUltimateBeneficialOwnerInput {
  """
  Individual beneficial owner first name. Length must be from 0 to 100 characters
  """
  firstName: String

  """
  Individual beneficial owner  last name. Length must be from 0 to 100 characters
  """
  lastName: String

  """Individual birth date. Must be a valid date"""
  birthDate: String

  """Individual birth city. Length must be from 0 to 100 characters"""
  birthCity: String

  """
  Individual birth city postal code. Length must be from 0 to 50 characters
  """
  birthCityPostalCode: String

  """Individual birth country code"""
  birthCountryCode: CCA3

  """Define UBO is an Indirect Owner"""
  indirect: Boolean

  """Define UBO is an Direct Owner"""
  direct: Boolean

  """
  Total of capital (in percentage, ex: 50 = 50%). Must be between 1 and 100.
  """
  totalCapitalPercentage: Float

  """Define UBO is a Legal Representative"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!

  """Individual beneficial owner Tax or Identification Number"""
  taxIdentificationNumber: String

  """Individual beneficial owner residency Address"""
  residencyAddress: AddressInformationInput

  """Individual ultimate beneficial owner title (Mr/Ms)"""
  title: TitleEnum
}

"""Individual Ultimate beneficial owner nature"""
enum IndividualUltimateBeneficialOwnerTypeEnum {
  """The Beneficial Owner is the representant legal"""
  LegalRepresentative

  """The Beneficial Owner have shares"""
  HasCapital

  """Other"""
  Other
}

"""Individual Ultimate Beneficial Owner Type Has Capital"""
type IndividualUltimateBeneficialOwnerTypeHasCapital implements IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!

  """Define UBO is an Indirect Owner"""
  indirect: Boolean

  """Define UBO is an Direct Owner"""
  direct: Boolean

  """Total of capital (in percentage, ex: 50 = 50%)"""
  totalCapitalPercentage: Float
}

"""Individual Ultimate Beneficial Owner Type Legal Representative"""
type IndividualUltimateBeneficialOwnerTypeLegalRepresentative implements IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!
}

"""Individual Ultimate Beneficial Owner Type Other"""
type IndividualUltimateBeneficialOwnerTypeOther implements IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!
}

"""Initiate credit transfers"""
input InitiateCreditTransfersInput {
  """account to be debited identified by number"""
  accountNumber: AccountNumber

  """account id to be debited identified by id"""
  accountId: ID

  """credit transfers (max 250 records)"""
  creditTransfers: [CreditTransferInput!]!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union InitiateCreditTransfersPayload = InitiateCreditTransfersSuccessPayload | AccountNotFoundRejection | ForbiddenRejection

type InitiateCreditTransfersSuccessPayload {
  payment: Payment!
}

"""Input to initiate a funding request"""
input InitiateFundingRequestInput {
  """ID of the funding source to be used to fund the concerned account"""
  fundingSourceId: ID!

  """
  Amount of the requested funding, i.e. amount that will credit the concerned Swan account and debit the external funding source.
  """
  amount: AmountInput!

  """
  Reference of the funding request that will be shown on the account holder statement and on the debtor account used.
  """
  reference: String

  """
  Label of the funding request that will be shown on the account holder statement and on the debtor account used
  Always starts with 'Partner Name' truncated at 19 characters followed by a space.
  If empty, default label is "Partner Name - Account Holder Name".
  """
  label: String

  """
  Url to which the authorized account member must be redirected once the consent has been finalized.
  """
  consentRedirectUrl: String!

  """
  When the funding request should be executed. If `null`, it will be executed as soon as possible.
  It is not possible to define this value when the option `isInstant` is set to true.
  """
  requestedExecutionAt: DateTime

  """
  *SOON TO BE DEPRECATED*
  If `true` the funds should be available immediately. If `false` or `null`, the funds will be available
  after the resolution of the credit transaction.
  """
  isInstant: Boolean
}

"""Initiate A Funding Request Payload"""
union InitiateFundingRequestPayload = InitiateFundingRequestSuccessPayload | ForbiddenRejection | ValidationRejection | FundingLimitExceededRejection | ProjectFundingLimitExceededRejection | GlobalFundingLimitExceededRejection | FundingSourceWrongStatusRejection | FundingSourceNotFoundRejection | InsufficientFundsRejection | InstantFundingLimitExceededRejection | ProjectInstantFundingLimitExceededRejection | GlobalInstantFundingLimitExceededRejection | AccountVerificationWrongStatusRejection

"""Initiate A Funding Request Success Payload"""
type InitiateFundingRequestSuccessPayload {
  """Details of the funding payment created"""
  payment: Payment!
}

"""
*COMING SOON*
Input to create a quote and an international beneficiary
"""
input InitiateInternationalCreditTransferInput {
  """Account ID of the originator of the international credit transfer"""
  accountId: ID

  """Account number if the beneficiary is a swan account"""
  accountNumber: AccountNumber

  """Target amount of the international credit transfer"""
  targetAmount: AmountInput!

  """Beneficiary of the international credit transfer"""
  internationalBeneficiary: InternationalBeneficiaryInput!

  """Transfer details"""
  internationalCreditTransferDetails: [InternationalCreditTransferDetailsInput!]!

  """When the consent flow is finished the user is redirected to this URL"""
  consentRedirectUrl: String!

  """External reference"""
  externalReference: String

  """Language used to output errors"""
  language: InternationalCreditTransferDisplayLanguage
}

"""Initiate International Credit Transfer Response Payload"""
union InitiateInternationalCreditTransferResponsePayload = InitiateInternationalCreditTransferResponseSuccessPayload | AccountNotFoundRejection | ForbiddenRejection | InternalErrorRejection | ValidationRejection

"""Initiate International Credit Transfer Response Success Payload"""
type InitiateInternationalCreditTransferResponseSuccessPayload {
  """Details of the international credit transfer created"""
  payment: Payment!

  """Details for the quote of international credit transfer"""
  quote: InternationalCreditTransferQuote!
}

input InitiateMerchantPaymentCollectionInput {
  """
  Amount of the concerned payment collection. For check deposit, the amount should not exceed 10 000.
  """
  amount: AmountInput!

  """
  Label of the concerned payment collection, which will be displayed on Swan bank statement -
  For checks transaction, if empty, default label will be set as "Check N [1st part of CMC7 - 7 char.]
  """
  label: String

  """end-to-end reference of the concerned payment collection"""
  reference: String

  """
  external reference (JSON) that can be used by the Swan merchant for reconciliation purposes
  """
  externalReference: String

  """Internal direct debit type of payment collection"""
  internalDirectDebit: InternalDirectDebitPaymentCollectionInput

  """Check type of payment collection"""
  check: CheckPaymentCollectionInput

  """Sepa Direct Debit type of payment collection"""
  sepaDirectDebit: SepaDirectDebitPaymentCollectionInput
}

union InitiateMerchantPaymentCollectionPayload = InitiateMerchantPaymentCollectionSuccessPayload | ForbiddenRejection | NotFoundRejection | InternalErrorRejection | ValidationRejection

type InitiateMerchantPaymentCollectionSuccessPayload {
  merchantPaymentCollection: Payment!
}

type InstantFundingLimit {
  """Maximum Instant Funding Amount authorized"""
  amount: Amount!

  """Instant Funding Amount that has already been used"""
  funding: Amount
}

"""
Rejection returned when the Account Holder Instant Funding limit has been exceeded
"""
type InstantFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""Rejection returned when the Available balance is insufficient"""
type InsufficientFundsRejection implements Rejection {
  message: String!
}

"""
*SOON TO BE DEPRECATED*
Internal Beneficiary
"""
type InternalBeneficiary implements Beneficiary {
  """unique identifier of a beneficiary"""
  id: ID

  """full name of the beneficiary"""
  name: String!

  """
  `true` if this new beneficiary is the account holder himself in an other financial institution.
  """
  isMyOwnIban: Boolean!

  """account number if the beneficiary is a swan account"""
  accountNumber: AccountNumber! @deprecated(reason: "because it is not already implemented (a default value is set).")
}

"""Internal Credit Transfer transaction"""
type InternalCreditTransfer implements Transaction {
  """unique identifier of the transaction"""
  id: ID!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire reference chain.
  """
  reference: String!

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """creditor information"""
  creditor: InternalCreditTransferCreditor!

  """debtor information"""
  debtor: InternalCreditTransferDebtor!

  """matching account for the transaction"""
  account: Account

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """r-transaction reason"""
  returnReason: TransactionReasonCode
}

"""Internal Credit Transfer creditor"""
interface InternalCreditTransferCreditor {
  """full name of the Creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Internal Credit Transfer debtor"""
interface InternalCreditTransferDebtor {
  """full name of the debtor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Internal Credit Transfer creditor for Incoming transaction"""
type InternalCreditTransferInCreditor implements InternalCreditTransferCreditor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Internal Credit Transfer debtor for Incoming transaction"""
type InternalCreditTransferInDebtor implements InternalCreditTransferDebtor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Internal Credit Transfer creditor for Outgoing transaction"""
type InternalCreditTransferOutCreditor implements InternalCreditTransferCreditor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Internal Credit Transfer debtor for Outgoing transaction"""
type InternalCreditTransferOutDebtor implements InternalCreditTransferDebtor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""InternalDirectDebitB2BMerchantPaymentMethod"""
type InternalDirectDebitB2BMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

input InternalDirectDebitB2BPaymentMethodInput {
  """If `true`, the Payment Method will be Pending Review"""
  activate: Boolean = false
}

"""Internal Direct Debit Creditor"""
type InternalDirectDebitCreditor {
  """unique identifier of the creditor account"""
  accountId: ID!
}

"""Internal Direct Debit Debtor"""
type InternalDirectDebitDebtor {
  """unique identifier of the debtor account"""
  accountId: ID!
}

interface InternalDirectDebitMandate {
  """
  Unique identifier of the internal direct debit mandate, generated by Swan
  """
  id: ID!
}

input InternalDirectDebitPaymentCollectionInput {
  """ID of the concerned payment mandate"""
  mandateId: ID!

  """Date at which the Swan merchant wishes the payment to be executed"""
  requestedExecutionAt: DateTime
}

enum InternalDirectDebitSequence {
  OneOff
  Recurring
}

"""InternalDirectDebitStandardMerchantPaymentMethod"""
type InternalDirectDebitStandardMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

input InternalDirectDebitStandardPaymentMethodInput {
  """If `true`, the Payment Method will be Pending Review"""
  activate: Boolean = false
}

"""Internal Direct Debit transaction"""
type InternalDirectDebitTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain.
  """
  reference: String!

  """payment method identifier used for this transaction: accountNumber"""
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """creditor information"""
  creditor: InternalDirectDebitCreditor!

  """debtor information"""
  debtor: InternalDirectDebitDebtor!

  """matching account for the transaction"""
  account: Account

  """matching Internal mandate for the transaction"""
  mandate: InternalDirectDebitMandate

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """reserved amount of the transaction computed with the rolling reserve."""
  reservedAmount: Amount

  """date on which reserved funds become available."""
  reservedAmountReleasedAt: DateTime

  """r-transaction reason"""
  returnReason: TransactionReasonCode
}

"""Rejection returned on unexpected server error"""
type InternalErrorRejection implements Rejection {
  message: String!
}

"""Payment direct debit mandate for Internal"""
type InternalPaymentDirectDebitMandate implements InternalDirectDebitMandate & PaymentDirectDebitMandate & PaymentMandate {
  """Unique identifier of the Internal Direct Debit Payment Mandate"""
  id: ID!

  """
  List of transactions associated with the Internal Payment Direct Debit Mandate.
  """
  transactions(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """Unique reference of the Internal Direct Debit Payment Mandate"""
  reference: String!

  """Internal Direct Debit Payment Mandate scheme"""
  scheme: InternalPaymentMandateScheme!

  """Internal Direct Debit Payment Mandate status information"""
  statusInfo: PaymentMandateStatusInfo!

  """Internal Direct Debit Payment Mandate sequence"""
  sequence: InternalPaymentMandateSequence!

  """Internal Direct Debit Payment Mandate PDF document URL"""
  mandateDocumentUrl: String!

  """Internal Direct Debit Payment Mandate debtor information"""
  debtor: InternalPaymentMandateDebtor!

  """Internal direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """Internal Direct Debit Payment Mandate creditor information"""
  creditor: InternalPaymentMandateCreditor!

  """Signature date of the Internal Direct Debit Payment Mandate"""
  signatureDate: Date

  """Creation date of the Internal Direct Debit Payment Mandate"""
  createdAt: DateTime!

  """Last Update date of the Internal Direct Debit Payment Mandate"""
  updatedAt: DateTime!

  """
  Date of the the last transaction executed for the concerned Internal Direct Debit Payment Mandate
  """
  executedAt: DateTime

  """Expiry date of the Internal Direct Debit Payment Mandate"""
  expiredAt: Date

  """Account Holder information"""
  accountHolder: AccountHolder!

  """Language that will be used to produce the mandate PDF document"""
  language: String!

  """Custom name of the mandate"""
  name: String
}

type InternalPaymentMandateCreditor implements PaymentMandateCreditor {
  """Internal Direct Debit Payment Mandate creditor UUID"""
  id: ID!

  """Internal Direct Debit Payment Mandate Creditor Idenfier"""
  identifier: ID!

  """Internal Direct Debit Payment Mandate creditor name"""
  name: String!

  """Internal Direct Debit Payment Mandate creditor address"""
  address: Address!
}

type InternalPaymentMandateDebtor implements PaymentMandateDebtor {
  """Internal Direct Debit Payment Mandate debtor name"""
  name: String!

  """Internal Direct Debit Payment Mandate debtor e-mail"""
  email: String!

  """Internal Direct Debit Payment Mandate debtor country"""
  country: CCA3!

  """
  Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries
  """
  address: Address

  """
  Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries
  """
  accountId: ID
}

enum InternalPaymentMandateScheme {
  """Internal Direct Debit Standard"""
  InternalDirectDebitStandard

  """Internal Direct Debit B2B"""
  InternalDirectDebitB2b
}

"""Internal Direct Debit Payment Mandate Sequence"""
enum InternalPaymentMandateSequence {
  """
  The Internal Direct Debit Payment Mandate can be used for recurrent collections
  """
  Recurring

  """The Internal Direct Debit Payment Mandate can be used only once"""
  OneOff
}

"""Received direct debit mandate for SEPA"""
type InternalReceivedDirectDebitMandate implements InternalDirectDebitMandate & ReceivedDirectDebitMandate {
  """
  Unique identifier of the received internal direct debit mandate, generated by Swan
  """
  id: ID!

  """
  List of transactions associated with the Internal Receive Direct Debit Mandate.
  """
  transactions(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """Version of the received internal direct debit mandate"""
  version: String!

  """Creation date of the received internal direct debit mandate"""
  createdAt: DateTime!

  """Last Update date of the received internal direct debit mandate"""
  updatedAt: DateTime!

  """Received internal direct debit Unique Mandate Reference (UMR)"""
  reference: String!

  """Received internal direct debit mandate scheme"""
  scheme: InternalReceivedDirectDebitMandateScheme!

  """Received internal direct debit mandate sequence"""
  sequence: InternalReceivedDirectDebitMandateSequence!

  """Received internal direct debit creditor"""
  creditor: InternalReceivedDirectDebitMandateCreditor!

  """Received internal direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """
  Date of the last internal direct debit transaction executed for the concerned received internal direct debit mandate
  """
  executedAt: DateTime

  """Date of signature of the received internal direct debit mandate"""
  signatureDate: Date

  """
  Expiry date of the received internal direct debit mandate, computed automatically (36 months from the executedAt date)
  """
  expiredAt: Date

  """
  Mandate status information of the received internal direct debit mandate
  """
  statusInfo: ReceivedDirectDebitMandateStatusInfo!

  """Account of the received internal direct debit mandate debtor"""
  account: Account

  """Iban of the received internal direct debit mandate debtor"""
  iban: IBAN!

  """Mandate name"""
  name: String
}

"""Internal received direct debit mandate creditor"""
type InternalReceivedDirectDebitMandateCreditor {
  """Creditor identifier"""
  identifier: String!

  """Name of the creditor"""
  name: String!

  """Address of the creditor"""
  address: Address!
}

"""Received internal direct debit mandate scheme"""
enum InternalReceivedDirectDebitMandateScheme {
  """
  When the received internal direct debit mandate can only be used for internal B2B direct debit transactions
  """
  InternalDirectDebitB2b

  """
  When the received internal direct debit mandate can only be used for internal Standard direct debit transactions
  """
  InternalDirectDebitStandard
}

"""Internal received direct debit mandate sequence"""
enum InternalReceivedDirectDebitMandateSequence {
  """
  When the authorisation is given once by the Debtor to collect only one single internal direct debit
  """
  OneOff

  """
  When the authorisation by the Debtor can be used for regular internal direct debits initiated by the Creditor
  """
  Recurrent
}

"""Address of an international beneficiary"""
input InternationalAddressInput {
  """Address 1"""
  address1: String

  """City"""
  city: String

  """Country"""
  country: String

  """Zip Code"""
  zipCode: String

  """State"""
  state: String
}

"""International Beneficiary Details"""
input InternationalBeneficiaryDetailsInput {
  """Key"""
  key: String!

  """Value"""
  value: String!
}

"""
*COMING SOON*
International Beneficiary Dynamic Forms
"""
type InternationalBeneficiaryDynamicForms {
  """
  *COMING SOON*
  Schemes
  """
  schemes: [Scheme!]!
}

"""
*COMING SOON*
International Beneficiary
"""
input InternationalBeneficiaryInput {
  """Account holder name"""
  name: String!

  """Currency of the international beneficiary account"""
  currency: Currency!

  """
  *COMING SOON*
  Currency-specific details of the beneficiary
  """
  details: [InternationalBeneficiaryDetailsInput!]!

  """
  *COMING SOON*
  Route that Swan will use to transfer the funds
  """
  route: InternationalCreditTransferRouteInput!
}

union InternationalCreditTransferCreditor = InternationalCreditTransferOutCreditor | InternationalCreditTransferInCreditor

"""International Currency Exchange / Quote"""
type InternationalCreditTransferCurrencyExchange {
  """Rate of the quote"""
  exchangeRate: String!

  """Fees"""
  feesAmount: Amount

  """Source amount of the quote"""
  sourceAmount: Amount

  """target amount of the quote"""
  targetAmount: Amount
}

union InternationalCreditTransferDebtor = InternationalCreditTransferOutDebtor | InternationalCreditTransferInDebtor

"""
International Credit Transfer - Currency-specific details of the beneficiary
"""
type InternationalCreditTransferDetails {
  """Key"""
  key: String!

  """Value"""
  value: String!
}

"""
*COMING SOON*
International Credit Transfer Details
"""
input InternationalCreditTransferDetailsInput {
  """
  *COMING SOON*
  Key
  """
  key: String!

  """
  *COMING SOON*
  Value
  """
  value: String!
}

"""Language: ISO 639-1 language code"""
enum InternationalCreditTransferDisplayLanguage {
  """British English"""
  en

  """Dutch"""
  nl

  """French"""
  fr

  """German"""
  de

  """Italian"""
  it

  """Portuguese"""
  pt

  """Spanish"""
  es
}

"""
*COMING SOON*
International Credit Transfer Dynamic Form
"""
type InternationalCreditTransferDynamicForm {
  """List of international transaction fields"""
  fields: [Field!]!

  """
  *COMING SOON*
  Number of fields that need to be updated to fill the form completely. Please re run the query internationalCreditTransferTransactionDetailsDynamicForm with updated refreshableFields if the value of this field is not 0
  """
  remainingFieldsToRefreshCount: Int!
}

"""International Credit Transfer In - Creditor info"""
type InternationalCreditTransferInCreditor {
  """Account holder name"""
  name: String!
}

type InternationalCreditTransferInDebtor {
  """Account holder name"""
  name: String!

  """Account Number"""
  accountNumber: String!

  """BIC"""
  bic: String
}

"""International Credit Transfer Out - Creditor info"""
type InternationalCreditTransferOutCreditor {
  """Currency of the international beneficiary account"""
  currency: Currency!

  """Currency-specific details of the beneficiary"""
  details: [InternationalCreditTransferDetails!]!

  """Account holder name"""
  name: String!

  """Route that Swan will use to transfer the funds"""
  route: InternationalCreditTransferRoute!
}

type InternationalCreditTransferOutDebtor {
  """Account holder name"""
  name: String!
}

"""
*COMING SOON*
International Quote
"""
type InternationalCreditTransferQuote {
  """Rate of the quote"""
  exchangeRate: String!

  """Source amount of the quote"""
  sourceAmount: Amount!

  """target amount of the quote"""
  targetAmount: Amount!

  """Fees"""
  feesAmount: Amount!
}

"""International Credit Transfer Route"""
enum InternationalCreditTransferRoute {
  """Unknown route"""
  Unknown

  """American ACH for low-value payments"""
  Aba

  """Argentinian local route"""
  Argentina

  """Australian local route"""
  Australian

  """Australian local route Bpay usually used for bill payments"""
  AustralianBpay

  """Brazilian local route"""
  Brazil

  """Canadian local route"""
  Canadian

  """Chilean local route"""
  Chile

  """Costa Rican local route"""
  CostaRica

  """Czech local route"""
  Czech

  """Emirate local route"""
  Emirates

  """
  American credit transfers service for large-value and time-critical payments
  """
  FedwireLocal

  """M-PAiSA"""
  FijiMobile

  """Faster Payment System"""
  HongKongFps

  """Hong Kong's local route"""
  Hongkong

  """Hungarian local route"""
  Hungarian

  """Local route using an IBAN as recipient account identifier"""
  Iban

  """Indian local route"""
  Indian

  """Indian instant payment system Unified Payments Interface"""
  IndianUpi

  """Canadian payment network Interac"""
  Interac

  """Israeli local route"""
  IsraeliLocal

  """Japanese local route"""
  Japanese

  """Kenyan local route"""
  KenyaLocal

  """Kenyan mobile payment network M-PESA"""
  KenyaMobile

  """Malaysian local route"""
  Malaysian

  """Malaysian payment network DuitNow"""
  MalaysianDuitnow

  """Mexican local route"""
  Mexican

  """Moroccan local route"""
  Morocco

  """Nepalese local route"""
  Nepal

  """New Zealand local route"""
  NewZealand

  """Filipino local route"""
  Philippines

  """Filipino mobile payment network"""
  PhilippinesMobile

  """Polish local route"""
  Polish

  """Ukranian local route"""
  PrivatBank

  """Singapore local route"""
  Singapore

  """Singapore mobile payment network PayNow"""
  SingaporePaynow

  """British local route"""
  SortCode

  """South African local route"""
  SouthAfrica

  """South Korean payment network Paygate"""
  SouthKoreanPaygate

  """South Korean payment network Paygate for corporates"""
  SouthKoreanPaygateBusiness

  """Swift"""
  SwiftCode

  """Thai local route"""
  Thailand

  """Turkish local route"""
  TurkishEarthport
}

"""International Credit Transfer Route"""
enum InternationalCreditTransferRouteInput {
  """American ACH for low-value payments"""
  Aba

  """Argentinian local route"""
  Argentina

  """Australian local route"""
  Australian

  """Australian local route Bpay usually used for bill payments"""
  AustralianBpay

  """Brazilian local route"""
  Brazil

  """Canadian local route"""
  Canadian

  """Chilean local route"""
  Chile

  """Costa Rican local route"""
  CostaRica

  """Czech local route"""
  Czech

  """Emirate local route"""
  Emirates

  """
  American credit transfers service for large-value and time-critical payments
  """
  FedwireLocal

  """M-PAiSA"""
  FijiMobile

  """Faster Payment System"""
  HongKongFps

  """Hong Kong's local route"""
  Hongkong

  """Hungarian local route"""
  Hungarian

  """Local route using an IBAN as recipient account identifier"""
  Iban

  """Indian local route"""
  Indian

  """Indian instant payment system Unified Payments Interface"""
  IndianUpi

  """Canadian payment network Interac"""
  Interac

  """Israeli local route"""
  IsraeliLocal

  """Japanese local route"""
  Japanese

  """Kenyan local route"""
  KenyaLocal

  """Kenyan mobile payment network M-PESA"""
  KenyaMobile

  """Malaysian local route"""
  Malaysian

  """Malaysian payment network DuitNow"""
  MalaysianDuitnow

  """Mexican local route"""
  Mexican

  """Moroccan local route"""
  Morocco

  """Nepalese local route"""
  Nepal

  """New Zealand local route"""
  NewZealand

  """Filipino local route"""
  Philippines

  """Filipino mobile payment network"""
  PhilippinesMobile

  """Polish local route"""
  Polish

  """Ukranian local route"""
  PrivatBank

  """Singapore local route"""
  Singapore

  """Singapore mobile payment network PayNow"""
  SingaporePaynow

  """British local route"""
  SortCode

  """South Korean payment network Paygate"""
  SouthKoreanPaygate

  """South Korean payment network Paygate for corporates"""
  SouthKoreanPaygateBusiness

  """South African local route"""
  SouthAfrica

  """Swift"""
  SwiftCode

  """Thai local route"""
  Thailand

  """Turkish local route"""
  TurkishEarthport
}

type InternationalCreditTransferTransaction implements Transaction {
  """matching account for this transaction"""
  account: Account

  """amount"""
  amount: Amount!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """created date"""
  createdAt: DateTime!

  """creditor information"""
  creditor: InternationalCreditTransferCreditor!

  """debtor information"""
  debtor: InternationalCreditTransferDebtor!

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """@deprecated(reason: "use `quote.feesAmount` instead")"""
  fees: Amount

  """unique identifier of the transaction"""
  id: ID!

  """instructed amount"""
  instructedAmount: Amount

  """instructed amount"""
  intermediaryBankFees: [Amount!]

  """label"""
  label: String!

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """payment associated to this transaction"""
  payment: Payment

  """ID of the payment associated to this transaction"""
  paymentId: String

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """quote given by our international provider"""
  currencyExchange: InternationalCreditTransferCurrencyExchange!

  """external identifier of the transaction"""
  reference: String!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """side (Credit or Debit)"""
  side: TransactionSide!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """type"""
  type: TransactionTypeEnum!

  """updated date"""
  updatedAt: DateTime!
}

"""Rejection returned on invalid argument error"""
type InvalidArgumentRejection implements Rejection {
  message: String!
  code: InvalidArgumentRejectionCode!
  fields: [InvalidArgumentRejectionField!]!
}

enum InvalidArgumentRejectionCode {
  INVALID_INPUT
}

type InvalidArgumentRejectionField {
  name: String!
  errors: [String!]!
}

"""Information about the invalidity of the IBAN"""
type InvalidIban {
  """Iban from input"""
  iban: IBAN!

  """Enum that can be used to discriminate on the error"""
  code: InvalidIbanCode!

  """Message that give a bit of context during development"""
  message: String!
}

"""InvalidIbanCode"""
enum InvalidIbanCode {
  """
  Iban is either too short (<2) or does not match this country's specified length
  """
  InvalidLength

  """
  We do not know this IBAN Structure (Meaning that the country code is probably wrong)
  """
  InvalidStructure

  """The IBAN does not verify the mod97 algorithm"""
  InvalidChecksum

  """We do not know the banking institution referenced in this IBAN."""
  InvalidBank
}

"""
Describes an invalid identification level for the process associated to this identification, and the invalid reason can be accessed
"""
type InvalidIdentificationLevelStatusInfo {
  """Always set to `Invalid`"""
  status: SwanIdentificationStatus!

  """The reasons why this identification level is invalid"""
  reasons: [IdentificationInvalidReason!]
}

"""Rejection returned if phone number is not well formatted"""
type InvalidPhoneNumberRejection implements Rejection {
  message: String!
}

"""Rejection returned if siren number is not well formatted"""
type InvalidSirenNumberRejection implements Rejection {
  message: String!
}

"""Invoice"""
type Invoice {
  """unique id"""
  id: ID!

  """account id"""
  accountId: ID!

  """name of the invoice"""
  name: String!

  """type of the invoice"""
  type: InvoiceType!

  """status of the invoice"""
  status: InvoiceStatus!

  """due amount"""
  amount: Amount!

  """temporary public url on which the file can be accessible"""
  url: String

  """date at which the link will not be useable anymore"""
  expiresAt: DateTime

  """starting date of the billing window"""
  openingDate: DateTime!

  """ending date of the billing window"""
  closingDate: DateTime!

  """creation date"""
  createdAt: DateTime!

  """last update date"""
  updatedAt: DateTime!
}

"""Please see the Connection interface"""
type InvoiceConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Int!
  edges: [InvoiceEdge!]!
}

"""Please see the Edge interface"""
type InvoiceEdge implements Edge {
  node: Invoice!
  cursor: String!
}

"""The different statuses of invoice"""
enum InvoiceStatus {
  Failed
  NotPaid
  Paid
  PaymentDue
  Pending
  Voided
}

enum InvoiceType {
  Invoice
  RefundNote
}

enum Language {
  de
  en
  fr
  it
  nl
  es
}

type LegalDocument {
  """ID of the legal document"""
  id: ID!

  """Type of the legal document"""
  type: LegalDocumentType!

  """Status of the Legal Document"""
  statusInfo: LegalDocumentStatusInfo!

  """Language of the Legal Document"""
  language: AccountLanguage!

  """Url to download the Document"""
  url: String!
}

type LegalDocumentActiveStatusInfo implements LegalDocumentStatusInfo {
  """
  LegalDocument status (always Active for type LegalDocumentActiveStatusInfo)
  """
  status: LegalDocumentStatus!

  """Creation date"""
  createdAt: DateTime!

  """Activation date"""
  activatedAt: DateTime
}

type LegalDocumentConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """LegalDocumentEdge list"""
  edges: [LegalDocumentEdge!]!
}

type LegalDocumentEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The account membership"""
  node: LegalDocument!
}

type LegalDocumentInactiveStatusInfo implements LegalDocumentStatusInfo {
  """
  LegalDocument status (always Inactive for type LegalDocumentInactiveStatusInfo)
  """
  status: LegalDocumentStatus!

  """Creation date"""
  createdAt: DateTime!

  """Activation date"""
  activatedAt: DateTime

  """Deactivation date"""
  deactivatedAt: DateTime
}

input LegalDocumentsFilterInput {
  status: LegalDocumentStatus
  type: LegalDocumentType
}

enum LegalDocumentStatus {
  """When the LegalDocument will be the next active on the account"""
  Upcoming

  """When the LegalDocument is currently active on the account"""
  Active

  """When the LegalDocument is no more active on the account"""
  Inactive
}

interface LegalDocumentStatusInfo {
  """LegalDocument Status"""
  status: LegalDocumentStatus!
}

enum LegalDocumentType {
  """Swan Terms & Conditions of Use"""
  SwanTCU
}

type LegalDocumentUpcomingStatusInfo implements LegalDocumentStatusInfo {
  """
  LegalDocument status (always Upcoming for type LegalDocumentUpcomingStatusInfo)
  """
  status: LegalDocumentStatus!

  """Creation date"""
  createdAt: DateTime!

  """Date when the LegalDocument will be activated"""
  effectiveDate: DateTime
}

type LegalRepresentativeAccountMembershipCannotBeDisabledRejection implements Rejection {
  accountMembershipId: String!
  message: String!
}

type LegalRepresentativeAccountMembershipCannotBeSuspendedRejection implements Rejection {
  id: String!
  message: String!
}

"""Language: ISO 639-1 language code"""
enum MandateLanguage {
  de
  en
  fr
  it
  nl
  es
  pt
  fi
}

input MembershipInfoInput {
  """Email address"""
  email: String!

  """Restricted to a user if necessary"""
  restrictedTo: RestrictedToInput!

  """
  `true` if this account membership can view account balances and transactions history
  """
  canViewAccount: Boolean!

  """`true` if this account membership can add or canceled beneficiaries"""
  canManageBeneficiaries: Boolean!

  """`true` if this account membership can initiate payments"""
  canInitiatePayments: Boolean!

  """
  `true` if this account membership can invite, update, suspend or resume account membership
  """
  canManageAccountMembership: Boolean!

  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean

  """Residency address of the member to be added"""
  residencyAddress: ResidencyAddressInput

  """Tax Identification Number of the user added"""
  taxIdentificationNumber: String
}

"""
Filters that can be applied when listing accounts (Only applied in user context)
"""
input MembershipsFilterInput {
  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean

  """Can the user initiate payments on this account"""
  canInitiatePayments: Boolean

  """Can the user manage account membership"""
  canManageAccountMembership: Boolean

  """Can the user manage beneficiaries"""
  canManageBeneficiaries: Boolean

  """Can the user view account"""
  canViewAccount: Boolean

  """Account memberships status/statuses we're looking for"""
  status: [AccountMembershipStatus!]

  """Filtered by email"""
  email: String

  """Filtered by first name"""
  firstName: String

  """Filtered by last name"""
  lastName: String

  """Searches email, first name, last name, and id"""
  search: String
}

"""MerchantCategoryDescription"""
enum MerchantCategoryDescription {
  AccessoryAndApparelStoresMiscellaneous
  AccountingAuditingAndBookkeepingServices
  AdvertisingServices
  AgriculturalCooperatives
  AirCarriersAirlinesNotElsewhereClassified
  AirConditioningAndRefrigerationRepairShops
  AirConditioningHeatingAndPlumbingContractors
  AirlinesAirCarriers
  AirportsAirportTerminalsFlyingFields
  AlterationsMendingSeamstressesTailors
  AmbulanceServices
  AmusementParksCarnivalsCircusesFortuneTellers
  AntiqueReproductionStores
  AntiqueShopsSalesRepairsAndRestorationServices
  ApplianceRepairShopsElectricalAndSmall
  AquariumsDolphinariumsZoosAndSeaquariums
  ArchitecturalEngineeringAndSurveyingServices
  ArtDealersAndGalleries
  ArtistSupplyStoresCraftShops
  AssociationsCivicSocialAndFraternal
  AthleticFieldsCommercialSportsProfessionalSportsClubsSportsPromoters
  AttorneysLegalServices
  AutomatedCashDisbursementsCustomerFinancialInstitution
  AutomobileAndTruckDealersSalesServiceRepairsPartsAndLeasing
  AutomobileAndTruckDealersUsedOnlySales
  AutomobileAssociations
  AutomobileParkingLotsAndGarages
  AutomobileRentalAgencyNotElsewhereClassified
  AutomotiveBodyRepairShops
  AutomotivePaintShops
  AutomotivePartsAccessoriesStores
  AutomotiveServiceShops
  AutomotiveTireStores
  AutoStoreHomeSupplyStores
  BailAndBondPayments
  Bakeries
  BandsOrchestrasAndMiscellaneousEntertainersNotElsewhereClassified
  BarberAndBeautyShops
  BarsCocktailLoungesDiscothequesNightclubsAndTavernsDrinkingPlacesAlcoholicBeverages
  BicycleShopsSalesAndService
  BoatDealers
  BoatLeasesAndBoatRentals
  BooksPeriodicalsAndNewspapers
  BookStores
  BowlingAlleys
  BridgeAndRoadFeesTolls
  BuildingMaterialsLumberStores
  BusinessServicesNotElsewhereClassified
  BusLines
  BuyingOrShoppingClubsServices
  CableSatelliteAndOtherPayTelevisionAndRadioServices
  CameraAndPhotographicSupplyStores
  CamperDealersRecreationalAndUtilityTrailers
  CampgroundsAndTrailerParks
  CandyNutConfectioneryStores
  CardGiftNoveltyAndSouvenirShops
  CarpentryContractors
  CarpetAndUpholsteryCleaning
  CarRentalAgencies
  CarWashes
  Caterers
  ChemicalsAndAlliedProductsNotElsewhereClassified
  ChildCareServices
  ChildrenAndInfantsWearStores
  ChiropodistsPodiatrists
  Chiropractors
  CigarStoresAndStands
  CleaningAndMaintenanceJanitorialServices
  CleaningGarmentAndLaundryServices
  ClockJewelryAndWatchRepairShops
  ClockJewelryWatchAndSilverwareStore
  ClothingRentalCostumesUniformsAndFormalWear
  ClubsCountryClubsMembershipAthleticRecreationSportsPrivateGolfCourses
  CollegesUniversitiesProfessionalSchoolsAndJuniorColleges
  CommercialArtGraphicsPhotography
  CommercialEquipmentNotElsewhereClassified
  CommercialFootwear
  ComputerMaintenanceRepairAndServicesNotElsewhereClassified
  ComputerNetworkOrInformationServices
  ComputerProgrammingDataProcessingAndIntegratedSystemsDesignServices
  ComputersComputerPeripheralEquipmentSoftware
  ComputerSoftwareStores
  ConcreteWorkContractors
  ConstructionMaterialsNotElsewhereClassified
  ConsultingManagementAndPublicRelationsServices
  ConsumerCreditReportingAgencies
  ContractorsSpecialTradeNotElsewhereClassified
  CosmeticStores
  CourierServiceAirAndGroundFreightForwarders
  CourtCostsIncludingAlimonyAndChildSupport
  CruiseLines
  CrystalAndGlasswareStores
  DairyProductsStores
  DanceHallsSchoolsAndStudios
  DatingServices
  DebtMarriagePersonalCounselingService
  DentalAndMedicalLaboratories
  DentalLaboratoryMedicalOphthalmicHospitalEquipmentAndSupplies
  DentistsOrthodontists
  DepartmentStores
  DetectiveAgenciesProtectiveAgenciesSecurityServicesIncludingArmoredCarsGuardDogs
  DigitalGoodsAudiovisualMediaIncludingBooksMoviesAndMusic
  DigitalGoodsGames
  DigitalGoodsMultiCategory
  DigitalGoodsSoftwareApplicationsExcludingGames
  DirectMarketingCatalogMerchants
  DirectMarketingCombinationCatalogAndRetailMerchants
  DirectMarketingContinuitySubscriptionMerchants
  DirectMarketingInboundTelemarketingMerchants
  DirectMarketingInsuranceServices
  DirectMarketingOtherDirectMarketersNotElsewhereClassified
  DirectMarketingOutboundTelemarketingMerchants
  DirectMarketingTravelRelatedArrangementServices
  DiscountStores
  DoctorsNotElsewhereClassified
  DoorToDoorSales
  DraperyUpholsteryAndWindowCoveringsStores
  DrugsDrugProprietorsAndDruggistsSundries
  DrugStoresPharmacies
  DryCleaners
  DurableGoodsNotElsewhereClassified
  DutyFreeStores
  EatingPlacesRestaurants
  ElectricalContractors
  ElectricalPartsAndEquipment
  ElectricRazorStoresSalesAndService
  ElectricVehicleCharging
  ElectronicRepairShops
  ElectronicSales
  EmploymentAgenciesTemporaryHelpServices
  EquipmentFurnitureAndHomeFurnishingsStoresExceptAppliances
  EquipmentRentalAndLeasingServicesFurnitureRentalToolRental
  ExterminatingAndDisinfectingServices
  FabricNeedleworkPieceGoodsAndSewingStores
  FamilyClothingStores
  FastFoodRestaurants
  Fines
  FireplaceFireplaceScreensAndAccessoriesStores
  FloorCoveringStores
  Florists
  FloristsSuppliesNurseryStockAndFlowers
  FreezerLockerMeatProvisioners
  FuelDealersCoalFuelOilLiquefiedPetroleumWood
  FuelDispenserAutomated
  FuneralServiceAndCrematories
  FurnitureReupholsteryAndRepairRefinishing
  FurriersAndFurShops
  GamblingTransactions
  GameToyAndHobbyShops
  GeneralContractorsResidentialAndCommercial
  GlassPaintWallpaperStores
  GolfCoursesPublic
  GovernmentLicensedHorseOrDogRacingUSRegionOnly
  GovernmentOwnedLotterySpecificCountries
  GovernmentOwnedLotteryUSRegionOnly
  GovernmentServicesNotElsewhereClassified
  GroceryStoresSupermarkets
  HardwareEquipmentAndSupplies
  HardwareStores
  HatCleaningShopsShoeRepairShopsShoeShineParlors
  HealthAndBeautySpas
  HealthPractitionersMedicalServicesNotElsewhereClassified
  HearingAidsSalesServiceSupplyStores
  HomeSupplyWarehouseStores
  HorticulturalAndLandscapingServices
  Hospitals
  HouseholdApplianceStores
  IndustrialSuppliesNotElsewhereClassified
  InformationRetrievalServices
  InsulationMasonryPlasteringStoneworkAndTileSettingContractors
  InsuranceSalesUnderwritingAndPremiums
  InternetGamblingUSRegionOnly
  IntraGovernmentPurchasesGovernmentOnly
  KeyEntryTelecomMerchantProvidingSingleLocalAndLongDistancePhoneCallsUsingACentralAccessNumberInANonFaceToFaceEnvironmentUsingKeyEntry
  LaundryServicesFamilyAndCommercial
  LawnAndGardenSupplyStores
  LeatherGoodsAndLuggageStores
  LimousinesAndTaxicabs
  LodgingHotelsMotelsResorts
  LodgingHotelsMotelsResortsNotElsewhereClassified
  ManualCashDisbursementsCustomerFinancialInstitution
  MarinasMarineServiceSupplies
  MassageParlors
  MenAndBoysClothingAndAccessoriesStores
  MenAndWomenClothingStores
  MenWomenAndChildrenUniformsAndCommercialClothing
  MerchandiseAndServicesCustomerFinancialInstitution
  MetalServiceCentersAndOffices
  MiscellaneousAndSpecialtyRetailStores
  MiscellaneousAutomotiveAircraftAndFarmEquipmentDealersNotElsewhereClassified
  MiscellaneousFoodStoresConvenienceStoresMarketsSpecialtyStores
  MiscellaneousGeneralMerchandiseStores
  MiscellaneousHouseFurnishingSpecialtyShops
  MiscellaneousPublishingAndPrinting
  MiscellaneousRepairShopsAndRelatedServices
  MobileHomeDealers
  MoneySendFunding
  MoneySendInterCountry
  MoneySendIntraCountry
  MoneyTransfer
  MotionPictureAndVideoTapeProductionAndDistribution
  MotionPictureTheaters
  MotorcycleShopsAndDealers
  MotorFreightCarriersTruckingLocalLongDistanceMovingAndStorageCompaniesLocalDelivery
  MotorHomeAndRecreationalVehicleRental
  MotorHomeDealers
  MotorVehicleSuppliesAndNewParts
  MusicStoresMusicalInstrumentsPianosSheetMusic
  NewsDealersAndNewsstands
  NondurableGoodsNotElsewhereClassified
  NursingAndPersonalCareFacilities
  OfficeAndCommercialFurniture
  OfficePhotographicPhotocopyAndMicrofilmEquipment
  OfficeSchoolSupplyAndStationeryStores
  OpticiansOpticalGoodsAndEyeglasses
  OptometristsOphthalmologists
  OrganizationsCharitableAndSocialService
  OrganizationsMembershipNotElsewhereClassified
  OrganizationsPolitical
  OrganizationsReligious
  OrthopedicGoodsArtificialLimbStores
  OsteopathicPhysicians
  OtherServicesNotElsewhereClassified
  PackageStoresBeerWineAndLiquor
  PaintsVarnishesAndSupplies
  PassengerRailways
  PawnShops
  PaymentTransactionCustomerFinancialInstitution
  PaymentTransactionMerchant
  PetroleumAndPetroleumProducts
  PetShopsPetFoodAndSupplies
  PhotoDevelopingPhotofinishingLaboratories
  PhotographicStudios
  PieceGoodsNotionsAndOtherDryGoods
  PlumbingAndHeatingEquipment
  PoiFundingTransactions
  PoolAndBilliardEstablishments
  PostalServicesGovernmentOnly
  PreciousStonesAndMetalsWatchesAndJewelry
  ProfessionalServicesNotElsewhereClassified
  PublicWarehousingFarmProductsRefrigeratedGoodsHouseholdGoodsStorage
  QuasiCashCustomerFinancialInstitution
  QuasiCashMerchant
  QuickCopyReproductionAndBlueprintingServices
  RailroadsFreight
  RealEstateAgentsAndManagersRentals
  RecordShops
  RecreationalAndSportingCamps
  RecreationServicesNotElsewhereClassified
  ReligiousGoodsStores
  RoofingAndSidingSheetMetalWorkContractors
  SalvageAndWreckingYards
  SanitationPolishingAndSpecialtyCleaningPreparations
  SchoolsAndEducationalServicesNotElsewhereClassified
  SchoolsBusinessAndSecretarial
  SchoolsCorrespondence
  SchoolsElementaryAndSecondary
  SchoolsTradeAndVocational
  SecondHandStoresUsedMerchandiseStores
  SecuritiesBrokersDealers
  ServiceStationsWithOrWithoutAncillaryServices
  ShoeStores
  SnowmobileDealers
  SportingGoodsStores
  SportsApparelRidingApparelStores
  StampAndCoinStoresPhilatelicAndNumismaticSupplies
  StationeryOfficeSuppliesPrintingAndWritingPaper
  StenographicAndSecretarialSupportServices
  SwimmingPoolsSalesAndSupplies
  TaxPayments
  TaxPreparationService
  TelecommunicationEquipmentIncludingTelephoneSales
  TelecommunicationServicesIncludingButNotLimitedToPrepaidPhoneServicesAndRecurringPhoneServices
  TelegraphServices
  TentAndAwningShops
  TestingLaboratoriesNonMedical
  TheatricalProducersExceptMotionPicturesAndTicketAgencies
  Timeshares
  TireRetreadingAndRepairShops
  TouristAttractionsAndExhibits
  TowingServices
  TransportationServicesNotElsewhereClassified
  TransportationSuburbanAndLocalCommuterPassengerIncludingFerries
  TravelAgenciesAndTourOperators
  TruckRental
  TypesettingPlateMakingAndRelatedServices
  TypewriterStoresRentalsSalesService
  Unknown
  UtilitiesElectricGasHeatingOilSanitaryWater
  VarietyStores
  VeterinaryServices
  VideoAmusementGameSupplies
  VideoEntertainmentRentalStores
  VideoGameArcadesOrEstablishments
  WeldingRepair
  WholesaleClubs
  WigAndToupeeShops
  WomenAccessoryAndSpecialtyStores
  WomenReadyToWearStores
}

type MerchantPaymentLink {
  """Merchant payment link's unique ID."""
  id: String!

  """ID of the related project"""
  projectId: ID!

  """The URL at which the customer can complete the payment."""
  url: String!

  """The merchant payment link status."""
  statusInfo: MerchantPaymentLinkStatusInfo!

  """The Merchant Profile to link this Payment Link to"""
  merchantProfile: MerchantProfile!

  """Amount to be paid to sucessfully complete the payment."""
  amount: Amount!

  """
  Merchant Website URL to redirect the user to when the payment is completed.
  """
  redirectUrl: String!

  """URL to redirect the user to if they cancel their payment"""
  cancelRedirectUrl: String!

  """
  Controls if the payment mandate created from this payment link is for one-time use or can be reused
  This is applicable for card and SEPA Direct Debit payment methods only.
  """
  sequence: PaymentLinkSequenceType!

  """
  The customer billing Address
  These fields should be completed also to pre-fill a SEPA direct debit mandate.
  
  We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes
  """
  billingAddress: Address

  """
    A date that reflects the time at which the user asked the transaction to be executed.
  For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
  For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
  
  Default value means that the execution will be as soon as possible
  """
  requestedExecutionAt: DateTime

  """
  Any string that you want to be attached to this payment link.
  Usually something to help you reference the link in an external system.
  """
  externalReference: String

  """
  Optional field intended to provide a way for you to include a reference number or code.
  The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different.
  """
  reference: String

  """
  The language used for the payment page.
  Default is the browser's language, or English if not available.
  """
  language: String

  """
  Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page.
  """
  label: String

  """
   We will use the information specified here to prefill the payment link fields
  depending on the payment method the end user chooses.
  Keep in mind that your end customer will be able to edit these fields.
  """
  customer: Customer

  """
  List of payment methods IDs enabled for this payment link.
  If the array is empty Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit)
  """
  paymentMethods: [MerchantPaymentMethod!]!
}

enum MerchantPaymentLinkStatus {
  """Customers can still use the merchant payment link to pay."""
  Active

  """The merchant payment link is expired."""
  Expired

  """The customer completed the payment."""
  Completed

  """The customer cancel the payment."""
  Canceled
}

interface MerchantPaymentLinkStatusInfo {
  status: MerchantPaymentLinkStatus!
}

"""Base object for the different Payment Methods available"""
interface MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

"""Rejection returned when the Merchant Payment Method is not active"""
type MerchantPaymentMethodNotActiveRejection implements Rejection {
  paymentMethodIds: [String!]
  message: String!
}

"""The different statuses a MerchantPaymentMethod can have"""
enum MerchantPaymentMethodStatus {
  PendingReview
  Enabled
  Rejected
  Disabled
  Canceled
  Suspended
}

"""The payment method status information"""
interface MerchantPaymentMethodStatusInfo {
  """Merchant Payment Method Status"""
  status: MerchantPaymentMethodStatus!
}

"""The different statuses a MerchantPaymentMethod can have"""
enum MerchantPaymentMethodType {
  InternalDirectDebitStandard
  InternalDirectDebitB2b
  SepaDirectDebitCore
  SepaDirectDebitB2b
  Check
  Card
}

"""Merchant Profile"""
type MerchantProfile {
  """The Merchant Profile ID"""
  id: ID!

  """The Account ID this Merchant Profile is linked to"""
  accountId: ID!

  """
  Business name of the merchant, i.e. name that will be displayed on debtors' bank statements
  """
  merchantName: String!

  """Url of the merchant's website"""
  merchantWebsite: String

  """Url of the merchant's logo"""
  merchantLogoUrl: String

  """The status of the merchant profile"""
  statusInfo: MerchantProfileStatusInfo!

  """
  Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
  """
  productType: ProductType!

  """Expected annual activity volumes for all payment method"""
  expectedMonthlyPaymentVolume: Amount!

  """Payment Methods associated"""
  merchantPaymentMethods: [MerchantPaymentMethod!]

  """Updates Requested associated"""
  requestedMerchantProfileUpdates: [RequestMerchantProfileUpdate!]

  """expected average basket value."""
  expectedAverageBasket: Amount!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!
}

type MerchantProfileConnection implements Connection {
  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """Edge list"""
  edges: [MerchantProfileEdge!]!

  """Total number of element in the list"""
  totalCount: Int!
}

type MerchantProfileEdge implements Edge {
  node: MerchantProfile!

  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

"""Filters that can be applied when listing Funding Sources"""
input MerchantProfileFiltersInput {
  status: [MerchantProfileStatus!]!
}

enum MerchantProfileOrderByFieldInput {
  createdAt
  updatedAt
}

input MerchantProfileOrderByInput {
  field: MerchantProfileOrderByFieldInput
  direction: OrderByDirection
}

"""Merchant Profile Statuses"""
enum MerchantProfileStatus {
  """A Merchant Profile is created in the PendingReview status"""
  PendingReview

  """Enabled"""
  Enabled

  """Rejected"""
  Rejected

  """Canceled"""
  Canceled

  """Suspended"""
  Suspended
}

"""Merchant Profile Status Information"""
interface MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
}

"""
Rejection returned when the Merchant Profile is not in the expected status
"""
type MerchantProfileWrongStatusRejection implements Rejection {
  message: String!
  currentStatus: MerchantProfileStatus!
  expectedStatus: MerchantProfileStatus!
}

"""Rejection returned when mandatory fields are missing from the call."""
type MissingMandatoryFieldRejection implements Rejection {
  message: String!
}

"""Monthly income."""
enum MonthlyIncome {
  """less than 500"""
  LessThan500

  """between 500 and 1500"""
  Between500And1500

  """between 1500 and 3000"""
  Between1500And3000

  """between 3000 and 4500"""
  Between3000And4500

  """more than 4500"""
  MoreThan4500
}

"""Monthly payment volume."""
enum MonthlyPaymentVolume {
  Between10000And50000
  Between50000And100000
  LessThan10000
  MoreThan100000
}

type Mutation {
  """
  Activate a Physical Card.
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have the account membership for this card
  """
  activatePhysicalCard(input: ActivatePhysicalCardInput!): ActivatePhysicalCardPayload!

  """
  Add a new account membership to an account.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
  
  *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.*
  """
  addAccountMembership(input: AddAccountMembershipInput!): AddAccountMembershipPayload!

  """
  Add multiple new account memberships to account
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
  
  *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.*
  """
  addAccountMemberships(input: AddAccountMembershipsInput!): AddAccountMembershipsPayload!

  """
  Add a new card to an account membership.
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.
  """
  addCard(input: AddCardInput!): AddCardPayload!

  """
  Add several cards with Group Delivery
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.
  """
  addCardsWithGroupDelivery(input: AddCardsWithGroupDeliveryInput!): AddCardsWithGroupDeliveryPayload!

  """
  Add several cards
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.
  """
  addCards(input: AddCardsInput!): AddCardsPayload!

  """
  Add a Digital Card to push to ApplePay or GooglePay
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must be the card holder
  
  A digital card will only be valid for 1 hour after consent validation
  """
  addDigitalCard(input: AddDigitalCardInput): AddDigitalCardPayload!

  """
  Add an external balance to an external account.
  
  This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  addExternalAccountBalance(input: AddExternalAccountBalanceInput!): AddExternalAccountBalancePayload! @deprecated(reason: "use `AddOrUpdateExternalAccountBalance` instead")

  """
  Add an external account to an account holder.
  
  This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  addExternalAccount(input: AddExternalAccountInput!): AddExternalAccountPayload!

  """
  Add a new request for funding limit settings change.
  
  This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  addFundingLimitSettingsChangeRequest(input: AddFundingLimitSettingsChangeRequestInput!): AddFundingLimitSettingsChangeRequestPayload!

  """
  Add an external balance to an external account. 
  If a balance already exist for the day, the balance amount will be updated.
  
  This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  addOrUpdateExternalAccountBalance(input: AddOrUpdateExternalAccountBalanceInput!): AddOrUpdateExternalAccountBalancePayload!

  """Add a new Single Use Virtual Card to an account membership."""
  addSingleUseVirtualCard(input: AddSingleUseVirtualCardInput!): AddSingleUseVirtualCardPayload!

  """
  Add several single-use virtual cards
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.
  """
  addSingleUseVirtualCards(input: AddSingleUseVirtualCardsInput!): AddSingleUseVirtualCardsPayload!

  """Add a new Virtual IBAN."""
  addVirtualIbanEntry(input: AddVirtualIbanInput): AddVirtualIbanEntryPayload

  """Allows to receive Sepa Direct Debit on a Virtual IBAN."""
  allowSddVirtualIbanEntry(input: AllowSddVirtualIbanEntryInput!): AllowSddVirtualIbanEntryPayload!

  """Allows to receive Sepa Direct Debit on an account."""
  allowSdd(input: AllowSddInput!): AllowSddPayload!

  """
  Bind a user to an account membership
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
  """
  bindAccountMembership(input: BindAccountMembershipInput!): BindAccountMembershipPayload!

  """Cancel a Card"""
  cancelCard(input: CancelCardInput): CancelCardPayload!

  """Cancel a Digital Card"""
  cancelDigitalCard(input: CancelDigitalCardInput): CancelDigitalCardPayload!

  """Cancel a physical card."""
  cancelPhysicalCard(input: CancelPhysicalCardInput): CancelPhysicalCardPayload!

  """Cancels a Virtual IBAN."""
  cancelVirtualIbanEntry(input: CancelVirtualIbanEntryInput!): CancelVirtualIbanEntryPayload!

  """
  Closes an account.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
  
  *The user must have a legal representative account membership for this account.*
  """
  closeAccount(input: CloseAccountInput!): CloseAccountPayload!

  """
  Delete a supporting document, in case uploaded file is not what was wanted. This action can not be undone.
  
  This mutation can only be used on an "Uploaded" supporting document of a "WaitingForDocument" supporting document collection.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  deleteSupportingDocument(input: DeleteSupportingDocumentInput!): DeleteSupportingDocumentPayload!

  """Allows to refuse all Sepa Direct Debit received on a Virtual IBAN."""
  denySddVirtualIbanEntry(input: DenySddVirtualIbanEntryInput!): DenySddVirtualIbanEntryPayload!

  """Allows to refuse all Sepa Direct Debit received on an account."""
  denySdd(input: DenySddInput): DenySddPayload!

  """
  Disable an account membership
  
  This mutation is callable with a User access token and a Project access token ([Learn More](https://docs.swan.io/api/authentication))
  
  With a User access token, the user must have the permission to manage account membership of the account
  """
  disableAccountMembership(input: DisableAccountMembershipInput): DisableAccountMembershipPayload!

  """
  Finalize an onboarding led to the opening of a new account for your client, who thus become the account holder.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)).*
  """
  finalizeOnboarding(input: FinalizeOnboardingInput!): FinalizeOnboardingPayload!

  """
  Creates an onboarding for a new company account holder.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  onboardCompanyAccountHolder(input: OnboardCompanyAccountHolderInput): OnboardCompanyAccountHolderPayload!

  """
  Creates an onboarding for a new individual account holder.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  onboardIndividualAccountHolder(input: OnboardIndividualAccountHolderInput): OnboardIndividualAccountHolderPayload!

  """
  Print Physical Card.
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  """
  printPhysicalCard(input: PrintPhysicalCardInput!): PrintPhysicalCardPayload!

  """
  Ask for Swan's compliance team to review given supporting document collection.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  requestSupportingDocumentCollectionReview(input: RequestSupportingDocumentCollectionReviewInput): RequestSupportingDocumentCollectionReviewPayload!

  """
  Resumes an account membership already suspended.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
  
  *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.*
  """
  resumeAccountMembership(input: ResumeAccountMembershipInput): ResumeAccountMembershipPayload!

  """
  Resume a Physical Card.
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have the account membership for this card
  """
  resumePhysicalCard(input: ResumePhysicalCardInput): ResumePhysicalCardPayload!

  """
  Suspends an account membership.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)).
  
  *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.*
  """
  suspendAccountMembership(input: SuspendAccountMembershipInput!): SuspendAccountMembershipPayload!

  """Suspend a Physical Card."""
  suspendPhysicalCard(input: SuspendPhysicalCardInput): SuspendPhysicalCardPayload!
  updateAccountHolder(input: UpdateAccountHolderInput!): UpdateAccountHolderPayload!

  """
  Updates an account membership.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
  
  *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.*
  """
  updateAccountMembership(input: UpdateAccountMembershipInput!): UpdateAccountMembershipPayload!

  """Update an account."""
  updateAccount(input: UpdateAccountInput!): UpdateAccountPayload!

  """Update a Card."""
  updateCard(input: UpdateCardInput): UpdateCardPayload

  """
  Updates a company onboarding.
  
  If you aim to update Ultimate Beneficiary Owners, you need to provide all of them as they are going to be overridden by your update payload.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  updateCompanyOnboarding(input: UpdateCompanyOnboardingInput): UpdateCompanyOnboardingPayload!

  """
  Updates an individual onboarding.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  updateIndividualOnboarding(input: UpdateIndividualOnboardingInput!): UpdateIndividualOnboardingPayload!
  updateSupportingDocument(input: UpdateSupportingDocumentInput!): UpdateSupportingDocumentPayload!

  """
  Reveal the card numbers in the consent page once consent has been given by the cardholder
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have the account membership for this card
  """
  viewCardNumbers(input: ViewCardNumbersInput!): ViewCardNumbersPayload!

  """
  Reveal the physical card numbers in the consent page once consent has been given by the cardholder
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have the account membership for this card
  """
  viewPhysicalCardNumbers(input: ViewPhysicalCardNumbersInput!): ViewPhysicalCardNumbersPayload!

  """
  Reveal the PIN code on Swan app after his consent
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have the account membership for this card
  """
  viewPhysicalCardPin(input: ViewPhysicalCardPinInput!): ViewPhysicalCardPinPayload!

  """
  Generate and return a presigned URL to upload a unique file for the supporting document collection
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  generateSupportingDocumentUploadUrl(input: GenerateSupportingDocumentUploadUrlInput!): GenerateSupportingDocumentUploadUrlPayload!

  """Generate an account statement"""
  generateAccountStatement(input: GenerateAccountStatementInput!): Statement!

  """
  Create a capital deposit case.
  
  This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  createCapitalDepositCase(input: CreateCapitalDepositCaseInput!): CreateCapitalDepositCasePayload!

  """
  Generate an url allowing the upload of a document which unique identifier is specified in parameters.
  
  This mutation is restricted to an Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  generateCapitalDepositDocumentUploadUrl(input: GenerateCapitalDepositDocumentUploadUrlInput!): GenerateCapitalDepositDocumentUploadUrlPayload!

  """Cancels a consent."""
  cancelConsent(input: CancelConsentInput!): CancelConsentPayload!

  """
  Create a multi consent, which represents a consent of several other consents,
  executed in parallel or sequentially depending on the `order` input value
  
  This mutation is restricted to a User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  """
  createMultiConsent(input: CreateMultiConsentInput!): CreateMultiConsentPayload

  """Grant consent with a server signature"""
  grantConsentWithServerSignature(input: GrantConsentWithServerSignatureInput!): GrantConsentWithServerSignaturePayload!

  """
  Updates user preferred consent notification channel.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  updateUserConsentSettings(input: UpdateUserConsentSettingsInput!): UpdateUserConsentSettingsPayload!

  """
  Allows to add a received internal direct debit mandate B2b.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
  
  *The user must be able to initiate payments for this account.*
  """
  addReceivedInternalDirectDebitB2bMandate(input: AddReceivedInternalDirectDebitB2bMandateInput!): AddReceivedInternalDirectDebitB2bMandatePayload!

  """
  Allows to add a received sepa direct debit mandate B2b.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
  
  *The user must be able to initiate payments for this account.*
  """
  addReceivedSepaDirectDebitB2bMandate(input: AddReceivedSepaDirectDebitB2bMandateInput!): AddReceivedSepaDirectDebitB2bMandatePayload!

  """
  Allows to enable a received mandate in the Suspended status.
  
  *For B2b received direct debit mandate, this mutation is restricted to an User access token([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
  
  *The user must be able to initiate payments for this account.*
  """
  enableReceivedDirectDebitMandate(input: EnableReceivedDirectDebitMandateInput!): EnableReceivedDirectDebitMandatePayload!

  """
  Allows to suspend a received direct debit mandate in the Enabled status.
  
  *The user must be able to initiate payments for this account.*
  """
  suspendReceivedDirectDebitMandate(input: SuspendReceivedDirectDebitMandateInput!): SuspendReceivedDirectDebitMandatePayload!

  """
  Allows to update a received sepa direct debit mandate B2b.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
  
  *The user must be able to initiate payments for this account.*
  """
  updateReceivedSepaDirectDebitB2bMandate(input: UpdateReceivedSepaDirectDebitB2bMandateInput!): UpdateReceivedSepaDirectDebitB2bMandatePayload!

  """Allows to add an internal direct debit payment mandate."""
  addInternalDirectDebitPaymentMandate(input: AddInternalDirectDebitPaymentMandateInput!): AddInternalDirectDebitPaymentMandatePayload!

  """Add a merchant profile to a company account holder"""
  addMerchantProfile(input: AddMerchantProfileInput!): AddMerchantProfilePayload
  addSepaDirectDebitPaymentMandate(input: AddSepaDirectDebitPaymentMandateInput!): AddSepaDirectDebitPaymentMandatePayload

  """Create a unique URL for a merchant to collect payment from a customer"""
  createMerchantPaymentLink(input: CreateMerchantPaymentLinkInput!): CreateMerchantPaymentLinkPayload!
  initiateMerchantPaymentCollection(input: InitiateMerchantPaymentCollectionInput!): InitiateMerchantPaymentCollectionPayload

  """Request merchant payment methods for a merchant profile"""
  requestMerchantPaymentMethods(input: RequestMerchantPaymentMethodsInput!): RequestMerchantPaymentMethodsPayload

  """Request an update of a MerchantProfile"""
  requestMerchantProfileUpdate(input: RequestMerchantProfileUpdateInput!): RequestMerchantProfileUpdatePayload

  """
  Cancels an UPCOMING credit transfer
  
   *The user must have an account membership for this account with the attribute `canInitiatePayments=true`.*
  """
  cancelTransaction(input: CancelTransactionInput!): CancelTransactionPayload!

  """
  Initiates a credit transfer to an other Swan account or to an IBAN
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and if necessary ask the user to consent to this request.*
  
  *The user must have an account membership for this account with the attribute `canInitiatePayments=true`.*
  """
  initiateCreditTransfers(input: InitiateCreditTransfersInput!): InitiateCreditTransfersPayload!

  """
  initiates a refund for a list of booked transaction
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and if necessary ask the user to consent to this request.*
  
  *The user must have an account membership on the accounts that are beneficiary of the transaction with the attribute `canInitiatePayments=true`.*
  """
  refund(input: RefundInput!): RefundPayload!

  """
  Add a funding source to an account
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.
  """
  addDirectDebitFundingSource(input: AddDirectDebitFundingSourceInput!): AddDirectDebitFundingSourcePayload

  """Cancel a funding source"""
  cancelFundingSource(input: CancelFundingSourceInput!): CancelFundingSourcePayload

  """
  Cancel a standing Order
  
  The user must have an account membership to the account and the permission to initiate credit transfer
  """
  cancelStandingOrder(input: CancelStandingOrderInput!): CancelStandingOrderPayload!

  """
  Initiate a funding request.
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  The user must have an account membership for this account with the attribute `canInitiateCreditTransfer=true`.
  """
  initiateFundingRequest(input: InitiateFundingRequestInput!): InitiateFundingRequestPayload

  """
  *COMING SOON*
  Create an international transfer
  """
  initiateInternationalCreditTransfer(input: InitiateInternationalCreditTransferInput!): InitiateInternationalCreditTransferResponsePayload

  """
  Schedule a standing Order
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership to the account and the permission to initiate credit transfer
  """
  scheduleStandingOrder(input: ScheduleStandingOrderInput!): ScheduleStandingOrderPayload!
}

"""
Rejection returned if the entity was not found or if the user does not have the rights to know that the account exists
"""
type NotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Rejection returned when consent status couldn't change"""
type NotReachableConsentStatusRejection implements Rejection {
  message: String!
  currentStatus: ConsentStatus
  unreachableStatus: ConsentStatus
}

"""
Describes an identification level that hasn't started for the process of the current identification
"""
type NotStartedIdentificationLevelStatusInfo {
  """Always set to `NotStarted`"""
  status: SwanIdentificationStatus!
}

"""
Rejection returned if the queried service doesn't support the country code
"""
type NotSupportedCountryRejection implements Rejection {
  message: String!
}

"""
Describes an identification level that's not supported for the process of the current identification
"""
type NotSupportedIdentificationLevelStatusInfo {
  """Always set to `NotSupported`"""
  status: SwanIdentificationStatus!
}

"""Extra parameters provided by partner"""
type OAuthRedirectParameters {
  """
  Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity.
  """
  state: String

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  """
  redirectUrl: String
}

input OAuthRedirectParametersInput {
  """
  Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity. Length must be from 0 to 255 characters
  """
  state: String

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. Length must be from 0 to 255 characters
  """
  redirectUrl: String
}

"""Inputs to onboard a new company account holder"""
input OnboardCompanyAccountHolderInput {
  """
  Account name of the company account holder.
  Length must be from 0 to 100 characters
  """
  accountName: String

  """Name of the company. Length must be from 0 to 255 characters"""
  name: String

  """
  Registration number of the company (SIRET, ...). Length must be from 0 to 50 characters
  """
  registrationNumber: String

  """Type of the company (Association ...)"""
  companyType: CompanyType

  """Business activity"""
  businessActivity: BusinessActivity

  """
  Business activity description. Length must be from 0 to 1024 characters
  """
  businessActivityDescription: String

  """
  Country of the account that will be created at the end of the onboarding process
  """
  accountCountry: AccountCountry

  """Estimated monthly payment volume (euro)"""
  monthlyPaymentVolume: MonthlyPaymentVolume

  """
  The ultimate beneficial owner is defined as the natural person (s) who own or control, directly and/or indirectly, the reporting company.
  
  The ultimate beneficial owner is :
  - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
  - either the natural person (s) who exercise, by other means, a power of control of the company;
  """
  individualUltimateBeneficialOwners: [IndividualUltimateBeneficialOwnerInput!]

  """Residency address of the head office (Must be in a European country)"""
  residencyAddress: ResidencyAddressInput

  """
  Email of the legal representative. Length must be from 0 to 255 characters
  """
  email: String

  """Language of the onboarding process. Must be compliant with RFC 5646"""
  language: String

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  Length must be from 0 to 255 characters
  """
  redirectUrl: String

  """Is company registered at RCS in its country"""
  isRegistered: Boolean

  """Extra parameters provided by partner"""
  oAuthRedirectParameters: OAuthRedirectParametersInput

  """VAT number"""
  vatNumber: String

  """Tax Identification Number"""
  taxIdentificationNumber: String

  """Legal representative personal address"""
  legalRepresentativePersonalAddress: AddressInformationInput

  """Type of representation (legal representative or power of attorney)"""
  typeOfRepresentation: TypeOfRepresentation
}

union OnboardCompanyAccountHolderPayload = OnboardCompanyAccountHolderSuccessPayload | BadRequestRejection | ForbiddenRejection | ValidationRejection

type OnboardCompanyAccountHolderSuccessPayload {
  onboarding: Onboarding!
}

"""Information on the shareholder."""
input OnboardCompanyShareholderInput {
  """Amount the shareholder has to deposit."""
  capitalDepositAmount: AmountInput!

  """Name ("Dnomination sociale") of the shareholder."""
  name: String!

  """Information required for the onboarding of a company shareholder."""
  onboardingInfo: OnboardCompanyAccountHolderInput!
}

"""Inputs to onboard a new individual account holder"""
input OnboardIndividualAccountHolderInput {
  """
  Account name of the individual account holder. Length must be from 0 to 255 characters
  """
  accountName: String

  """
  Country of the account that will be created at the end of the onboarding process
  """
  accountCountry: AccountCountry

  """Employment status of the individual account holder"""
  employmentStatus: EmploymentStatus

  """Monthly income of the individual account holder"""
  monthlyIncome: MonthlyIncome

  """
  Residency address of the individual account holder (must be in a European country)
  """
  residencyAddress: ResidencyAddressInput

  """Email. Length must be from 0 to 255 characters"""
  email: String

  """Language of the onboarding process. Must be compliant with RFC 5646"""
  language: String

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. Length must be from 0 to 255 characters
  """
  redirectUrl: String

  """Extra parameters provided by partner"""
  oAuthRedirectParameters: OAuthRedirectParametersInput

  """Tax Identification Number"""
  taxIdentificationNumber: String
}

union OnboardIndividualAccountHolderPayload = OnboardIndividualAccountHolderSuccessPayload | ForbiddenRejection | ValidationRejection

type OnboardIndividualAccountHolderSuccessPayload {
  onboarding: Onboarding!
}

"""Information on the shareholder."""
input OnboardIndividualShareholderInput {
  """First name of the shareholder."""
  firstName: String!

  """Last name of the shareholder."""
  lastName: String!

  """Birthdate of the shareholder in the YYYY/MM/DD format."""
  birthDate: String!

  """CCA3 code for the country of nationality of the shareholder."""
  nationality: CCA3!

  """Amount the shareholder has to deposit."""
  capitalDepositAmount: AmountInput!

  """Information required for the onboarding of a individual shareholder."""
  onboardingInfo: OnboardIndividualAccountHolderInput!
}

"""
Information provided during the onboarding process of an individual or a company
"""
type Onboarding {
  """Unique identifier of an onboarding"""
  id: String!

  """Account name"""
  accountName: String

  """Account Country"""
  accountCountry: AccountCountry!

  """Creation date"""
  createdAt: DateTime!

  """Email"""
  email: String

  """Finalization date"""
  finalizedAt: DateTime

  """
  Language of the onboarding process. This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)
  """
  language: String

  """Information regarding the Individual or the company to onboard"""
  info: OnboardingAccountHolderInfo!

  """Account holder created at the end of the onboarding process"""
  accountHolder: AccountHolder

  """
  Redirect the legal representative of a new account holder to this URL to start the onboarding process
  """
  onboardingUrl: String!

  """Current computed state of onboarding"""
  onboardingState: OnboardingState!

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  """
  redirectUrl: String! @deprecated(reason: "Use `redirectUrl` field on oauthRedirectParameters parameters instead.")

  """Extra parameters provided by partner"""
  oAuthRedirectParameters: OAuthRedirectParameters

  """Status (valid/invalid/finalized) and details of errors on fields"""
  statusInfo: OnboardingStatusInfo!

  """Swan TCU URL"""
  tcuUrl: String!

  """List of supporting document collection owned by the account holder."""
  supportingDocumentCollection: SupportingDocumentCollection!

  """Creation date"""
  updatedAt: DateTime!

  """Account opened after the onboarding finalization"""
  account: Account

  """List of accepted identification level for the legal representative"""
  legalRepresentativeAcceptedIdentificationLevels: [IdentificationLevel]!

  """Recommended identification level for the legal representative"""
  legalRepresentativeRecommendedIdentificationLevel: IdentificationLevel!
}

"""The onboarding could be for an Individual or a company"""
interface OnboardingAccountHolderInfo {
  """Account holder type"""
  type: AccountHolderType!
}

"""Company Account Holder Information"""
type OnboardingCompanyAccountHolderInfo implements OnboardingAccountHolderInfo {
  """
  Account holder type (always Company for type OnboardingCompanyAccountHolderInfo)
  """
  type: AccountHolderType!

  """name of the company"""
  name: String

  """registration number of the company (SIRET, ...)"""
  registrationNumber: String

  """legal form of the company (SAS, SCI, SASU, ...)"""
  companyType: CompanyType

  """business activity"""
  businessActivity: BusinessActivity

  """
  business activity description
  This must be 1024 characters long maximum.
  """
  businessActivityDescription: String

  """estimated monthly payment volume (euro)"""
  monthlyPaymentVolume: MonthlyPaymentVolume

  """
  The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
  
  The ultimate beneficiary is :
  - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
  - either the natural person (s) who exercise, by other means, a power of control of the company;
  """
  individualUltimateBeneficialOwners: [IndividualUltimateBeneficialOwner!]

  """residency address of the head office (Must be in a European country)"""
  residencyAddress: AddressInfo

  """Is company registered at RCS in its country"""
  isRegistered: Boolean

  """
  Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT
  """
  vatNumber: String

  """Tax Identification Number"""
  taxIdentificationNumber: String

  """Legal representative personal address"""
  legalRepresentativePersonalAddress: AddressInformation

  """Type of representation (legal representative or power of attorney)"""
  typeOfRepresentation: TypeOfRepresentation
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type OnboardingConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """OnboardingEdge list"""
  edges: [OnboardingEdge!]!
}

"""Implements the Relay Edge interface"""
type OnboardingEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The Onboarding"""
  node: Onboarding!
}

"""Filters that can be applied when listing onboardings"""
input OnboardingFiltersInput {
  """Type/Types we want to filter on"""
  types: [AccountHolderType!]

  """Email we want to filter on"""
  email: String

  """Searches company name, first name, last name"""
  search: String

  """Status we want to filter on"""
  status: [OnboardingStatus!]
}

"""StatusInfo when onboarding has been finalized"""
type OnboardingFinalizedStatusInfo implements OnboardingStatusInfo {
  status: OnboardingStatus!
}

"""Individual Account Holder Information"""
type OnboardingIndividualAccountHolderInfo implements OnboardingAccountHolderInfo {
  """
  Account holder type (always Individual for type OnboardingIndividualAccountHolderInfo)
  """
  type: AccountHolderType!

  """employment status of the individual account holder"""
  employmentStatus: EmploymentStatus

  """monthly income of the individual account holder"""
  monthlyIncome: MonthlyIncome

  """
  residency address of the individual account holder (must be in a European country)
  """
  residencyAddress: AddressInfo

  """Tax Identification Number"""
  taxIdentificationNumber: String
}

type OnboardingInfo {
  """Unique identifier of an onboarding"""
  id: String!

  """Account name"""
  accountName: String

  """
  Country of the account that will be created at the end of the onboarding process
  """
  accountCountry: AccountCountry

  """email"""
  email: String

  """
  language of the onboarding process. This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)
  """
  language: String

  """Information regarding the Individual or the company to onboard"""
  info: OnboardingAccountHolderInfo!

  """
  Redirect the legal representative of a new account holder to this URL to start the onboarding process
  """
  onboardingUrl: String!

  """Current computed state of onboarding"""
  onboardingState: OnboardingState

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  """
  redirectUrl: String!

  """Project infos you set in the dashboard"""
  projectInfo: ProjectInfo

  """Verification Flow"""
  verificationFlow: VerificationFlow!

  """Extra parameters provided by partner"""
  oAuthRedirectParameters: OAuthRedirectParameters

  """Status (valid/invalid/finalized) and details of errors on fields"""
  statusInfo: OnboardingStatusInfo!

  """Supporting document collection related to onboarding."""
  supportingDocumentCollection: SupportingDocumentCollection!

  """List of accepted identification level for the legal representative"""
  legalRepresentativeAcceptedIdentificationLevels: [IdentificationLevel]!

  """Recommended identification level for the legal representative"""
  legalRepresentativeRecommendedIdentificationLevel: IdentificationLevel!

  """Swan TCU URL"""
  tcuUrl: String!
}

"""StatusInfo when onboarding has still at least one incorrect field"""
type OnboardingInvalidStatusInfo implements OnboardingStatusInfo {
  status: OnboardingStatus!
  errors: [ValidationError!]!
}

"""Rejection returned if an onboarding is not completed"""
type OnboardingNotCompletedRejection implements Rejection {
  message: String!

  """@deprecated(reason: "use `onboarding.id` instead")"""
  onboardingId: String!
  onboarding: Onboarding!
}

"""
Field we can use when ordering that can be applied when listing onboardings
"""
enum OnboardingOrderByFieldInput {
  createdAt
  updatedAt
  finalizedAt
}

"""Order that can be applied when listing onboardings"""
input OnboardingOrderByInput {
  field: OnboardingOrderByFieldInput
  direction: OrderByDirection
}

"""Onboarding process state"""
enum OnboardingState {
  """When the onboarding is in progress"""
  Ongoing

  """When the onboarding is finalized and the account holder is created"""
  Completed
}

"""Possible values for onboarding status"""
enum OnboardingStatus {
  """When the onboarding is finalized"""
  Finalized

  """when the onboarding is invalid. Final status"""
  Invalid

  """When the onboarding is valid. Final status"""
  Valid
}

"""
Object containing details about onboarding status (valid/invalid and why it is invalid/already finalized)
"""
interface OnboardingStatusInfo {
  """
  Current onboarding status. Onboarding can only be finalized if status is "valid"
  """
  status: OnboardingStatus!
}

"""
StatusInfo when onboarding has all onboarding fields are correctly filled
"""
type OnboardingValidStatusInfo implements OnboardingStatusInfo {
  status: OnboardingStatus!
}

enum OrderByDirection {
  Asc
  Desc
}

"""
Implements PageInfo from the Relay Connections Specification - information about a page in the pagination mechanism
"""
type PageInfo {
  """Indicates whether more edges exist following this page"""
  hasNextPage: Boolean

  """Indicates whether more edges exist preceding this page"""
  hasPreviousPage: Boolean

  """Opaque identifier pointing to the first node of the page"""
  startCursor: String

  """Opaque identifier pointing to the last node of the page"""
  endCursor: String
}

"""Input version"""
input PartnerCloseAccountReasonInput {
  type: PartnerCloseAccountReasonType!
  message: String
}

"""Specific type for closing account action"""
enum PartnerCloseAccountReasonType {
  """Simple closing request"""
  ClosingRequested
}

"""Partnership Status Accepted"""
type PartnershipAcceptedStatusInfo implements PartnershipStatusInfo {
  """
  Partnership status (always Accepted for type PartnershipAcceptedStatusInfo)
  """
  status: PartnershipStatus!

  """Accepted date of the partnership for this account"""
  acceptedDate: DateTime!
}

"""Partnership Status canceled"""
type PartnershipCanceledStatusInfo implements PartnershipStatusInfo {
  """
  Partnership status (always Canceled for type PartnershipCanceledStatusInfo)
  """
  status: PartnershipStatus!

  """Accepted date of the partnership for this account"""
  acceptedDate: DateTime!

  """Canceled date of the partnership for this account"""
  canceledDate: DateTime!

  """Reason of the cancelation"""
  reason: String!
}

"""Partnership Status currently cancelling"""
type PartnershipCancelingStatusInfo implements PartnershipStatusInfo {
  """
  Partnership status (always Canceling for type PartnershipCancelingStatusInfo)
  """
  status: PartnershipStatus!

  """Accepted date of the partnership for this account"""
  acceptedDate: DateTime!

  """Canceled date of the partnership for this account"""
  canceledAfter: DateTime!
}

enum PartnershipStatus {
  """
  When the partnership is accepted by the account holder for this account
  """
  Accepted

  """When you decide to stop the partnership, you have 2 months notice"""
  Canceling

  """When the partnership was canceled by you or the account holder"""
  Canceled
}

"""Partnership Status information"""
interface PartnershipStatusInfo {
  """Status of the partnership for this account"""
  status: PartnershipStatus!
}

"""The document corresponding to a passport"""
type PassportDocument {
  """Unique identifier of the passport document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """The date at which the passport was issued"""
  issueDate: Date

  """The date at which the passport expires"""
  expiryDate: Date

  """Machine-readable zone code of the passport"""
  mrz: String

  """Number of the passport"""
  number: String

  """List of the associated files"""
  files: [PassportDocumentFile!]!
}

"""The file associated to the passport document"""
type PassportDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!

  """From which side the passport's picture was taken"""
  side: DocumentFileSide!
}

"""
A Payment represents a set of transactions linked to the same payment act.

This payment act can be initiated:
- either from a user
- either from a merchant
- either from you
- either from Swan
"""
type Payment {
  """unique identifier of a payment"""
  id: ID!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """status information"""
  statusInfo: PaymentStatusInfo!

  """list of transactions associated to this payment"""
  transactions(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """standing order that has initiated this payment"""
  standingOrder: StandingOrder
}

enum PaymentAccountType {
  """When the account holder if the account hasn't met KYC requirements"""
  EMoney

  """When all KYC requirements are met"""
  PaymentService
}

"""Please see the Connection interface"""
type PaymentConnection implements Connection {
  pageInfo: PageInfo!
  edges: [PaymentEdge!]!
  totalCount: Int!
}

"""Payment status consent pending"""
type PaymentConsentPending implements PaymentStatusInfo {
  """status of the payment"""
  status: PaymentStatus!

  """The consent required to initiate this payment"""
  consent: Consent!
}

interface PaymentDirectDebitMandate {
  """Unique identifier of the Direct Debit Payment Mandate"""
  id: ID!
}

"""Please see the Connection interface"""
type PaymentEdge implements Edge {
  node: Payment!
  cursor: String!
}

"""Filters that can be applied when listing payments"""
input PaymentFiltersInput {
  status: [PaymentStatus!]
}

"""Payment status initiated"""
type PaymentInitiated implements PaymentStatusInfo {
  """status of the payment"""
  status: PaymentStatus!
}

"""Payment Level of the account"""
enum PaymentLevel {
  """When the account is limited to 150 within 30 days and with no IBAN"""
  Limited

  """
  When the account holder is fully verified and then the account is unlimited with an IBAN
  """
  Unlimited
}

enum PaymentLinkSequenceType {
  OneOff
  Recurring
}

interface PaymentMandate {
  """Unique identifier of the Payment Mandate"""
  id: ID!
}

enum PaymentMandateCanceledReason {
  """When the user requested to cancel the Payment Mandate"""
  RequestedByUser

  """When the Payment Mandate is expired"""
  MandateExpired
}

"""Payment Mandate Canceled status information"""
type PaymentMandateCanceledStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Canceled for type PaymentMandateCanceledStatusInfo).
  """
  status: PaymentMandateStatus!

  """Reason behind the Payment Mandate Canceled status"""
  reason: PaymentMandateCanceledReason!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type PaymentMandateConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """PaymentMandateEdge list"""
  edges: [PaymentMandateEdge!]!
}

"""Payment Mandate Consent Pending status information"""
type PaymentMandateConsentPendingStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Enabled for type PaymentMandateEnableedStatusInfo).
  """
  status: PaymentMandateStatus!

  """Consent information required to enable the concerned Payment Mandate"""
  consent: Consent!
}

interface PaymentMandateCreditor {
  """Creditor UUID"""
  id: ID!

  """Creditor name"""
  name: String!

  """Creditor address"""
  address: Address!
}

interface PaymentMandateDebtor {
  """Debtor name"""
  name: String!

  """Debtor e-mail"""
  email: String

  """Debtor country"""
  country: CCA3!
}

"""Implements the Relay Edge interface"""
type PaymentMandateEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The payment mandate"""
  node: PaymentMandate!
}

"""Payment Mandate Enabled status information"""
type PaymentMandateEnabledStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Enabled for type PaymentMandateEnabledStatusInfo).
  """
  status: PaymentMandateStatus!
}

"""
Filter that can be passed to get the payment mandate in a specific data range
"""
input PaymentMandateFiltersInput {
  """To filter on status values"""
  status: [PaymentMandateStatus!]

  """To filter on scheme values"""
  scheme: [PaymentMandateScheme!]
}

"""Error returned if the payment mandate was not found"""
type PaymentMandateMandateNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""
Field we can use when ordering that can be applied when listing payment mandate results
"""
enum PaymentMandateOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing payment mandate results"""
input PaymentMandateOrderByInput {
  field: PaymentMandateOrderByFieldInput
  direction: OrderByDirection
}

"""
Rejection returned when a payment mandate reference is already for a creditor
"""
type PaymentMandateReferenceAlreadyUsedRejection implements Rejection {
  message: String!
}

"""Payment Mandate Rejected status information"""
type PaymentMandateRejectedStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Rejected for type PaymentMandateSuspendedStatusInfo).
  """
  status: PaymentMandateStatus!
}

enum PaymentMandateScheme {
  """SEPA Direct Debit Core"""
  SepaDirectDebitCore

  """SEPA Direct Debit B2B"""
  SepaDirectDebitB2b

  """Internal Direct Debit Standard"""
  InternalDirectDebitStandard

  """Internal Direct Debit B2B"""
  InternalDirectDebitB2b
}

"""Payment Mandate Sequence"""
enum PaymentMandateSequence {
  """The Payment Mandate can be used for recurrent collections"""
  Recurrent

  """The Payment Mandate can be used only once"""
  OneOff
}

"""Payment Mandate status"""
enum PaymentMandateStatus {
  ConsentPending
  Enabled
  Rejected
  Canceled
}

"""Payment Mandate status information"""
interface PaymentMandateStatusInfo {
  """Status of the payment mandate."""
  status: PaymentMandateStatus!
}

"""
Rejection returned when a payment method is not compatible for the requested mutation
"""
type PaymentMethodNotCompatibleRejection implements Rejection {
  message: String!
}

"""
Field we can use when ordering that can be applied when listing payment
"""
enum PaymentOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing payments"""
input PaymentOrderByInput {
  field: PaymentOrderByFieldInput
  direction: OrderByDirection
}

"""Payment product"""
enum PaymentProduct {
  """When the payment is an Internal Credit Transfer operation"""
  InternalCreditTransfer

  """When the payment is a Sepa Credit Transfer operation"""
  SEPACreditTransfer

  """When the payment is a Sepa Direct Debit operation"""
  SEPADirectDebit

  """When the payment is a Card operation"""
  Card

  """When the payment is a Fees operation"""
  Fees

  """When the payment is an Internal Direct Debit operation"""
  InternalDirectDebit

  """When the payment is a Check operation"""
  Check

  """When the payment is an International Credit Transfer operation"""
  InternationalCreditTransfer
}

"""Payment status rejected"""
type PaymentRejected implements PaymentStatusInfo {
  """status of the payment"""
  status: PaymentStatus!

  """rejected reason"""
  reason: String!
}

"""Payment status"""
enum PaymentStatus {
  """when a consent is pending before initiating the payment"""
  ConsentPending

  """when the payment has been initiated"""
  Initiated

  """when the payment has been rejected"""
  Rejected
}

"""Payment Status Information"""
interface PaymentStatusInfo {
  """status of the payment"""
  status: PaymentStatus!
}

"""Custom information for a PDF statement"""
type PdfStatement implements StatementInfo {
  """statement type"""
  type: StatementType

  """temporary public url on which the file can be accessed"""
  url: String

  """date at which the link will not be useable anymore"""
  expiresAt: DateTime
}

"""Pending Consent when the account membership will be updated"""
type PendingConsentAccountMembershipUpdate {
  """New account membership version waiting for consent"""
  accountMembershipId: AccountMembership!

  """The consent required to update the account membership"""
  consent: Consent!
}

"""Pending Digital Card used for ApplePay or GooglePay"""
type PendingDigitalCard implements DigitalCard {
  """Unique identifier of a digital card"""
  id: ID!

  """The type of digitalization that created this digital card."""
  type: DigitalizationType!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Wallet Provider (ApplePay, GooglePay ...)"""
  walletProvider: WalletProvider!

  """
  Digital Card status information
  
  In this type the status will be either ConsentPending or Pending
  """
  statusInfo: PendingDigitalCardStatusInfo!

  """
  Data to provide to the wallet during InApp Provisioning
  
  Signature Data is mandatory for ApplePay
  
  This data is only available for a digital card in
  - status: Pending
  - type: InApp
  """
  inAppProvisioningData(signatureData: SignatureData): InAppProvisioningData
}

"""Pending Digital Card Status"""
enum PendingDigitalCardStatus {
  """when the digital card is waiting for the user to finish his consent"""
  ConsentPending

  """when the digital card is pending the end of the digitalization process"""
  Pending

  """
  when the creation of a digital card is declined
  
  this is a final state
  """
  Declined
}

"""Pending Digital Card Status Information"""
interface PendingDigitalCardStatusInfo {
  """Status of the digital card."""
  status: PendingDigitalCardStatus!
}

"""Funding Source Pending status information"""
type PendingFundingSourceStatusInfo implements FundingSourceStatusInfo {
  """Funding Source Pending status"""
  status: FundingSourceStatus!
}

"""
Describes an identification level that is pending for the process of the current identification, requiring an operation not related to the end-user to progress
"""
type PendingIdentificationLevelStatusInfo {
  """Always set to `Pending`"""
  status: SwanIdentificationStatus!
}

"""PendingMerchantPaymentMethodStatusInfo"""
type PendingMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!
}

"""PendingReviewMerchantProfileStatusInfo"""
type PendingReviewMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
}

"""Pending Verification Information"""
type PendingReviewStatusInfo implements AccountVerificationStatusInfo {
  """Account verification status (PendingReview)"""
  status: AccountVerificationStatus!
}

"""Pending transaction status information"""
type PendingTransactionStatusInfo implements TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!

  """
  The date when the pending amount of this transaction is released on the available balance of this account if not booked
  """
  pendingEndDate: DateTime
}

"""Pending Verification Information"""
type PendingVerificationStatusInfo implements AccountVerificationStatusInfo {
  """Account verification status (PendingVerification)"""
  status: AccountVerificationStatus!
}

type PermissionCannotBeGrantedRejection implements Rejection {
  message: String!
}

"""
E.164 standard format phone number

Examples
+551155256325
+44207183875
"""
scalar PhoneNumber

"""Physical Card"""
type PhysicalCard {
  """Physical Card status information"""
  statusInfo: PhysicalCardStatusInfo!

  """Physical Card expiration date  with MM/YY string format"""
  expiryDate: String

  """
  Unique identifier present on physical card, such identifier is null if the status is ToActivate or Canceled. This identifier is updated when a renewed card is activated
  """
  identifier: String

  """Offline Spending limit defined by Swan"""
  offlineSpendingLimit: Amount!

  """Masked Card Number"""
  cardMaskedNumber: String!

  """Custom Options"""
  customOptions: PhysicalCardCustomOptions!
}

"""Physical Card Activated Status Information"""
type PhysicalCardActivatedStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Activated for type PhysicalCardEnabledStatusInfo).
  """
  status: PhysicalCardStatus!
}

"""Physical Card Canceled Status Information"""
type PhysicalCardCanceledStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Canceled for type PhysicalCardCanceledStatusInfo).
  """
  status: PhysicalCardStatus!

  """Reason why the card is canceled."""
  reason: String!
}

"""Physical Card Canceling Status Information"""
type PhysicalCardCancelingStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Canceling for type PhysicalCardCancelingStatusInfo).
  """
  status: PhysicalCardStatus!

  """Reason why the card is canceled."""
  reason: String!
}

input PhysicalCardConfigInput {
  """Address to deliver the physical card"""
  deliveryAddress: CompleteAddressInput!

  """Custom options to use for physical cards."""
  physicalCardCustomOptions: PhysicalCardCustomOptionsInput
}

"""when the user has to authorize production of the physical card"""
type PhysicalCardConsentPendingStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always ConsentPending for type PhysicalCardConsentPendingStatusInfo)
  """
  status: PhysicalCardStatus!

  """The consent required to authorize production of the physical card"""
  consent: Consent!
}

"""Custom options for physical card."""
type PhysicalCardCustomOptions {
  """Additional line embossed on the card."""
  additionalPrintedLine: String
}

input PhysicalCardCustomOptionsForGroupDeliveryInput {
  """
  Additional line to be embossed on the card. 
  
  This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
  
  Max length allowed: 26 characters.
  Characters allowed: alphanumeric* . - / apostrophe
  """
  additionalPrintedLine: String
}

input PhysicalCardCustomOptionsForPrintInput {
  """
  Additional line to be printed on the card. 
  
  This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
  
  Max length allowed: 26 characters.
  Characters allowed: alphanumeric* . - / apostrophe
  """
  additionalPrintedLine: String
}

input PhysicalCardCustomOptionsInput {
  """
  Additional line to be embossed on the card. 
  
  This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
  
  Max length allowed: 26 characters.
  Characters allowed: alphanumeric* . - / apostrophe
  """
  additionalPrintedLine: String
}

"""Rejection returned when the Physical Card does not exist"""
type PhysicalCardNotFoundRejection implements Rejection {
  message: String!
  identifier: String!
}

"""when the physical card is in the process of being ready to use"""
type PhysicalCardProcessingStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical card status (always Processing for type PhysicalCardProcessingStatusInfo)
  """
  status: PhysicalCardStatus!
}

"""Physical Card Renewed Status Information"""
type PhysicalCardRenewedStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Renewed for type PhysicalCardRenewedStatusInfo).
  """
  status: PhysicalCardStatus!

  """address to deliver the physical card"""
  address: Address!

  """Estimated delivery date"""
  estimatedDeliveryDate: DateTime

  """Shipping tracking number"""
  trackingNumber: String

  """Name of the shipping provider (Ex: LaPoste, DHL ...)"""
  shippingProvider: String

  """`true` if PIN Code is available."""
  isPINReady: Boolean!
}

"""Physical Card Status"""
enum PhysicalCardStatus {
  """Consent to authorize physical card production is pending"""
  ConsentPending

  """Physical card is in processing and cant be used yet"""
  Processing

  """Physical card is activated and can be used"""
  Activated

  """Physical card is suspended and cant be used"""
  Suspended

  """Physical card is canceled, cant be used, and cant be restored"""
  Canceled

  """
  Physical card is in the process of being canceled; card cant be used or restored
  """
  Canceling

  """Physical card needs to be activated by cardholder"""
  ToActivate

  """Physical card is in the process of being renewed"""
  ToRenew

  """Physical card is renewed but hasnt made a transaction since renewal"""
  Renewed
}

"""Physical Card Status Information"""
interface PhysicalCardStatusInfo {
  """Status of the physical card."""
  status: PhysicalCardStatus!
}

"""Physical Card Suspended Status Information"""
type PhysicalCardSuspendedStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Suspended for type PhysicalCardSuspendedStatusInfo).
  """
  status: PhysicalCardStatus!

  """Reason why the card is suspended."""
  reason: String!
}

"""Physical Card To Activate Status Information"""
type PhysicalCardToActivateStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always ToActivate for type PhysicalCardToActivateStatusInfo).
  """
  status: PhysicalCardStatus!

  """address to deliver the physical card"""
  address: Address!

  """Estimated delivery date"""
  estimatedDeliveryDate: DateTime

  """Shipping tracking number"""
  trackingNumber: String

  """Name of the shipping provider (Ex: LaPoste, DHL ...)"""
  shippingProvider: String

  """`true` if PIN Code is available."""
  isPINReady: Boolean!
}

"""when the physical card is in the process of being renewed"""
type PhysicalCardToRenewStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical card status (always ToRenew for type PhysicalCardToRenewStatusInfo)
  """
  status: PhysicalCardStatus!

  """registered address to deliver the new physical card"""
  address: Address!
}

"""Rejection returned when the Physical Card is not the expected status"""
type PhysicalCardWrongStatusRejection implements Rejection {
  message: String!
  identifier: String!
  currentStatus: PhysicalCardStatus!
  expectedStatus: PhysicalCardStatus!
}

"""6 digits numeric passcode"""
scalar PIN

type PINNotReadyRejection implements Rejection {
  physicalCardIdentifier: String!
  message: String!
}

enum PreferredNotificationChannel {
  """Use Swan SMS"""
  Sms

  """Use In-App notification"""
  App
}

type PreProvisioningSUVCardSettings {
  preProvisioningSUVCards: Boolean!
  preProvisioningSUVNumberOfCards: Int!
  ownerProvisioningSUVCards: ID
  preProvisioningSUVCardsAvailablePercentage: Float!
}

"""Inputs to print a physical card"""
input PrintPhysicalCardInput {
  """Unique identifier of a card"""
  cardId: ID!

  """Address to deliver the physical card"""
  address: CompleteAddressInput!

  """`true` if the user must choose their PIN Code"""
  choosePINCode: Boolean!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Custom options to use for physical cards."""
  physicalCardCustomOptions: PhysicalCardCustomOptionsForPrintInput
}

union PrintPhysicalCardPayload = PrintPhysicalCardSuccessPayload | AccountMembershipNotAllowedRejection | AlreadyValidPhysicalCardRejection | BadAccountStatusRejection | BadRequestRejection | CardNotFoundRejection | CardProductNotApplicableToPhysicalCardsRejection | CardProductDisabledRejection | MissingMandatoryFieldRejection | ValidationRejection

type PrintPhysicalCardSuccessPayload {
  """The physicalCard created"""
  physicalCard: PhysicalCard!
}

"""
Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
"""
enum ProductType {
  Goods
  Services
  VirtualGoods
  GiftsAndDonations
}

type ProjectCardDesigns {
  """Unique identifier of a project"""
  id: ID!

  """Visual Id from the issuing card processor (Monext)"""
  issuingProcessorVisualId: String

  """Specific card product for companies"""
  specificCardProductCodeForCompanies: String

  """Project name"""
  name: String

  """Project card product designs"""
  cardDesigns: [CardProductDesign!]!

  """Project's pre provisioning suv card settings"""
  preProvisioningSUVCardSettings: PreProvisioningSUVCardSettings
}

type ProjectCardSettings {
  """Unique identifier of a project"""
  id: ID!

  """Visual Id from the issuing card processor (Monext)"""
  issuingProcessorVisualId: String

  """Specific card product for companies"""
  specificCardProductCodeForCompanies: String

  """Project name"""
  name: String

  """Project's card settings"""
  cardSettings: [CardSettings!]!

  """Project's pre provisioning suv card settings"""
  preProvisioningSUVCardSettings: PreProvisioningSUVCardSettings
}

"""Project Card Settings Background Type"""
enum ProjectCardSettingsBackgroundType {
  """when Card setting background is black"""
  Black

  """when Card setting background is light"""
  Silver

  """when Card setting background is customized"""
  Custom
}

"""Card Status"""
enum ProjectCardStatus {
  """when project's card settings are Initiated"""
  Initiated

  """when project's card settings are Enabled"""
  Enabled

  """when project's card settings are Disabled"""
  Disabled

  """when project's card settings are ToReview"""
  ToReview

  """when project's card settings are Suspended"""
  Suspended

  """when project's card settings are Rejected"""
  Rejected
}

type ProjectForbiddenRejection implements Rejection {
  message: String!
}

"""Rejection returned when the Project Funding has been exceeded"""
type ProjectFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""Public information of a `Project`"""
type ProjectInfo {
  """The card products associated with this project."""
  cardProducts: [CardProduct!]

  """the currently active card settings"""
  activeCardSettings: CardSettings @deprecated(reason: "Use cardProduct.cardDesigns instead")

  """Unique identifier of the project"""
  id: ID!
  B2BMembershipIDVerification: Boolean
  supportingDocumentSettings: SupportingDocumentSettings

  """
  Your project name displayed in white label interfaces and in the terms and conditions
  """
  name: String!

  """The type of your project"""
  type: ProjectType!

  """URL of your logo"""
  logoUri: String

  """
  Your accent color, used in white label interfaces. Most of the time for call to actions
  """
  accentColor: String

  """Your custom subdomain used in consents"""
  customConsentSubdomain: String

  """Your OAuth client id"""
  oAuthClientId: String

  """
  URL to your Terms and Conditions of Use document depending on the provided language
  """
  tcuDocumentUri(
    """
    this consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)
    """
    language: String!
  ): String!

  """Unique id of your current Terms and Conditions of Use"""
  tcuDocumentId: String!

  """Web banking settings"""
  webBankingSettings: WebBankingSettings

  """Project status"""
  status: ProjectStatus!

  """
  Flag that determines if desktop authentication is enabled for this project
  """
  allowsDesktopAuthentication: Boolean!
}

"""
Rejection returned when the Project Instant Funding limit has been exceeded
"""
type ProjectInstantFundingLimitExceededRejection implements Rejection {
  message: String!
}

type ProjectInvalidStatusRejection implements Rejection {
  message: String!
}

type ProjectNotFound implements Rejection {
  message: String!
}

"""Rejection returned when the project is not found"""
type ProjectNotFoundRejection implements Rejection {
  message: String!
}

type ProjectSettingsForbiddenError implements Rejection {
  message: String!
}

type ProjectSettingsNotFound implements Rejection {
  message: String!
}

type ProjectSettingsStatusNotReachable implements Rejection {
  message: String!
}

enum ProjectStatus {
  Initiated
  MeetingScheduled
  ToReview @deprecated(reason: "replaced by `PendingCompliance`")
  PendingCompliance
  LimitedLiveAccess
  BetaLiveAccess
  Enabled @deprecated(reason: "replaced by `LimitedLiveAccess`")
  FullLiveAccess
  Disabled
  Suspended
  Rejected
  PendingLiveReview
}

enum ProjectType {
  INDIVIDUAL @deprecated(reason: "replaced by `Individual`")
  COMPANY @deprecated(reason: "replaced by `Company`")
  COMPANY_AND_CUSTOMERS @deprecated(reason: "replaced by `CompanyAndCustomers`")
  Individual
  Company
  CompanyAndCustomers
}

"""Rejection returned when the public onboarding is disabled"""
type PublicOnboardingDisabledRejection implements Rejection {
  message: String!
}

type Query {
  """Returns a request for funding limit settings change from its id."""
  fundingLimitSettingsChangeRequest(fundingLimitSettingsChangeRequestId: ID!): FundingLimitSettingsChangeRequest

  """
  Allows to check iban validation. It also returns its bank and reachability information
  """
  ibanValidation(input: IbanValidationInput): IbanValidationResult

  """Returns an account holder from its id."""
  accountHolder(id: ID!): AccountHolder

  """
  Returns the list of account holders.
  
  *For a Project access token, this is all the account holders of the project and for an User access token, these are the holders of the accounts of which the user has an account membership.*
  """
  accountHolders(first: Int! = 50, before: String, filters: AccountHolderFilterInput, orderBy: AccountHolderOrderByInput, after: String): AccountHolderConnection!

  """Returns an account membership from its id."""
  accountMembership(id: ID!): AccountMembership

  """The list of account memberships"""
  accountMemberships(first: Int! = 50, before: String, after: String, filters: AccountMembershipsFilterInput, orderBy: AccountMembershipOrderByInput): AccountMembershipConnection!

  """Returns an account from its id."""
  account(accountId: ID!): Account

  """
  Returns the list of accounts.
  
  *For a Project access token, this is all the accounts of the project and for an User access token, these are the accounts of which the user has an account membership.*
  """
  accounts(first: Int! = 50, before: String, after: String, filters: AccountFilterInput, orderBy: AccountOrderByInput): AccountConnection!

  """Returns a card from its id."""
  card(cardId: ID!): Card

  """
  Returns the list of cards.
  
  *For a Project access token, this is all the cards of the project and for an User access token, these are the cards owned by the user whom have an account membership.*
  """
  cards(
    first: Int! = 50
    before: String
    after: String

    """When the list of elements needs to be ordered"""
    orderBy: CardOrderByInput

    """When the list of elements needs to be filtered"""
    filters: CardFiltersInput
  ): CardConnection!

  """
  Returns an onboarding from its id.
  
  *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  onboarding(id: ID!): Onboarding!

  """
  Returns the list of onboardings.
  
  *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  onboardings(first: Int! = 50, before: String, after: String, filters: OnboardingFiltersInput, orderBy: OnboardingOrderByInput): OnboardingConnection!

  """
  Returns a supporting document collection from its id.
  
  *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  supportingDocumentCollection(id: ID!): SupportingDocumentCollection

  """Returns an account statement by id"""
  accountStatement(id: ID!): Statement!

  """Returns a payment from its id."""
  payment(id: ID!): Payment!

  """
  Returns the list of payments.
  
  *For a Project access token, this is all the payments of the project and for an User access token, these are the payments initiated by the user*
  """
  payments(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to end before a element"""
    before: String

    """When the list of elements needs to be ordered"""
    orderBy: PaymentOrderByInput

    """When the list of elements needs to be filtered"""
    filters: PaymentFiltersInput
  ): PaymentConnection!

  """
  Returns a transaction from its id.
  
  *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  transaction(id: ID!): Transaction!

  """
  A list of transactions of a project.
  
  *For a Project access token, this is all the transactions of the project (only available with project access token)*
  """
  transactions(
    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput

    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """
    When the list of elements needs to be sorted (default value UpdatedAt desc)
    """
    orderBy: TransactionsOrderByInput
  ): TransactionConnection!
  accountInvoice(invoiceId: ID!): Invoice

  """Return the capital deposit case for the provided id."""
  capitalDepositCase(id: ID!): CapitalDepositCase

  """
  Returns the list of capital deposit cases.
  
  *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  capitalDepositCases(first: Int! = 50, before: String, after: String, filters: CapitalDepositCaseFiltersInput, orderBy: CapitalDepositCaseOrderByInput): CapitalDepositCaseConnection!

  """Return the CapitalDepositDocument for the provided id."""
  capitalDepositDocument(id: ID!): CapitalDepositDocument

  """Return the Shareholder for the provided id."""
  shareholder(id: ID!): Shareholder

  """Returns the project infos you set in the dashboard."""
  projectInfo: ProjectInfo!

  """Returns a consent by its id."""
  consent(id: ID!): Consent!

  """
  Return the list of consents
  
  For a User access token : return the list of consents for the signed-in user
  For a Project access token : return the list of consents for the project. This list can be filtered by userId
  
  *([Learn more on authentication](https://docs.swan.io/api/authentication))*
  """
  consents(first: Int! = 50, after: String, filters: ConsentsFiltersInput): ConsentConnection!

  """
  Returns a User
  
  For a Project access token : it requires a user id and returns the user for the given id
  For a User access token : returns the signed-in user and all of their data at Swan
  
  *([Learn more on authentication](https://docs.swan.io/api/authentication))*
  """
  user(id: String): User

  """
  Returns the list of user that joined the project
  The search field allows to search in : id, phonNumber, firstName, allFirstNames, lastName
  
  *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  users(
    after: String
    before: String
    filters: UserFilterInput
    first: Int! = 50

    """@deprecated(reason: "use the `search` field in `UserFilterInput`")"""
    search: String
  ): UserConnection!

  """Returns a received direct debit mandate from its id."""
  receivedDirectDebitMandate(receivedDirectDebitMandateId: ID!): ReceivedDirectDebitMandate

  """Returns a merchant profile by id."""
  merchantProfile(id: ID!): MerchantProfile

  """Returns funding source by id."""
  fundingSource(id: ID!): FundingSource

  """Returns an international beneficiary dynamic forms."""
  internationalBeneficiaryDynamicForms(amount: AmountInput!, language: InternationalCreditTransferDisplayLanguage, dynamicFields: [InternationalBeneficiaryDetailsInput!]): InternationalBeneficiaryDynamicForms

  """Returns an international credit transfer dynamic form."""
  internationalCreditTransferTransactionDetailsDynamicForm(targetAmount: AmountInput!, language: InternationalCreditTransferDisplayLanguage, internationalBeneficiary: InternationalBeneficiaryInput!, refreshableFields: [InternationalCreditTransferDetailsInput!]): InternationalCreditTransferDynamicForm

  """Request an international credit transfer quote."""
  internationalCreditTransferQuote(accountId: ID!, targetAmount: AmountInput!, language: InternationalCreditTransferDisplayLanguage): InternationalCreditTransferQuote

  """Returns standing order from its id."""
  standingOrder(standingOrderId: ID!): StandingOrder
}

type RadioField implements Field {
  key: String!
  name: String!
  refreshDynamicFieldsOnChange: Boolean!
  required: Boolean!
  allowedValues: [AllowedValue!]!
}

"""Information that can be used to determine where the iban can be used"""
type Reachability {
  """Can be used for instant transfer over SEPA"""
  sepaCreditTransferInst: Boolean!

  """Can be used for direct debit over SEPA"""
  sepaDirectDebitCore: Boolean!

  """Can be used for B2B direct debit over SEPA"""
  sepaDirectDebitB2b: Boolean!

  """
  Can be used for transfer over SEPA (can be used in initiateCreditTransfer mutation)
  """
  sepaCreditTransfer: Boolean!
}

"""Define a reason with a message"""
interface Reason {
  message: String
}

"""Input version"""
input ReasonInput {
  message: String
}

"""Interface for Received Direct Debit Mandate"""
interface ReceivedDirectDebitMandate {
  """
  Unique identifier of the received direct debit mandate, generated by Swan
  """
  id: ID!

  """Version of the received direct debit mandate"""
  version: String!

  """Creation date of the received direct debit mandate"""
  createdAt: DateTime!

  """Last Update date of the received direct debit mandate"""
  updatedAt: DateTime!

  """Date of signature of the received direct debit mandate"""
  signatureDate: Date

  """
  Date of the last direct debit transaction executed for the concerned received direct debit mandate
  """
  executedAt: DateTime

  """Expiry date of the received direct debit mandate"""
  expiredAt: Date

  """Mandate status information of the received direct debit mandate"""
  statusInfo: ReceivedDirectDebitMandateStatusInfo!

  """Mandate name"""
  name: String
}

"""Rejection returned if the received direct debit mandate already exist"""
type ReceivedDirectDebitMandateAlreadyExistRejection implements Rejection {
  id: String!
  message: String!
}

"""
Received direct debit mandate is canceled and therefore can't be enabled/suspended or updated
"""
type ReceivedDirectDebitMandateCanceledRejection implements Rejection {
  id: String!
  message: String!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type ReceivedDirectDebitMandateConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ReceivedDirectDebitMandateEdge list"""
  edges: [ReceivedDirectDebitMandateEdge!]!
}

"""Implements the Relay Edge interface"""
type ReceivedDirectDebitMandateEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The received direct debit mandate"""
  node: ReceivedDirectDebitMandate!
}

"""
Rejection returned if the received direct debit mandate is not a B2b mandate
"""
type ReceivedDirectDebitMandateNotB2bRejection implements Rejection {
  id: String!
  message: String!
}

"""
Error returned if the received direct debit mandate was not found or if the user does not have the rights to receive information abo
ut the existence of the received direct debit mandate
"""
type ReceivedDirectDebitMandateNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Received Direct Debit Mandate Scheme"""
enum ReceivedDirectDebitMandateScheme {
  """
  When the received direct debit mandate can only be used for SEPA B2B direct debit transactions
  """
  SepaDirectDebitB2b

  """
  When the received direct debit mandate can only be used for SEPA Core direct debit transactions
  """
  SepaDirectDebitCore
}

"""Received Direct Debit Mandate Statuses"""
enum ReceivedDirectDebitMandateStatus {
  """When the received direct debit mandate is enabled"""
  Enabled

  """When the received direct debit mandate is suspended"""
  Suspended

  """When the received direct debit mandate is canceled"""
  Canceled

  """
  When the received direct debit mandate requires the initiation of a consent process
  """
  ConsentInitiationPending

  """When the received direct debit mandate is pending consent completion"""
  ConsentPending
}

"""Received Direct Debit Mandate status information"""
interface ReceivedDirectDebitMandateStatusInfo {
  """Received Direct Debit Mandate status"""
  status: ReceivedDirectDebitMandateStatus!
}

"""Received Direct Debit Mandate Canceled status information"""
type ReceivedDirectDebitMandateStatusInfoCanceled implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always Canceled for type ReceivedDirectDebitMandateStatusInfoCanceled)
  """
  status: ReceivedDirectDebitMandateStatus!

  """Date of cancellation"""
  canceledAt: DateTime!
}

"""
Received Direct Debit Mandate ConsentInitiationPending status information
"""
type ReceivedDirectDebitMandateStatusInfoConsentInitiationPending implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentInitiationPending)
  """
  status: ReceivedDirectDebitMandateStatus!
}

"""Received Direct Debit Mandate ConsentPending status information"""
type ReceivedDirectDebitMandateStatusInfoConsentPending implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentPending)
  """
  status: ReceivedDirectDebitMandateStatus!

  """The consent required to consent to a received direct debit mandate"""
  consent: Consent!
}

"""Received Direct Debit Mandate Enabled status information"""
type ReceivedDirectDebitMandateStatusInfoEnabled implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always Enabled for type ReceivedDirectDebitMandateStatusInfoEnabled)
  """
  status: ReceivedDirectDebitMandateStatus!

  """
  Date at which the received direct debit mandate has been moved to the enabled status
  """
  enabledAt: DateTime!
}

"""Received Direct Debit Mandate Suspended status information"""
type ReceivedDirectDebitMandateStatusInfoSuspended implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always Suspended for type ReceivedDirectDebitMandateStatusInfoSuspended)
  """
  status: ReceivedDirectDebitMandateStatus!

  """
  Date of the last time the received direct debit mandate has been moved to the suspended status
  """
  suspendedAt: DateTime!
}

"""Input to select the beneficiary and the originator to perform a refund"""
input RefundInput {
  """transactions to refund"""
  refundTransactions: [RefundTransaction!]!

  """url the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

"""The respond body to a refund mutation"""
union RefundPayload = RefundSuccessPayload | RefundRejection

"""
Rejection returned if the transaction status is not correct for the desired action
"""
type RefundRejection implements Rejection {
  message: String!
  code: RefundRejectionCode!
}

"""Reason code that explains why we can't refund the transactions"""
enum RefundRejectionCode {
  """
  The transaction couldn't be found or the user doesn't have the 'canInitiatePayment' rights on the account
  """
  TransactionNotFound

  """The transaction status is not Booked"""
  TransactionNonRefundable

  """Error server"""
  ServerError
}

"""Consent generated by the refund mutation"""
type RefundSuccessPayload {
  """
  optional consent that need to be validated for the refund to go through
  """
  consent: Consent
}

"""Information about the transaction to refund"""
input RefundTransaction {
  """id of the transaction to refund"""
  originTransactionId: String!

  """amount to refund in the same currency as the account"""
  amount: AmountInput!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction.
  This reference is passed on, unchanged, throughout the entire end-to-end chain for credit transfers. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35})
  """
  reference: String

  """label for the refund transaction (max 140 characters)"""
  label: String

  """
  only used when the transaction was a credit transfer
  
  date when the credit transfer will be executed, if `null` the credit transfer is executed today
  """
  executionDate: DateTime
}

"""Funding Source Rejected Reason"""
enum RejectedFundingSourceReason {
  AccountVerificationRejected
}

"""Funding Source Rejected status information"""
type RejectedFundingSourceStatusInfo implements FundingSourceStatusInfo {
  """Funding Source Rejected status"""
  status: FundingSourceStatus!

  """Date at which the funding source was rejected"""
  rejectedAt: Date!

  """Reason code of the rejection"""
  reasonCode: RejectedFundingSourceReason!
}

"""RejectedMerchantPaymentMethodStatusInfo"""
type RejectedMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method rejected date"""
  rejectedAt: Date!
}

"""RejectedMerchantProfileStatusInfo"""
type RejectedMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  rejectedAt: Date!
}

"""The following reason code for a rejected transaction are defined:"""
enum RejectedReasonCode {
  """Rejected because the account is closed"""
  AccountClosed

  """Rejected because the account holder is deceased"""
  AccountHolderDeceased

  """Rejected by the account membership"""
  AccountMembershipRefused

  """Rejected because the account is suspended"""
  AccountSuspended

  """Rejected because the account is unknown"""
  AccountUnknown

  """Rejected by the bank"""
  BankRefused

  """Rejected because the creditor bank is not reachable"""
  BeneficiaryBankNotReachable

  """Rejected because the card is expired"""
  CardExpired

  """Rejected because the card has been permanently blocked"""
  CardPermanentlyBlocked

  """Rejected because the card is suspended"""
  CardSuspended

  """Rejected because the creditor bank is offline"""
  CreditorBankOffline

  """Rejected following an error from the creditor bank"""
  CreditorBankTechnicalErrorOccurred

  """Rejected following a timeout from the creditor bank"""
  CreditorBankTimeout

  """Rejected because the debtor account is closed"""
  DebtorAccountClosed

  """
  Rejected because the debtor is a non business account and the transaction is a B2B SEPA Direct Debit transaction
  """
  DebtorAccountConsumer

  """Rejected because the debtor account is unknown"""
  DebtorAccountUnknown

  """Rejected because the debtor bank is offline"""
  DebtorBankOffline

  """Rejected following an error from the debtor bank"""
  DebtorBankTechnicalErrorOccurred

  """Rejected following a timeout from the debtor bank"""
  DebtorBankTimeout

  """Rejected because the debtor account holder is dead"""
  DebtorDeceased

  """Rejected because of a fraud suspicion"""
  FraudSuspected

  """Rejected because the beneficiary IBAN is invalid"""
  IbanInvalid

  """Rejected because the beneficiary IBAN is suspended"""
  IbanSuspended

  """Rejected because of insufficient funds on the account"""
  InsufficientFunds

  """Rejected because of invalid transfer date"""
  InvalidTransferDate

  """Rejected by debtor because the mandate is invalid"""
  MandateInvalid

  """Rejected because the mandate has been revoked or does not exist"""
  NoMandate

  """Rejected by the partner (you)"""
  PartnerRefused

  """Rejected following an error or a timeout from the partner"""
  PartnerTechnicalErrorOccurred

  """
  Rejected because the maximum amount allowed on the given period has been exceeded
  """
  PeriodAmountLimitExceeded

  """
  Rejected because the maximum number of transactions on the given period has been exceeded
  """
  PeriodNbTransactionLimitExceeded

  """Rejected by bank with no specified reason"""
  ReasonNotSpecifiedByBank

  """Rejected by debtor with no specified reason"""
  ReasonNotSpecifiedByDebtor

  """Rejected by bank for regulatory reason"""
  RegulatoryReason

  """Rejected because the debtor or the creditor bank is offline"""
  SwanOffline

  """Rejected by Swan"""
  SwanRefused

  """Rejected because of a Swan technical error"""
  SwanTechnicalErrorOccurred

  """Rejected because of a Swan timeout"""
  SwanTimeout

  """Rejected because the terms and conditions limit has been exceeded"""
  TermsAndConditionsLimitExceeded

  """
  Rejected because the maximum amount for a transaction has been exceeded
  """
  TransactionAmountLimitExceeded

  """Rejected by bank because this transaction is duplicated"""
  TransactionDuplicated

  """Rejected because the transaction is forbidden on this type of account"""
  TransactionOnAccountTypeNotAllowed

  """Rejected because the type of transaction is forbidden on the account"""
  TransactionTypeNotAllowed

  """Rejected because the card is not activated yet"""
  CardNotActivated

  """Rejected because the PIN is invalid"""
  InvalidPin

  """
  Rejected because there were too many invalid tries on the PIN validation
  """
  InvalidPinAttemptsExceeded

  """
  Rejected because the merchant must request a new transaction with authorisation
  """
  MerchantShouldResubmitAuthorization

  """
  Rejected because the expiration date entered does not match the one on the card
  """
  InvalidExpirationDate

  """
  Rejected because the security number entered does not match the one on the card
  """
  InvalidSecurityNumber

  """
  Rejected because a transaction with PIN code is required to continue to using the card
  """
  PinRequiredForFurtherTransaction

  """
  Rejected because the Swipe method is not supported, a retry using the Chip and PIN method is necessary
  """
  RetryWithChipAndPin
}

"""Rejected transaction status information"""
type RejectedTransactionStatusInfo implements TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!

  """reason code"""
  reason: RejectedReasonCode!

  """`true` if the transaction had a fallback"""
  hasFallback: Boolean!
}

"""Rejected Verification Reason"""
enum RejectedVerificationReason {
  HolderDidNotMatch
}

"""Rejected Information"""
type RejectedVerificationStatusInfo implements AccountVerificationStatusInfo {
  """Rejected Reason"""
  reason: RejectedVerificationReason!

  """Date at which the verification was rejected"""
  rejectedAt: DateTime!

  """Account verification status (Rejected)"""
  status: AccountVerificationStatus!
}

interface Rejection {
  message: String!
}

enum ReleasedReason {
  """Authorization fully captured by one or more debits"""
  Captured

  """Authorization expired"""
  Expired

  """Authorization has been superseded by an advice"""
  AdviceReceived

  """Authorization released by the merchant"""
  MerchantReleased

  """Authorization manually released by Swan"""
  ManuallyReleased

  """Authorization released for other/undefined reasons"""
  Other
}

"""Released card transaction status information"""
type ReleasedTransactionStatusInfo implements TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!

  """The date when the transaction was released"""
  releaseDate: DateTime!

  """reason of the released transaction"""
  reason: ReleasedReason!
}

"""The document corresponding to a identification report"""
type ReportDocument {
  """Unique identifier of the report document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """List of the associated files"""
  files: [ReportDocumentFile!]!
}

"""The file associated to the report document"""
type ReportDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!
}

"""here is the exchange rate detail"""
type ReportExchangeRate {
  sourceCurrency: Currency!
  exchangeRate: Float!
  unitCurrency: Currency!
  targetCurrency: Currency!
  quotationDate: Date!
  contractIdentification: String
}

input RequestMerchantPaymentMethodsInput {
  """ID of the Merchant Profile"""
  merchantProfileId: ID!

  """Input for the Internal Direct Debit Standard payment method"""
  internalDirectDebitStandard: InternalDirectDebitStandardPaymentMethodInput

  """Input for the Internal Direct Debit B2B payment method"""
  internalDirectDebitB2B: InternalDirectDebitB2BPaymentMethodInput

  """Input for the Sepa Direct Debit Core payment method"""
  sepaDirectDebitCore: SepaDirectDebitCorePaymentMethodInput

  """Input for the Sepa Direct Debit B2B payment method"""
  sepaDirectDebitB2B: SepaDirectDebitB2BPaymentMethodInput

  """Input for Check payment method"""
  check: CheckPaymentMethodInput

  """input for Card payment method"""
  card: CardPaymentMethodInput
}

union RequestMerchantPaymentMethodsPayload = RequestMerchantPaymentMethodsSuccessPayload | ForbiddenRejection | NotFoundRejection | InternalErrorRejection | ValidationRejection

type RequestMerchantPaymentMethodsSuccessPayload {
  merchantProfile: MerchantProfile
}

"""Request Update Merchant Profile"""
type RequestMerchantProfileUpdate {
  """The Request ID"""
  id: ID!

  """The Merchant Profile ID to update"""
  merchantProfileId: ID!

  """
  Business name of the merchant, i.e. name that will be displayed on debtors' bank statements
  """
  merchantName: String!

  """Url of the merchant's website"""
  merchantWebsite: String

  """Url of the merchant's logo"""
  merchantLogoUrl: String

  """The status of the request"""
  status: RequestMerchantProfileUpdateStatus!

  """
  Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
  """
  productType: ProductType!

  """Expected annual activity volumes for all payment method"""
  expectedMonthlyPaymentVolume: Amount!

  """expected average basket value."""
  expectedAverageBasket: Amount!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!
}

"""Input to update a Merchant Profile"""
input RequestMerchantProfileUpdateInput {
  """ID of the MerchantProfile to update"""
  merchantProfileId: ID!

  """
  Business name of the merchant, i.e. name that will be displayed on debtors' bank statements
  """
  merchantName: String!

  """
  Url of the merchant's website.
  Use '' to delete the field. Don't add the field to the mutation if you want to keep the existing value.
  """
  merchantWebsite: String

  """
  Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
  """
  productType: ProductType!

  """Expected annual activity volumes for all payment methods."""
  expectedMonthlyPaymentVolume: AmountInput!

  """expected average basket value."""
  expectedAverageBasket: AmountInput!

  """
  base64 encoded merchant's logo.
  Use '' to delete the field. Don't add the field to the mutation if you want to keep the existing value.
  """
  merchantLogo: String
}

"""Add Merchant Profile Payload"""
union RequestMerchantProfileUpdatePayload = RequestMerchantProfileUpdateSuccessPayload | ForbiddenRejection | AccountNotFoundRejection | InternalErrorRejection

"""Request Merchant Profile Update Statuses"""
enum RequestMerchantProfileUpdateStatus {
  """A Request is created in the PendingReview status"""
  PendingReview

  """A Request that has already been approved"""
  Enabled

  """A Request that has already been rejected"""
  Rejected
}

"""Add Merchant Profile Success Payload"""
type RequestMerchantProfileUpdateSuccessPayload {
  """Request Update Merchant Profile"""
  requestMerchantProfileUpdate: RequestMerchantProfileUpdate!
}

input RequestSupportingDocumentCollectionReviewInput {
  """Id of the supporting document collection to review."""
  supportingDocumentCollectionId: ID!
}

union RequestSupportingDocumentCollectionReviewPayload = RequestSupportingDocumentCollectionReviewSuccessPayload | ForbiddenRejection | SupportingDocumentCollectionNotFoundRejection | SupportingDocumentCollectionStatusNotAllowedRejection | ValidationRejection

type RequestSupportingDocumentCollectionReviewSuccessPayload {
  supportingDocumentCollection: SupportingDocumentCollection!
}

"""The document corresponding to a residence permit"""
type ResidencePermitDocument {
  """Unique identifier of the residence permit document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """The date at which the residence permit was issued"""
  issueDate: Date

  """The date at which the residence permit expires"""
  expiryDate: Date

  """Machine-readable zone code of the residence permit"""
  mrz: String

  """Number of the residence permit"""
  number: String

  """List of the associated files"""
  files: [ResidencePermitDocumentFile!]!
}

"""The file associated to the resident permit document"""
type ResidencePermitDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!

  """From which side the residence permit's picture was taken"""
  side: DocumentFileSide!
}

input ResidencyAddressInput {
  """Address line 1. Length must be from 0 to 255 characters"""
  addressLine1: String

  """AddressLine2. Length must be from 0 to 255 characters"""
  addressLine2: String

  """City. Length must be from 0 to 100 characters"""
  city: String

  """Postal code. Length must be from 0 to 50 characters"""
  postalCode: String

  """State of residency. Length must be from 0 to 100 characters"""
  state: String

  """Country"""
  country: CCA3
}

"""Account membership restricted to"""
type RestrictedTo {
  """first name"""
  firstName: String!

  """last name"""
  lastName: String!

  """birth date"""
  birthDate: Date

  """phone number"""
  phoneNumber: String!
}

"""Input when the account membership is restricted to a verified user"""
input RestrictedToInput {
  """Account member first name"""
  firstName: String!

  """Account member last name"""
  lastName: String!

  """Account member birth date"""
  birthDate: Date

  """Account member phone number"""
  phoneNumber: PhoneNumber!
}

"""
Rejection returned if the mutation cannot be executed in another context than user
"""
type RestrictedToUserRejection implements Rejection {
  message: String!
}

input ResumeAccountMembershipInput {
  """Unique identifier of a given account membership to resume"""
  accountMembershipId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ResumeAccountMembershipPayload = ResumeAccountMembershipSuccessPayload | ForbiddenRejection | UserNotAllowedToManageAccountMembershipRejection | ValidationRejection

type ResumeAccountMembershipSuccessPayload {
  consent: Consent!
}

"""Inputs to resume a physical card"""
input ResumePhysicalCardInput {
  """Unique identifier of a card"""
  cardId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ResumePhysicalCardPayload = ResumePhysicalCardSuccessPayload | ForbiddenRejection | CardNotFoundRejection | UserNotCardHolderRejection | PhysicalCardNotFoundRejection | PhysicalCardWrongStatusRejection | ValidationRejection

type ResumePhysicalCardSuccessPayload {
  """The physicalCard to resume"""
  physicalCard: PhysicalCard!

  """The consent required to resume a physical card"""
  consent: Consent!
}

"""
Percentage over a number of business days, that is applied to all funds collected to compute a Reserved amount
This amount cannot be used over the corresponding business days
"""
type RollingReserve {
  """Percentage of the funding amount to be reserved"""
  percentage: Int!

  """Number of business days the computed amount is reserved"""
  rollingDays: Int!
}

input ScheduleStandingOrderInput {
  """
  Fix Amount that will be periodically transferred
  *the value must be empty when `targetAvailableBalance` is defined*
  """
  amount: AmountInput

  """
  Target available balance that will be used for periodically clipping the account
  *the value must be empty when `amount` is defined*
  """
  targetAvailableBalance: AmountInput

  """Scheduled period of Standing Order"""
  period: StandingOrderPeriod!

  """Earlier date the Standing Order will be executed"""
  firstExecutionDate: DateTime

  """Latest date the Standing Order will be executed"""
  lastExecutionDate: DateTime

  """SEPA beneficiary of the Standing ORder"""
  sepaBeneficiary: SepaBeneficiaryInput

  """Account the Standing Order will be attached to"""
  accountId: String!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35})
  """
  reference: String

  """label (max 140 characters)"""
  label: String

  """Transfer mode of the Standing Order"""
  creditTransferMode: CreditTransferMode = Regular
}

union ScheduleStandingOrderPayload = ScheduleStandingOrderSuccessPayload | ForbiddenRejection | InternalErrorRejection | InvalidArgumentRejection

type ScheduleStandingOrderSuccessPayload {
  standingOrder: StandingOrder!
}

type Scheme {
  fields: [Field!]!
  title: String!
  type: InternationalCreditTransferRouteInput!
  remainingFieldsToRefreshCount: Int!
}

"""Rejection returned when adding a B2B mandate with an Individual debtor"""
type SchemeWrongRejection implements Rejection {
  message: String!
}

type SelectField implements Field {
  key: String!
  name: String!
  refreshDynamicFieldsOnChange: Boolean!
  required: Boolean!
  allowedValues: [AllowedValue!]!
}

"""
*SOON TO BE DEPRECATED*
External Beneficiary type SEPA
"""
type SEPABeneficiary implements Beneficiary {
  """unique identifier of a beneficiary"""
  id: ID

  """full name of the beneficiary"""
  name: String!

  """
  `true` if this new beneficiary is the account holder himself in an other financial institution.
  """
  isMyOwnIban: Boolean!

  """beneficiary address"""
  address: Address

  """
  maskedIBAN if the beneficiary is a an account in an other financial institution
  """
  maskedIBAN: String
}

"""Sepa beneficiary account"""
input SepaBeneficiaryInput {
  """International Bank Account Number"""
  iban: IBAN!

  """
  Full name of the beneficiary (min 2 characters, max 70 characters). The name should not include any special characters.
  """
  name: String!

  """beneficiary address"""
  address: AddressInput

  """
  `true` if this new beneficiary is the account holder himself in another financial institution.
  """
  isMyOwnIban: Boolean!

  """
  `true` if this new beneficiary will be saved to the beneficiary list of the debited account.
  """
  save: Boolean!
}

"""
SEPA Creditor Identifier
format :
    1  2: ISO Country Code
    3  4: Check Digit
    5  7: Creditor Business Code  you (Creditor) choose this. The default is ZZZ
    8 - 35: Creditor National Identifier  a consecutive number that will be assigned by country
example:
    FR11ABC123456
"""
scalar SepaCreditorIdentifier

"""Sepa Credit Transfer Creditor"""
interface SEPACreditTransferCreditor {
  """full name of the creditor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String
}

"""Sepa Credit Transfer Debtor"""
interface SEPACreditTransferDebtor {
  """full name of the debtor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String
}

"""Sepa Credit Transfer Creditor for Incoming transaction"""
type SEPACreditTransferInCreditor implements SEPACreditTransferCreditor {
  """full name of the creditor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """account number"""
  accountNumber: AccountNumber! @deprecated(reason: "because it is not already implemented (a default value is set).")
}

"""Sepa Credit Transfer Debtor for Incoming transaction"""
type SEPACreditTransferInDebtor implements SEPACreditTransferDebtor {
  """full name of the debtor (max 70 characters)"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID
}

"""
*SOON TO BE DEPRECATED*
Sepa Credit Transfer Debtor for Incoming transaction
"""
type SEPACreditTransferInternalInDebtor implements SEPACreditTransferDebtor {
  """full name of the debtor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """account number"""
  accountNumber: AccountNumber! @deprecated(reason: "because it is not already implemented (a default value is set).")
}

"""
*SOON TO BE DEPRECATED*
Sepa Credit Transfer Creditor for internal transaction
"""
type SEPACreditTransferInternalOutCreditor implements SEPACreditTransferCreditor {
  """full name of the creditor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """account number"""
  accountNumber: AccountNumber!

  """beneficiary if the beneficiary is already saved"""
  beneficiary: InternalBeneficiary @deprecated(reason: "because it is not already implemented.")
}

"""Sepa Credit Transfer Creditor for Outgoing transaction"""
type SEPACreditTransferOutCreditor implements SEPACreditTransferCreditor {
  """full name of the creditor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """beneficiary if the beneficiary is already saved"""
  beneficiary: SEPABeneficiary @deprecated(reason: "because it is not already implemented.")
}

"""Sepa Credit Transfer Debtor for internal transaction"""
type SEPACreditTransferOutDebtor implements SEPACreditTransferDebtor {
  """full name of the debtor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """account number"""
  accountNumber: AccountNumber! @deprecated(reason: "because it is not already implemented (a default value is set).")
}

"""Sepa Credit Transfer transaction"""
type SEPACreditTransferTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain.
  """
  reference: String!

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """creditor information"""
  creditor: SEPACreditTransferCreditor!

  """debtor information"""
  debtor: SEPACreditTransferDebtor!

  """matching account for the transaction"""
  account: Account

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """r-transaction reason"""
  returnReason: TransactionReasonCode
}

"""SepaDirectDebitB2BMerchantPaymentMethod"""
type SepaDirectDebitB2BMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve

  """Whether this payment method uses the Swan Sepa Creditor Identifier"""
  useSwanSepaCreditorIdentifier: Boolean!

  """
  When the above is false, the value of the Sepa Creditor Identifier used
  """
  sepaCreditorIdentifier: String
}

input SepaDirectDebitB2BPaymentMethodInput {
  """If `true`, the Payment Method will be Enabled"""
  activate: Boolean = false

  """
  If `true`, the transaction will be created with the Swan Creditor Identifier
  """
  useSwanSepaCreditorIdentifier: Boolean! = true

  """
  Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false, otherwise Swan does not take this input into account (even if not empty)
  """
  sepaCreditorIdentifier: String
}

"""SepaDirectDebitCoreMerchantPaymentMethod"""
type SepaDirectDebitCoreMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve

  """Whether this payment method uses the Swan Sepa Creditor Identifier"""
  useSwanSepaCreditorIdentifier: Boolean!

  """
  When the above is false, the value of the Sepa Creditor Identifier used
  """
  sepaCreditorIdentifier: String
}

input SepaDirectDebitCorePaymentMethodInput {
  """If `true`, the Payment Method will be Pending Review"""
  activate: Boolean = false

  """
  If `true`, the transaction will be created with the Swan Creditor Identifier
  """
  useSwanSepaCreditorIdentifier: Boolean! = true

  """
  Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false, otherwise Swan does not take this input into account (even if not empty)
  """
  sepaCreditorIdentifier: String
}

"""Sepa Direct Debit Creditor"""
interface SEPADirectDebitCreditor {
  """full name of the creditor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String
}

"""Sepa Direct Debit Debtor"""
interface SEPADirectDebitDebtor {
  """full name of the debtor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String
}

"""Sepa Direct Debit Creditor for Input transaction"""
type SEPADirectDebitInCreditor implements SEPADirectDebitCreditor {
  """full name of the creditor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """account number"""
  accountNumber: AccountNumber!
}

"""Sepa Direct Debtor for Input transaction"""
type SEPADirectDebitInDebtor implements SEPADirectDebitDebtor {
  """full name of the debtor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """beneficiary if the beneficiary is already saved"""
  beneficiary: SEPABeneficiary
}

interface SEPADirectDebitMandate {
  """
  Unique identifier of the received direct debit mandate, generated by Swan
  """
  id: ID!
}

"""Sepa Direct Debit Creditor for Outgoing transaction"""
type SEPADirectDebitOutCreditor implements SEPADirectDebitCreditor {
  """full name of the creditor (max 70 characters)"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """beneficiary if the beneficiary is already saved"""
  beneficiary: SEPABeneficiary @deprecated(reason: "because it is not already implemented (a default value is set).")

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID
}

"""Sepa Direct Debtor for Outgoing transaction"""
type SEPADirectDebitOutDebtor implements SEPADirectDebitDebtor {
  """full name of the debtor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """account number"""
  accountNumber: AccountNumber! @deprecated(reason: "because it is not already implemented (a default value is set).")
}

input SepaDirectDebitPaymentCollectionInput {
  """Payment Mandate ID generated by Swan"""
  mandateId: ID!

  """Date at which the Swan merchant wishes the payment to be executed"""
  requestedExecutionAt: DateTime
}

"""
Scheme that will be used to create the underlying payment mandate for this funding source
"""
enum SEPADirectDebitScheme {
  """Sepa Direct Debit Core Scheme"""
  SepaDirectDebitCore

  """Sepa Direct Debit B2B Scheme"""
  SepaDirectDebitB2b
}

"""Sepa Direct Debit transaction"""
type SEPADirectDebitTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain.
  """
  reference: String!

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """creditor information"""
  creditor: SEPADirectDebitCreditor!

  """debtor information"""
  debtor: SEPADirectDebitDebtor!

  """matching account for the transaction"""
  account: Account

  """matching SEPA mandate for the transaction"""
  mandate: SEPADirectDebitMandate

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """reserved amount of the transaction computed with the rolling reserve."""
  reservedAmount: Amount

  """date on which reserved funds become available."""
  reservedAmountReleasedAt: DateTime

  """r-transaction reason"""
  returnReason: TransactionReasonCode
}

"""Payment direct debit mandate for SEPA"""
type SEPAPaymentDirectDebitMandate implements SEPADirectDebitMandate & PaymentDirectDebitMandate & PaymentMandate {
  """Unique identifier of the SEPA Direct Debit Payment Mandate"""
  id: ID!

  """
  List of transactions associated with the SEPA Payment Direct Debit Mandate.
  """
  transactions(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """Unique reference of the SEPA Direct Debit Payment Mandate"""
  reference: String!

  """SEPA Direct Debit Payment Mandate scheme"""
  scheme: SEPAPaymentMandateScheme!

  """SEPA Direct Debit Payment Mandate status information"""
  statusInfo: PaymentMandateStatusInfo!

  """SEPA Direct Debit Payment Mandate sequence"""
  sequence: SEPAPaymentMandateSequence!

  """SEPA Direct Debit Payment Mandate PDF document URL"""
  mandateDocumentUrl: String!

  """SEPA Direct Debit Payment Mandate debtor information"""
  debtor: SEPAPaymentMandateDebtor!

  """SEPA direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """SEPA Direct Debit Payment Mandate creditor information"""
  creditor: SEPAPaymentMandateCreditor!

  """Signature date of the SEPA Direct Debit Payment Mandate"""
  signatureDate: Date

  """Creation date of the SEPA Direct Debit Payment Mandate"""
  createdAt: DateTime!

  """Last Update date of the SEPA Direct Debit Payment Mandate"""
  updatedAt: DateTime!

  """
  Date of the the last transaction executed for the concerned SEPA Direct Debit Payment Mandate
  """
  executedAt: DateTime

  """Expiry date of the SEPA Direct Debit Payment Mandate"""
  expiredAt: Date

  """Account Holder information"""
  accountHolder: AccountHolder!

  """Custom name of the mandate"""
  name: String
}

type SEPAPaymentMandateCreditor implements PaymentMandateCreditor {
  """SEPA Direct Debit Payment Mandate creditor UUID"""
  id: ID!

  """SEPA Direct Debit Payment Mandate Sepa Creditor Idenfier (SCI)"""
  identifier: SepaCreditorIdentifier!

  """SEPA Direct Debit Payment Mandate creditor name"""
  name: String!

  """SEPA Direct Debit Payment Mandate creditor address"""
  address: Address!
}

type SEPAPaymentMandateDebtor implements PaymentMandateDebtor {
  """SEPA Direct Debit Payment Mandate debtor name"""
  name: String!

  """SEPA Direct Debit Payment Mandate debtor IBAN"""
  iban: IBAN!

  """SEPA Direct Debit Payment Mandate debtor e-mail"""
  email: String

  """SEPA Direct Debit Payment Mandate debtor country"""
  country: CCA3!

  """
  SEPA Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries
  """
  address: Address
}

input SepaPaymentMandateDebtorInput {
  """SEPA Direct Debit Payment Mandate debtor name"""
  name: String!

  """SEPA Direct Debit Payment Mandate debtor IBAN"""
  IBAN: String!
  address: AddressInput!
}

enum SEPAPaymentMandateScheme {
  """SEPA Direct Debit Core"""
  SepaDirectDebitCore

  """SEPA Direct Debit B2B"""
  SepaDirectDebitB2b
}

"""SEPA Direct Debit Payment Mandate Sequence"""
enum SEPAPaymentMandateSequence {
  """
  The SEPA Direct Debit Payment Mandate can be used for recurrent collections
  """
  Recurrent

  """The SEPA Direct Debit Payment Mandate can be used only once"""
  OneOff
}

"""Received direct debit mandate for SEPA"""
type SEPAReceivedDirectDebitMandate implements SEPADirectDebitMandate & ReceivedDirectDebitMandate {
  """
  Unique identifier of the received SEPA direct debit mandate, generated by Swan
  """
  id: ID!

  """
  List of transactions associated with the SEPA Receive Direct Debit Mandate.
  """
  transactions(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """Version of the received SEPA direct debit mandate"""
  version: String!

  """Creation date of the received SEPA direct debit mandate"""
  createdAt: DateTime!

  """Last Update date of the received SEPA direct debit mandate"""
  updatedAt: DateTime!

  """Received SEPA direct debit Unique Mandate Reference (UMR)"""
  reference: String!

  """Received SEPA direct debit mandate scheme"""
  scheme: SEPAReceivedDirectDebitMandateScheme!

  """Received SEPA direct debit mandate sequence"""
  sequence: SEPAReceivedDirectDebitMandateSequence!

  """Received SEPA direct debit creditor"""
  creditor: SEPAReceivedDirectDebitMandateCreditor!

  """Received SEPA direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """
  Date of the last SEPA direct debit transaction executed for the concerned received SEPA direct debit mandate
  """
  executedAt: DateTime

  """Date of signature of the received SEPA direct debit mandate"""
  signatureDate: Date

  """
  Expiry date of the received SEPA direct debit mandate, computed automatically (36 months from the executedAt date)
  """
  expiredAt: Date

  """Mandate status information of the received SEPA direct debit mandate"""
  statusInfo: ReceivedDirectDebitMandateStatusInfo!

  """Account of the received SEPA direct debit mandate debtor"""
  account: Account

  """Iban of the received SEPA direct debit mandate debtor"""
  iban: IBAN!

  """Mandate name"""
  name: String
}

"""SEPA received direct debit mandate creditor"""
type SEPAReceivedDirectDebitMandateCreditor {
  """SEPA Creditor identifier (SCI)"""
  identifier: String!

  """Name of the SEPA creditor"""
  name: String!

  """Address of the SEPA creditor"""
  address: Address!
}

"""Received SEPA direct debit mandate scheme"""
enum SEPAReceivedDirectDebitMandateScheme {
  """
  When the received SEPA direct debit mandate can only be used for SEPA B2B direct debit transactions
  """
  SepaDirectDebitB2b

  """
  When the received SEPA direct debit mandate can only be used for SEPA Core direct debit transactions
  """
  SepaDirectDebitCore
}

"""SEPA received direct debit mandate sequence"""
enum SEPAReceivedDirectDebitMandateSequence {
  """
  When the authorisation is given once by the SEPA Debtor to collect only one single SEPA direct debit
  """
  OneOff

  """
  When the authorisation by the Debtor can be used for regular SEPA direct debits initiated by the Creditor
  """
  Recurrent
}

"""
SEPA Identifier
max 35 Latin characters as follow :
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    0 1 2 3 4 5 6 7 8 9
    / - ? : ( ) . , '  +
with some follow extra rules :
    Content must not start or end with a /
    Content must not contain //s
"""
scalar SepaReference

enum SequenceType {
  OneOff
  Recurring
}

"""
Rejection returned when signature is not valid or remote IP address is not allowed
"""
type ServerConsentCredentialsNotValidOrOutdatedRejection implements Rejection {
  message: String!
}

"""Rejection returned when server consent is not allowed on the consent"""
type ServerConsentNotAllowedForConsentOperationRejection implements Rejection {
  message: String!
}

"""
Rejection returned when server consent is not allowed for the project associated with the consent
"""
type ServerConsentNotAllowedForProjectRejection implements Rejection {
  message: String!
}

"""
Rejection returned when there are no server consent credentials for the project
"""
type ServerConsentProjectCredentialMissingRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the server consent project credentials are not found
"""
type ServerConsentProjectCredentialNotFoundRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the server consent project settings are not found
"""
type ServerConsentProjectSettingsNotFoundRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the signature is not valid
@Deprecated
"""
type ServerConsentSignatureNotValidRejection implements Rejection {
  message: String!
}

"""Shareholder of a company creating a Capital Deposit Case"""
type Shareholder {
  """Unique identifier of a shareholder."""
  id: ID!

  """Amount the shareholder has to deposit."""
  capitalDepositAmount: Amount!

  """Onboarding information of the shareholder."""
  onboarding: Onboarding

  """Unique identifier of the shareholder account."""
  accountId: String

  """Status of the shareholder during the process with Swan."""
  status: ShareholderStatus!

  """Extra information about the shareholder"""
  info: ShareholderInfo!

  """Shareholder documents for the capital deposit case"""
  documents: [CapitalDepositDocument!]!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Information about capital deposit case."""
  relatedCapitalDepositCase: CapitalDepositCase!
}

"""Shareholder information."""
union ShareholderInfo = IndividualShareholder | CompanyShareholder

"""Status of the shareholder during the process with Swan."""
enum ShareholderStatus {
  """Waiting for the shareholder to finalize their onboarding."""
  PendingOnboarding

  """Waiting for Swan compliance team to verify the shareholder."""
  WaitingForVerification

  """
  Waiting for the shareholder to wire their share of the capital on their temporary Swan account.
  """
  WaitingForTransfer

  """When the shareholder has wired their share of the capital."""
  CapitalTransferred

  """When the shareholder's capital is wired to the notary."""
  CapitalFundsWiredToNotary
}

"""Shareholder type to identify individuals and companies."""
enum ShareholderType {
  """Individual shareholder type."""
  Individual

  """Company shareholder type."""
  Company
}

"""Signature data used during apple pay inApp provisioning"""
input SignatureData {
  """nonce"""
  nonce: String!

  """nonce signed by the secure element"""
  nonceSignature: String!

  """list of apple generated certificates"""
  certificates: [Certificate!]!
}

enum SimulationCardType {
  Physical
  Virtual
}

input SingleUseVirtualCardConfigInput {
  """Unique identifier of a given account membership"""
  accountMembershipId: ID!

  """Card name"""
  name: String

  """Spending limit"""
  spendingLimit: SpendingLimitInput!
}

"""Spending"""
type Spending {
  """period concerned"""
  period: SpendingLimitPeriod!

  """amount spent during the period"""
  amount: Amount
}

"""Spending limits"""
type SpendingLimit {
  """type of limit (defined by the Partner, defined by Swan, etc.)"""
  type: SpendingLimitType!

  """period concerned"""
  period: SpendingLimitPeriod!

  """sum of amount of spending authorized during the period"""
  amount: Amount!
}

"""Inputs when editing spending limit configuration"""
input SpendingLimitInput {
  """period concerned"""
  period: SpendingLimitPeriodInput!

  """sum of amount of spending authorized during the period"""
  amount: AmountInput!
}

"""Available period to compute spending limits"""
enum SpendingLimitPeriod {
  Monthly
  Weekly
  Daily
  Always
}

"""Available period to compute spending limits"""
enum SpendingLimitPeriodInput {
  Monthly
  Weekly
  Daily
  Always
}

"""Available type of spending limits"""
enum SpendingLimitType {
  """for the account holder - defined by the partner"""
  AccountHolder

  """for the partner - defined by Swan"""
  Partner
}

type StandingOrder {
  """Standing Order unique identifier"""
  id: ID!

  """A list of payments of an standing order."""
  payments(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start at a specific offset"""
    offset: Int

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be ordered"""
    orderBy: PaymentOrderByInput

    """When the list of elements needs to be filtered"""
    filters: PaymentFiltersInput
  ): PaymentConnection!

  """
  reference that will be transferred to the beneficiary throughout the entire end-to-end chain
  """
  reference: String

  """label that will be transferred to the beneficiary"""
  label: String

  """Fixed Amount that will be regularly transferred"""
  amount: Amount

  """
  Target available balance value that will be used for periodically clipping the account
  """
  targetAvailableBalance: Amount

  """Scheduled period of Standing Order"""
  period: StandingOrderPeriod!

  """Earlier date the Standing Order will be executed"""
  firstExecutionDate: DateTime

  """Latest date the Standing Order will be executed"""
  lastExecutionDate: DateTime

  """SEPA beneficiary of the Standing Order"""
  sepaBeneficiary: SEPABeneficiary!

  """Status of the Standing Order"""
  statusInfo: StandingOrderStatusInfo!

  """Date the Standing Order has been created"""
  createdAt: Date!

  """Last date the Standing Order has been updated"""
  updatedAt: Date!

  """Account of the Standing Order"""
  account: Account!

  """Identity that scheduled the Standing Order"""
  createdBy: User!

  """Next execution date of the Standing Order, if any"""
  nextExecutionDate: Date

  """Transfer mode of the Standing Order"""
  creditTransferMode: CreditTransferMode
}

type StandingOrderCanceledStatusInfo implements StandingOrderStatusInfo {
  canceledAt: Date!
  status: StandingOrderStatus!
}

"""Please see the Connection interface"""
type StandingOrderConnection implements Connection {
  pageInfo: PageInfo!
  edges: [StandingOrderEdge!]!
  totalCount: Int!
}

type StandingOrderConsentPendingStatusInfo implements StandingOrderStatusInfo {
  status: StandingOrderStatus!
  consent: Consent!
}

"""Please see the Connection interface"""
type StandingOrderEdge implements Edge {
  node: StandingOrder!
  cursor: String!
}

type StandingOrderEnabledStatusInfo implements StandingOrderStatusInfo {
  status: StandingOrderStatus!
}

"""Rejection returned when Standing Order is not found"""
type StandingOrderNotFoundRejection implements Rejection {
  message: String!
}

enum StandingOrderPeriod {
  Daily
  Weekly
  Monthly
}

enum StandingOrderStatus {
  ConsentPending
  Enabled
  Canceled
}

interface StandingOrderStatusInfo {
  status: StandingOrderStatus!
}

"""
Describes an identification level that has started for the process of the current identification
"""
type StartedIdentificationLevelStatusInfo {
  """Always set to `Started`"""
  status: SwanIdentificationStatus!
}

"""
A statement represent metadata around a banking document that list all of the BOOKED banking transactions that have happened between startDate and endDate
"""
type Statement {
  """unique identifier of the statement"""
  id: ID!

  """account of the statement"""
  account: Account!

  """booked balance at the start of the window"""
  openingBalance: Amount!

  """booked balance at the end of the window"""
  closingBalance: Amount!

  """starting date of the date window"""
  openingDate: DateTime!

  """ending date of the date window"""
  closingDate: DateTime!

  """status of the statement"""
  status: StatementStatus!

  """period of statement (either custom or monthly)"""
  period: StatementPeriod

  """the sum of credit transactions during the window"""
  totalCredits: Amount!

  """the sum of debit transactions during the window"""
  totalDebits: Amount!

  """the sum of fee transactions during the window"""
  fees: Amount!

  """type of statements (ex: PDF)"""
  type: [StatementInfo]!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)).
"""
type StatementConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Int!
  edges: [StatementEdge!]!
}

"""Implements the Relay Edge interface."""
type StatementEdge implements Edge {
  node: Statement!
  cursor: String!
}

"""
Filter that can be given to give the statement in a specific data range
"""
input StatementFiltersInput {
  """To filter after an updatedAt value"""
  isAfterUpdatedAt: DateTime

  """To filter before an updatedAt value"""
  isBeforeUpdatedAt: DateTime

  """To filter on a specific period of statement (either custom or monthly)"""
  period: StatementPeriod
}

"""Custom information for a certain type of statement"""
interface StatementInfo {
  type: StatementType
}

"""The different periods of statement"""
enum StatementPeriod {
  Monthly
  Custom
}

"""The different statuses of statement"""
enum StatementStatus {
  Available
  Failed
  Pending
}

"""
The different type of statement actually available
- PDF will be a PDF file with the statement information
"""
enum StatementType {
  PDF
  CSV
}

"""Supporting document used for compliance"""
type SupportingDocument {
  """Unique identifier of the document"""
  id: String!

  """Supporting document status information"""
  statusInfo: SupportingDocumentStatusInfo!

  """Type of supporting Document"""
  supportingDocumentType: SupportingDocumentType

  """Purpose of supporting document"""
  supportingDocumentPurpose: SupportingDocumentPurposeEnum!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!
}

type SupportingDocumentAccountHolder {
  id: ID
}

"""
Collection of supporting documents used for compliance

Fetching SupportingDocument is restricted to Project access token
"""
type SupportingDocumentCollection {
  """Unique identifier of the supporting document collection"""
  id: String!

  """Status of the supporting document collection"""
  statusInfo: SupportingDocumentCollectionStatusInfo!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  List of supported documents contained in the supporting document collection
  """
  supportingDocuments: [SupportingDocument]!

  """
  List of required supporting document purposes for this supporting document collection
  """
  requiredSupportingDocumentPurposes: [SupportingDocumentPurpose!]!
  accountHolder: SupportingDocumentAccountHolder!
  onboarding: SupportingDocumentOnboarding!
}

"""Supporting document collection with Approved status"""
type SupportingDocumentCollectionApprovedStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the supporting document collection is approved"""
  status: SupportingDocumentCollectionStatus!

  """Date on which the supporting document collection has been approved"""
  approvedAt: DateTime!
}

"""Supporting document collection with Canceled status"""
type SupportingDocumentCollectionCanceledStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the supporting document collection is canceled"""
  status: SupportingDocumentCollectionStatus!

  """Date on which the supporting document collection has been canceled"""
  canceledAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type SupportingDocumentCollectionConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """SupportingDocumentCollectionEdge list"""
  edges: [SupportingDocumentCollectionEdge!]!
}

"""Implements the Relay Edge interface"""
type SupportingDocumentCollectionEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The supporting document collection"""
  node: SupportingDocumentCollection!
}

"""Rejection returned if the supporting document collection was not found"""
type SupportingDocumentCollectionNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Supporting document collection with PendingReview status"""
type SupportingDocumentCollectionPendingReviewStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """
  When the supporting document collection is completed and in compliance review
  """
  status: SupportingDocumentCollectionStatus!
}

"""Supporting document collection with Rejected status"""
type SupportingDocumentCollectionRejectedStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the supporting document collection is rejected"""
  status: SupportingDocumentCollectionStatus!

  """Date on which the supporting document collection has been rejected"""
  rejectedAt: DateTime!
}

"""Verification status of a supporting document collection"""
enum SupportingDocumentCollectionStatus {
  """When the supporting document collection is created and on going"""
  WaitingForDocument

  """
  When the supporting document collection is completed and in compliance review
  """
  PendingReview

  """When the supporting document collection is approved. Final status"""
  Approved

  """When the supporting document collection is canceled. Final status"""
  Canceled

  """When the supporting document collection is rejected. Final status"""
  Rejected
}

"""
Rejection returned if supporting document cannot be deleted because its supporting document collection status is not WaitingForDocument
"""
type SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection implements Rejection {
  message: String!
  supportingDocumentCollectionStatus: SupportingDocumentCollectionStatus!
  supportingDocumentCollection: SupportingDocumentCollection!
}

"""
Rejection returned if supporting document cannot be updated because its supporting document collection status is not WaitingForDocument
"""
type SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection implements Rejection {
  message: String!
  supportingDocumentCollectionStatus: SupportingDocumentCollectionStatus!
  supportingDocumentCollection: SupportingDocumentCollection!
}

interface SupportingDocumentCollectionStatusInfo {
  """Status of the supporting document collection"""
  status: SupportingDocumentCollectionStatus!
}

"""Rejection returned if the status transition is not allowed"""
type SupportingDocumentCollectionStatusNotAllowedRejection implements Rejection {
  oldStatus: SupportingDocumentCollectionStatus!
  newStatus: SupportingDocumentCollectionStatus!
  message: String!
}

"""Supporting document collection with WaitingForUpload status"""
type SupportingDocumentCollectionWaitingForDocumentStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the Supporting Document Collection is created"""
  status: SupportingDocumentCollectionStatus!
}

enum SupportingDocumentCollectMode {
  API
  EndCustomer
  Partner
}

enum SupportingDocumentCommunicationLanguageSettings {
  en
  fr
}

"""Rejection returned if the supporting document was not found"""
type SupportingDocumentNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Supporting document with NotUploaded status."""
type SupportingDocumentNotUploadedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has not been updated on time."""
  status: SupportingDocumentStatus!
}

type SupportingDocumentOnboarding {
  id: ID
}

type SupportingDocumentPostField {
  key: String!
  value: String!
}

"""Details of a supporting document purpose"""
type SupportingDocumentPurpose {
  """Technical name of the purpose"""
  name: SupportingDocumentPurposeEnum!

  """
  Corresponding supporting document types accepted for this supporting document purpose
  """
  acceptableSupportingDocumentTypes: [SupportingDocumentType!]!
}

"""Supporting document purpose"""
enum SupportingDocumentPurposeEnum {
  """Proof of association registration"""
  AssociationRegistration

  """Banking"""
  Banking

  """Proof of company registration"""
  CompanyRegistration

  """Minutes Of The General Assembly"""
  GeneralAssemblyMinutes

  """Other"""
  Other

  """Signed power of attorney document to give the power to act on behalf."""
  PowerOfAttorney

  """Proof of company address"""
  ProofOfCompanyAddress

  """Proof of company income"""
  ProofOfCompanyIncome

  """Proof of identity"""
  ProofOfIdentity

  """Proof of individual address"""
  ProofOfIndividualAddress

  """Proof of individual income"""
  ProofOfIndividualIncome

  """Proof of origin of funds"""
  ProofOfOriginOfFunds

  """Signed status"""
  SignedStatus

  """UBO Declaration"""
  UBODeclaration

  """Sworn statement"""
  SwornStatement

  """Proof of identity of the legal representative"""
  LegalRepresentativeProofOfIdentity

  """Proof of identity of the Ultimate Beneficial Owner"""
  UltimateBeneficialOwnerProofOfIdentity

  """NIF Accreditation Card"""
  NIFAccreditationCard

  """Decision of appointment of the President"""
  PresidentDecisionOfAppointment

  """Decision of appointment of Administrator"""
  AdministratorDecisionOfAppointment

  """Financial Statements"""
  FinancialStatements

  """Proof of address of the Ultimate Beneficial Owner"""
  UltimateBeneficialOwnerProofOfAddress
}

"""Supporting document with Refused status"""
type SupportingDocumentRefusedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has been refused by Swan"""
  status: SupportingDocumentStatus!

  """An unique URL and one-time URL to download the Document"""
  downloadUrl: String!

  """Date on which the supporting document collection has been refused"""
  refusedAt: DateTime!

  """Reason why the supporting document has been refused"""
  reason: String!

  """Original file name"""
  filename: String!
}

type SupportingDocumentSettings {
  collectMode: SupportingDocumentCollectMode!
  communicationLanguage: SupportingDocumentCommunicationLanguageSettings
  emailContact: String
}

"""Verification status of a document"""
enum SupportingDocumentStatus {
  """Document is not uploaded yet."""
  WaitingForUpload

  """Document has been uploaded but not verified by Swan yet."""
  Uploaded

  """Document has been uploaded and verified by Swan."""
  Validated

  """Document has been refused by Swan."""
  Refused

  """Document has not been uploaded on time."""
  NotUploaded
}

"""
Rejection returned if supporting document cannot be deleted because of its status
"""
type SupportingDocumentStatusDoesNotAllowDeletionRejection implements Rejection {
  supportingDocument: SupportingDocument!
  status: SupportingDocumentStatus!
  message: String!
}

"""
Rejection returned if supporting document cannot be updated because of its status
"""
type SupportingDocumentStatusDoesNotAllowUpdateRejection implements Rejection {
  supportingDocument: SupportingDocument!
  status: SupportingDocumentStatus!
  message: String!
}

interface SupportingDocumentStatusInfo {
  """Status of the supporting document"""
  status: SupportingDocumentStatus!
}

"""Rejection returned if the status transition is not allowed"""
type SupportingDocumentStatusNotAllowedRejection implements Rejection {
  oldStatus: SupportingDocumentStatus!
  newStatus: SupportingDocumentStatus!
  message: String!
}

"""Specific type for document"""
enum SupportingDocumentType {
  """Selfie"""
  Selfie

  """Passport"""
  Passport

  """NationalIdCard"""
  NationalIdCard

  """Resident permit"""
  ResidentPermit

  """Driving license"""
  DrivingLicense

  """Water, Electricity or Gas Bill issued within the last 3 months"""
  UtilityBill

  """Telephone Bill issued within the last 3 months"""
  PhoneBill

  """Rental Receipt issued within the last 3 months"""
  RentReceipt

  """Home Insurance contract"""
  HomeInsurance

  """
  Income Tax return or tax-exemption certificate dating less than 2 years
  """
  IncomeTaxReturn

  """A pay slip dating less than 3 months"""
  PaySlip

  """Commercial registry extract issued within the last 3 months"""
  RegisterExtract

  """Legal document required for companys formation"""
  ArticlesOfIncorporation

  """Share Deposit Certificate"""
  CapitalShareDepositCertificate

  """Ultimate Beneficial Owner Declaration"""
  UBODeclaration

  """Association registration proof for french association"""
  JOAFFEExtract

  """
  Lease agreement in the name of the business or Proof of Individual Address if the company is hosted by one of the legal representative
  """
  CompanyLeaseAgreement

  """Bank Statement"""
  BankStatement

  """
  Document with details such as bank name, address, account number and account holder
  """
  BankAccountDetails

  """Signed power of attorney document to give the power to act on behalf"""
  PowerOfAttorney

  """
  Document submitted to your tax bureau at the end of the last business period
  """
  CorporateIncomeTaxReturn

  """Other"""
  Other

  """By Laws"""
  ByLaws

  """Account statement"""
  AccountStatement

  """Deed of donation"""
  DeedOfDonation

  """Deed of sale"""
  DeedOfSale

  """Deed of succession"""
  DeedOfSuccession

  """Loan contract"""
  LoanContract

  """Notarial deed"""
  NotarialDeed

  """Sworn statement"""
  SwornStatement

  """Meeting's minutes"""
  MeetingMinutes

  """NIF Accreditation Card"""
  NIFAccreditationCard

  """Decision of appointment"""
  DecisionOfAppointment

  """Financial Statements"""
  FinancialStatements
}

"""Supporting document with Uploaded status"""
type SupportingDocumentUploadedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has been uploaded but not verified by Swan yet"""
  status: SupportingDocumentStatus!

  """An unique URL and one-time URL to download the Document"""
  downloadUrl: String!

  """Original file name"""
  filename: String!
}

type SupportingDocumentUploadInfo {
  url: String!
  fields: [SupportingDocumentPostField!]!
}

"""
Rejection returned if the supporting document collection cannot receive supporting documents anymore
"""
type SupportingDocumentUploadNotAllowedRejection implements Rejection {
  supportingDocumentCollectionStatus: SupportingDocumentCollectionStatus!
  message: String!
}

"""Supporting document with Validated status"""
type SupportingDocumentValidatedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has been uploaded and verified by Swan"""
  status: SupportingDocumentStatus!

  """An unique URL and one-time URL to download the Document"""
  downloadUrl: String!

  """Date on which the supporting document has been validated"""
  validatedAt: DateTime!

  """Original file name"""
  filename: String!
}

"""Supporting document with WaitingForUpload status"""
type SupportingDocumentWaitingForUploadStatusInfo implements SupportingDocumentStatusInfo {
  """When the document is not uploaded yet"""
  status: SupportingDocumentStatus!

  """
  Info to upload the document : url and fields to add along file in form (POST)
  """
  upload: SupportingDocumentUploadInfo!
}

input SuspendAccountMembershipInput {
  accountMembershipId: ID!
}

union SuspendAccountMembershipPayload = SuspendAccountMembershipSuccessPayload | InternalErrorRejection | LegalRepresentativeAccountMembershipCannotBeSuspendedRejection | UserNotAllowedToManageAccountMembershipRejection | UserNotAllowedToSuspendItsOwnAccountMembershipRejection | ValidationRejection

type SuspendAccountMembershipSuccessPayload {
  accountMembership: AccountMembership!
}

"""
Define a reason with a message and a specific type for suspend account action
"""
type SuspendAccountReason implements Reason {
  type: SuspendAccountReasonType!
  message: String
}

"""Input version"""
input SuspendAccountReasonInput {
  type: SuspendAccountReasonType!
  message: String
}

"""Specific type for suspend account action"""
enum SuspendAccountReasonType {
  """Simple suspend request"""
  SuspendRequested
}

"""SuspendAccountStatusReason"""
union SuspendAccountStatusReason = SuspendAccountReason

"""StatusInfo when funding limit settings has been suspended"""
type SuspendedFundingLimitSettingsStatusInfo implements FundingLimitSettingsStatusInfo {
  status: FundingLimitSettingsStatus!
  reason: String!
}

"""Funding Source Suspended status information"""
type SuspendedFundingSourceStatusInfo implements FundingSourceStatusInfo {
  """Funding Source Suspended status"""
  status: FundingSourceStatus!

  """Date at which the funding source was suspended"""
  suspendedAt: Date!
}

"""SuspendedMerchantPaymentMethodStatusInfo"""
type SuspendedMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method suspended date"""
  suspendedAt: Date!
}

"""SuspendedMerchantProfileStatusInfo"""
type SuspendedMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  suspendedAt: Date!
}

"""Inputs to suspend a physical card"""
input SuspendPhysicalCardInput {
  """Unique identifier of a card"""
  cardId: ID!
}

union SuspendPhysicalCardPayload = SuspendPhysicalCardSuccessPayload | AccountMembershipNotAllowedRejection | CardNotFoundRejection | ForbiddenRejection | PhysicalCardNotFoundRejection | ValidationRejection

type SuspendPhysicalCardSuccessPayload {
  """The physicalCard suspended"""
  physicalCard: PhysicalCard!
}

"""
Rejection returned if the SuspendReceivedDirectDebitMandatedRejection mutation is rejected
"""
type SuspendReceivedDirectDebitMandatedRejection implements Rejection {
  message: String!
  reason: SuspendReceivedDirectDebitMandatedRejectionReason!
}

"""
Enum of reasons of rejection for suspendReceivedDirectDebitMandate mutation
"""
enum SuspendReceivedDirectDebitMandatedRejectionReason {
  """
  Received direct debit mandate is canceled and therefore can't be suspend
  """
  ReceivedDirectDebitMandateCanceled
}

"""Inputs to suspend a received direct debit mandate"""
input SuspendReceivedDirectDebitMandateInput {
  receivedDirectDebitMandateId: ID!
}

"""Union type returned by the suspendReceivedDirectDebitMandate mutation"""
union SuspendReceivedDirectDebitMandatePayload = SuspendReceivedDirectDebitMandateSuccessPayload | SuspendReceivedDirectDebitMandatedRejection | ReceivedDirectDebitMandateNotFoundRejection | ReceivedDirectDebitMandateCanceledRejection | ForbiddenRejection

"""
Return type in case of a successful response of the suspendReceivedDirectDebitMandate mutation
"""
type SuspendReceivedDirectDebitMandateSuccessPayload {
  """the received direct debit mandate is suspended"""
  receivedDirectDebitMandate: ReceivedDirectDebitMandate!
}

"""Swan account beneficiary"""
input SwanAccountBeneficiaryInput {
  """account number to be credited"""
  accountNumber: AccountNumber!

  """full name of the beneficiary  (max 70 characters)"""
  name: String!

  """
  `true` if this new beneficiary will be saved to the beneficiary list of the debited account.
  """
  save: Boolean!
}

"""Status values of an identification"""
enum SwanIdentificationStatus {
  """
  When the identification process is currently being treated by a manual or automatic process
  """
  Pending

  """When the identification is valid"""
  Valid

  """When the identification is invalid"""
  Invalid

  """
  When the user canceled the identification process or the identification service was unavailable
  """
  Canceled

  """When the identification is no longer valid"""
  Expired

  """When the identification does not support an identification level"""
  NotSupported

  """When the identification hasn't been started yet"""
  NotStarted

  """When the identification has been started"""
  Started
}

type SwanTCUDocumentNotFoundRejection implements Rejection {
  message: String!
}

type SwanTCUDocumentStatusNotAllowedRejection implements Rejection {
  message: String!
}

type TextField implements Field {
  displayFormat: String
  example: String
  key: String!
  maxLength: Int
  minLength: Int
  name: String!
  refreshDynamicFieldsOnChange: Boolean!
  required: Boolean!
  validationRegex: String
}

"""Individual ultimate beneficial owner title (Mr/Ms)"""
enum TitleEnum {
  """Identified as a man"""
  Mr

  """Identified as a woman"""
  Ms
}

scalar TokenRequestorId

"""
Rejection returned when trying to create a multi consent with too many child consents
"""
type TooManyChildConsentsRejection implements Rejection {
  message: String!
}

"""Rejection returned if too many items are given"""
type TooManyItemsRejection implements Rejection {
  message: String!
}

"""Transaction"""
interface Transaction {
  """unique identifier of the transaction"""
  id: ID!

  """external identifier of the transaction"""
  reference: String!

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """matching account for this transaction"""
  account: Account

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction
}

"""Please see the Connection interface"""
type TransactionConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Int!
  edges: [TransactionEdge!]!
}

"""Please see the Edge interface"""
type TransactionEdge implements Edge {
  node: Transaction!
  cursor: String!
}

"""Rejection returned if the transaction was not found"""
type TransactionNotFoundRejection implements Rejection {
  transactionId: ID!
  message: String!
}

"""The following reason codes for a r-transaction are defined:"""
enum TransactionReasonCode {
  """Rejected because the account is closed"""
  AccountClosed

  """Rejected because the account holder is deceased"""
  AccountHolderDeceased

  """Rejected because the account is suspended"""
  AccountSuspended

  """Rejected because the account is unknown"""
  AccountUnknown

  """Rejected by the bank"""
  BankRefused

  """Creditor account is blocked"""
  BeneficiaryAccountBlocked

  """Creditor account is closed"""
  BeneficiaryAccountClosed

  """Creditor account number is incorrect"""
  BeneficiaryAccountIncorrect

  """Creditor account number does not exist"""
  BeneficiaryAccountUnknown

  """Rejected because the creditor bank is not reachable"""
  BeneficiaryBankNotReachable

  """Customer is deceased"""
  BeneficiaryDeceased

  """Rejected because the card is expired"""
  CardExpired

  """Rejected because the card is not activated yet"""
  CardNotActivated

  """Rejected because the card has been permanently blocked"""
  CardPermanentlyBlocked

  """Rejected because the card is suspended"""
  CardSuspended

  """Invalid check"""
  CheckInvalid

  """Invalid check number"""
  CheckNumberInvalid

  """Rejected because the creditor bank is offline"""
  CreditorBankOffline

  """Rejected following an error from the creditor bank"""
  CreditorBankTechnicalErrorOccurred

  """Rejected following a timeout from the creditor bank"""
  CreditorBankTimeout

  """Debtor Account Blocked"""
  DebtorAccountBlocked

  """Rejected because the debtor account is closed"""
  DebtorAccountClosed

  """
  Rejected because the debtor is a non business account and the transaction is a B2B SEPA Direct Debit transaction
  """
  DebtorAccountConsumer

  """Rejected because the debtor account is unknown"""
  DebtorAccountUnknown

  """Rejected because the debtor bank is offline"""
  DebtorBankOffline

  """Rejected following an error from the debtor bank"""
  DebtorBankTechnicalErrorOccurred

  """Rejected following a timeout from the debtor bank"""
  DebtorBankTimeout

  """Rejected because the debtor account holder is dead"""
  DebtorDeceased

  """Funds already transferred back to the originator"""
  FundsAlreadyTransferredBack

  """Rejected because of insufficient funds on the account"""
  InsufficientFunds

  """
  Rejected because the expiration date entered does not match the one on the card
  """
  InvalidExpirationDate

  """Rejected because the PIN is invalid"""
  InvalidPin

  """
  Rejected because there were too many invalid tries on the PIN validation
  """
  InvalidPinAttemptsExceeded

  """
  Rejected because the security number entered does not match the one on the card
  """
  InvalidSecurityNumber

  """Funds cannot be reimbursed by beneficiary bank/legal decision"""
  LegalOrBankDecision

  """Rejected by debtor because the mandate is invalid"""
  MandateInvalid

  """
  Rejected because the merchant must request a new transaction with authorisation
  """
  MerchantShouldResubmitAuthorization

  """No answer from customer"""
  NoAnswerFromBeneficiary

  """No original transaction received"""
  NoOriginalTransactionReceived

  """Rejected by the partner (you)"""
  PartnerRefused

  """Rejected following an error or a timeout from the partner"""
  PartnerTechnicalErrorOccurred

  """
  Rejected because the maximum amount allowed on the given period has been exceeded
  """
  PeriodAmountLimitExceeded

  """
  Rejected because the maximum number of transactions on the given period has been exceeded
  """
  PeriodNbTransactionLimitExceeded

  """
  Rejected because a transaction with PIN code is required to continue to using the card
  """
  PinRequiredForFurtherTransaction

  """Rejected by bank with no specified reason"""
  ReasonNotSpecifiedByBank

  """Reason unspecified"""
  ReasonNotSpecifiedByBeneficiary

  """Rejected by debtor with no specified reason"""
  ReasonNotSpecifiedByDebtor

  """Customer request"""
  ReasonNotSpecifiedByOriginator

  """Recall request accepted by beneficiary bank or beneficiary"""
  RecallAccepted

  """Refund requested by end customer"""
  RefundRequestedByDebtor

  """Rejected by bank for regulatory reason"""
  RegulatoryReason

  """Invalid RLMC key, please control the key and the check number"""
  RlmcKeyInvalid

  """Rejected because the debtor or the creditor bank is offline"""
  SwanOffline

  """Rejected by Swan"""
  SwanRefused

  """Rejected because of a Swan technical error"""
  SwanTechnicalErrorOccurred

  """Rejected because of a Swan timeout"""
  SwanTimeout

  """Technical issue resulting in incorrect transactions sent out"""
  TechnicalIssue

  """Rejected because the terms and conditions limit has been exceeded"""
  TermsAndConditionsLimitExceeded

  """Wrong transaction amount"""
  TransactionAmountIncorrect

  """
  Rejected because the maximum amount for a transaction has been exceeded
  """
  TransactionAmountLimitExceeded

  """Rejected by bank because this transaction is duplicated"""
  TransactionDuplicated

  """Rejected because the transaction is forbidden on this type of account"""
  TransactionOnAccountTypeNotAllowed

  """Rejected because the type of transaction is forbidden on the account"""
  TransactionTypeNotAllowed
}

"""the criteria to filter transactions"""
input TransactionsFiltersInput {
  """To filter on some Transaction Status (all if empty)"""
  status: [TransactionStatus!]

  """To filter on some Payment Products (all if empty)"""
  paymentProduct: [PaymentProduct!]

  """To filter after an updatedAt value"""
  isAfterUpdatedAt: DateTime

  """To filter before an updatedAt value"""
  isBeforeUpdatedAt: DateTime

  """To filter on some text occurrences (words or ids)"""
  search: String

  """To filter on some transaction types"""
  type: [TransactionTypeEnum!]

  """
  To filter so it includes rejected transactions that had a fallback (`true` by default)
  """
  includeRejectedWithFallback: Boolean
}

"""Transaction side"""
enum TransactionSide {
  """when the transaction debit the account"""
  Debit

  """when the transaction credit the account"""
  Credit
}

enum TransactionsOrderByField {
  id
  createdAt
  updatedAt
  executionDate
}

"""the criteria to sort transactions"""
input TransactionsOrderByInput {
  field: TransactionsOrderByField
  direction: OrderByDirection
}

"""Transaction status"""
enum TransactionStatus {
  """
  when the transaction is posted to the Swan book and impact the booked balance
  """
  Booked

  """when the transaction is rejected"""
  Rejected

  """
  when the transaction is pending and the amount impact the available balance
  """
  Pending

  """
  when a pending transaction is canceled and the amount is released on the available balance
  """
  Canceled

  """
  when the transaction is upcoming (scheduled credit transfer, direct debit ...)
  """
  Upcoming

  """
  when a card authorization is released after X days or fully consumed by X debits
  """
  Released
}

"""Transaction Status information"""
interface TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!
}

"""Transaction Type"""
enum TransactionTypeEnum {
  """When an internal Credit Transfer debited a Swan account."""
  InternalCreditTransferOut

  """
  When an internal Credit Transfer debited a Swan account and Swan or the Swan creditor returned the funds.
  """
  InternalCreditTransferOutReturn

  """
  When an internal Credit Transfer debited a Swan account, Swan or the Swan debtor asked for a recall of the transaction, and Swan or the Swan creditor accepted the recall request.
  """
  InternalCreditTransferOutRecall

  """When an internal Credit Transfer credited a Swan account."""
  InternalCreditTransferIn

  """
  When an internal Credit Transfer credited a Swan account and Swan or the Swan debtor returned the funds.
  """
  InternalCreditTransferInReturn

  """
  When an internal Credit Transfer credited a Swan account, Swan or the Swan creditor asked for a recall of the transaction, and Swan or the Swan debtor accepted the recall request.
  """
  InternalCreditTransferInRecall

  """When a Sepa Credit Transfer debited a Swan account."""
  SepaCreditTransferOut

  """When an instant Sepa Credit Transfer debited a Swan account."""
  SepaInstantCreditTransferOut

  """When an instant Sepa Credit Transfer credited a Swan account."""
  SepaInstantCreditTransferIn

  """
  When a Sepa Credit Transfer debited a Swan account and the creditor bank or the creditor returned the funds.
  """
  SepaCreditTransferOutReturn

  """
  When a Sepa Instant Credit Transfer debited a Swan account, Swan or the Swan debtor asked for a recall of the transaction, and the creditor bank or the creditor accepted the recall request.
  """
  SepaInstantCreditTransferOutRecall

  """
  When a Sepa Instant Credit Transfer credited a Swan account, Swan or the Swan creditor asked for a recall of the transaction, and the debtor bank or the debtor accepted the recall request.
  """
  SepaInstantCreditTransferInRecall

  """
  When a Sepa Credit Transfer debited a Swan account, Swan or the Swan debtor asked for a recall of the transaction, and the creditor bank or the creditor accepted the recall request.
  """
  SepaCreditTransferOutRecall

  """When a Sepa Credit Transfer credited a Swan account."""
  SepaCreditTransferIn

  """
  When a Sepa Credit Transfer credited a Swan account and Swan or the Swan debtor returned the funds.
  """
  SepaCreditTransferInReturn

  """
  When a Sepa Credit Transfer credited a Swan account, Swan or the Swan creditor asked for a recall of the transaction, and the debtor bank or the debtor accepted the recall request.
  """
  SepaCreditTransferInRecall

  """When a fee is debited from a Swan account."""
  FeesOut

  """When a fee is credited to a Swan account."""
  FeesIn

  """When a Sepa Direct Debit credited a Swan account."""
  SepaDirectDebitIn

  """
  When a Sepa Direct Debit credited a Swan account and the debtor bank or the debtor returned it.
  """
  SepaDirectDebitInReturn

  """
  *COMING SOON*
  When a Sepa Direct Debit credited a Swan account and Swan or the Swan creditor reversed it.
  """
  SepaDirectDebitInReversal

  """When a Sepa Direct Debit debited a Swan account."""
  SepaDirectDebitOut

  """
  When a Sepa Direct Debit debited a Swan account and Swan or the Swan debtor returned it.
  """
  SepaDirectDebitOutReturn

  """
  When a Sepa Direct Debit debited a Swan account and the creditor bank or the creditor reversed it.
  """
  SepaDirectDebitOutReversal

  """When a card authorization has been received by Swan."""
  CardOutAuthorization

  """When a card debit debited a Swan account."""
  CardOutDebit

  """
  When a card debit has been reversed by the merchant (credited on a Swan account).
  """
  CardOutDebitReversal

  """When a card credit credited a Swan account."""
  CardOutCredit

  """
  When a card credit has been reversed by the merchant (debited on a Swan account).
  """
  CardOutCreditReversal

  """When an Internal Direct Debit credited a Swan account."""
  InternalDirectDebitIn

  """
  When an Internal Direct Debit credited a Swan account and Swan or the debtor returned the funds.
  """
  InternalDirectDebitInReturn

  """When an Internal Direct Debit debited a Swan account."""
  InternalDirectDebitOut

  """
  When an Internal Direct Debit debited a Swan account and Swan or the debtor returned the funds.
  """
  InternalDirectDebitOutReturn

  """When a Check credited a Swan account."""
  CheckIn

  """
  When a Check credited a Swan account and Swan or the debtor returned the funds.
  """
  CheckInReturn

  """
  *COMING SOON*
  When an International Credit Transfer credited a Swan account.
  """
  InternationalCreditTransferIn

  """
  *COMING SOON*
  When an International Credit Transfer debited a Swan account.
  """
  InternationalCreditTransferOut

  """
  *COMING SOON*
  When an International Credit Transfer credited a Swan account and Swan or the Swan debtor returned the funds.
  """
  InternationalCreditTransferInReturn

  """
  *COMING SOON*
  When an International Credit Transfer debited a Swan account and Swan or the Swan debtor returned it.
  """
  InternationalCreditTransferOutReturn
}

"""Quality of the account holder doing the onboarding"""
enum TypeOfRepresentation {
  """The account holder is the legal representative"""
  LegalRepresentative

  """The account holder has a power of attorney"""
  PowerOfAttorney
}

"""Ultimate beneficial Direct Owner company info."""
type UltimateBeneficialDirectOwnerCompanyInfo implements UltimateBeneficialOwnerInfo {
  """Ultimate Beneficial Owner Unique Identifier ."""
  id: ID!

  """Ultimate beneficial Direct Owner Company type."""
  type: UltimateBeneficialOwnerType!

  """
  Shares ratio of the parent company. Example: 50 if the share ratio is 50%.
  """
  parentCompanyShareRatio: Float!

  """Name of the company."""
  name: String!

  """Registration number."""
  registrationNumber: String!
}

"""Ultimate beneficial Direct Owner individual info."""
type UltimateBeneficialDirectOwnerIndividualInfo implements UltimateBeneficialOwnerInfo {
  """Ultimate Beneficial Owner Unique Identifier ."""
  id: ID!

  """Ultimate beneficial Direct owner Individual type ."""
  type: UltimateBeneficialOwnerType!

  """
  Shares ratio of the parent company. Example: 50 if the share ratio is 50%.
  """
  parentCompanyShareRatio: Float!

  """First name."""
  firstName: String!

  """Last name."""
  lastName: String!

  """Birth date."""
  birthDate: Date!
}

"""Ultimate beneficial owner company info."""
type UltimateBeneficialIndirectOwnerCompanyInfo implements UltimateBeneficialOwnerInfo {
  """Ultimate Beneficial Owner Unique Identifier ."""
  id: ID!

  """Ultimate beneficial Indirect Owner Company type."""
  type: UltimateBeneficialOwnerType!

  """Unique Reference of the Parent Company."""
  parentCompanyReference: String!

  """
  Shares ratio of the parent company. Example: 50 if the share ratio is 50%.
  """
  parentCompanyShareRatio: Float!

  """Name of the company."""
  name: String!

  """Registration number."""
  registrationNumber: String!
}

"""Ultimate beneficial Indirect Owner individual info."""
type UltimateBeneficialIndirectOwnerIndividualInfo implements UltimateBeneficialOwnerInfo {
  """Ultimate Beneficial Owner Unique Identifier."""
  id: ID!

  """Ultimate beneficial Indirect Owner Individual type ."""
  type: UltimateBeneficialOwnerType!

  """Unique Reference of the Parent Company."""
  parentCompanyReference: String!

  """
  Shares ratio of the parent company. Example: 50 if the share ratio is 50%.
  """
  parentCompanyShareRatio: Float!

  """First name."""
  firstName: String!

  """Last name."""
  lastName: String!

  """Birth date."""
  birthDate: Date!
}

"""
The Ultimate Beneficial Owner could be for an Individual or a Company and these can Direct or Indirect
"""
interface UltimateBeneficialOwnerInfo {
  """Ultimate Beneficial Owner Unique Identifier ."""
  id: ID!

  """Ultimate beneficial owner type."""
  type: UltimateBeneficialOwnerType!

  """
  Shares ratio of the parent company. Example: 50 if the share ratio is 50%.
  """
  parentCompanyShareRatio: Float!
}

"""Ultimate Beneficial Owner type."""
enum UltimateBeneficialOwnerType {
  """Direct Individual Owner (Natural person) ."""
  DirectIndividual

  """Direct Company Owner (Legal person)."""
  DirectCompany

  """Indirect Individual Owner (Natural person)."""
  IndirectIndividual

  """Indirect Company Owner (Legal person)."""
  IndirectCompany
}

"""Upcoming transaction status information"""
type UpcomingTransactionStatusInfo implements TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!

  """The date when the transaction will be executed"""
  executionDate: DateTime!
}

input UpdateAccountHolderInput {
  accountHolderId: ID!
  vatNumber: String
  taxIdentificationNumber: String
}

union UpdateAccountHolderPayload = UpdateAccountHolderSuccessPayload | AccountHolderNotFoundRejection | ValidationRejection

type UpdateAccountHolderSuccessPayload {
  accountHolder: AccountHolder!
}

"""Inputs to update an account"""
input UpdateAccountInput {
  """Unique identifier of an account"""
  accountId: ID!

  """Name"""
  name: String

  """Language"""
  language: AccountLanguage
}

"""Inputs to update an account membership"""
input UpdateAccountMembershipInput {
  """Unique identifier of an account membership"""
  accountMembershipId: ID!

  """Email address"""
  email: String

  """Restricted to a user if necessary"""
  restrictedTo: UpdatedRestrictedToInput

  """
  `true` if this account membership can view account balances and transactions history
  """
  canViewAccount: Boolean

  """`true` if this account membership can add or canceled beneficiaries"""
  canManageBeneficiaries: Boolean

  """`true` if this account membership can initiate payments"""
  canInitiatePayments: Boolean

  """
  `true` if this account membership can invite, update, suspend or resume memberships
  """
  canManageAccountMembership: Boolean

  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean

  """Periodic Spending limit"""
  spendingLimit: SpendingLimitInput

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Residency address of the member to be added"""
  residencyAddress: ResidencyAddressInput

  """Tax Identification Number of the user added"""
  taxIdentificationNumber: String
}

union UpdateAccountMembershipPayload = UpdateAccountMembershipSuccessPayload | AccountMembershipCannotBeUpdatedRejection | AccountMembershipNotFoundRejection | ForbiddenRejection | InvalidPhoneNumberRejection | PermissionCannotBeGrantedRejection | UserNotAllowedToManageAccountMembershipRejection | ValidationRejection

type UpdateAccountMembershipSuccessPayload {
  consent: Consent!
}

union UpdateAccountPayload = UpdateAccountSuccessPayload | AccountNotFoundRejection | BadAccountStatusRejection | ForbiddenRejection | InternalErrorRejection | ValidationRejection

type UpdateAccountSuccessPayload {
  account: Account!
}

"""Input to Update Card"""
input UpdateCardInput {
  """Unique identifier of the card to update"""
  cardId: ID!

  """Card expiration date  if `null` it does not have an expiration date"""
  cardContractExpiryDate: DateTime

  """`true` if this card allows cash withdrawals"""
  withdrawal: Boolean!

  """`true` if this card allows payments outside of the country"""
  international: Boolean!

  """
  `true` if this card allows transactions outside of the card's main currency
  """
  nonMainCurrencyTransactions: Boolean!

  """`true` if this card allows transactions at eCommerce sites"""
  eCommerce: Boolean!

  """Periodic Spending limit"""
  spendingLimit: SpendingLimitInput

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Card name"""
  name: String
}

union UpdateCardPayload = UpdateCardSuccessPayload | AccountNotFoundRejection | CardNotFoundRejection | AccountMembershipNotAllowedRejection | ValidationRejection

type UpdateCardSuccessPayload {
  consent: Consent!
}

input UpdateCompanyOnboardingInput {
  """
  Account name of the company account holder. Length must be from 0 to 100 characters
  """
  accountName: String

  """
  Country of the account that will be created at the end of the onboarding process
  """
  accountCountry: AccountCountry

  """Name of the company. Length must be from 0 to 255 characters"""
  name: String

  """
  Registration number of the company (SIRET, ...). Length must be from 0 to 50 characters
  """
  registrationNumber: String

  """Type of the company (Association ...)"""
  companyType: CompanyType

  """Business activity"""
  businessActivity: BusinessActivity

  """
  Business activity description. Length must be from 0 to 1024 characters
  """
  businessActivityDescription: String

  """Estimated monthly payment volume (euro)"""
  monthlyPaymentVolume: MonthlyPaymentVolume

  """
  The ultimate beneficial owner is defined as the natural person (s) who own or control, directly and/or indirectly, the reporting company.
  
  The ultimate beneficial owner is :
  - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
  - either the natural person (s) who exercise, by other means, a power of control of the company;
  """
  individualUltimateBeneficialOwners: [IndividualUltimateBeneficialOwnerInput!]

  """Residency address of the head office (Must be in a European country)"""
  residencyAddress: ResidencyAddressInput

  """
  Email of the legal representative. Length must be from 0 to 255 characters
  """
  email: String

  """Language of the onboarding process. Must be compliant with RFC 5646"""
  language: String

  """Is company registered at RCS in its country"""
  isRegistered: Boolean

  """Id of onboarding to be updated. Must be a valid UUID v4. Required"""
  onboardingId: ID!

  """VAT number"""
  vatNumber: String

  """Tax Identification Number"""
  taxIdentificationNumber: String

  """Legal representative personal address"""
  legalRepresentativePersonalAddress: AddressInformationInput

  """Type of representation (legal representative or power of attorney)"""
  typeOfRepresentation: TypeOfRepresentation
}

"""Possible results for mutation `updateCompanyOnboarding`"""
union UpdateCompanyOnboardingPayload = ForbiddenRejection | InternalErrorRejection | UpdateCompanyOnboardingSuccessPayload | ValidationRejection

"""Result when updateCompanyOnboarding is a success"""
type UpdateCompanyOnboardingSuccessPayload {
  onboarding: OnboardingInfo!
}

"""Input when the account membership is restricted to a verified user"""
input UpdatedRestrictedToInput {
  """Account member first name"""
  firstName: String

  """Account member last name"""
  lastName: String

  """Account member birth date"""
  birthDate: Date

  """Account member phone number"""
  phoneNumber: String
}

input UpdateIndividualOnboardingInput {
  """
  Account name of the individual account holder. Length must be from 0 to 255 characters
  """
  accountName: String

  """
  Country of the account that will be created at the end of the onboarding process
  """
  accountCountry: AccountCountry

  """Employment status of the individual account holder"""
  employmentStatus: EmploymentStatus

  """Monthly income of the individual account holder"""
  monthlyIncome: MonthlyIncome

  """
  Residency address of the individual account holder (must be in a European country)
  """
  residencyAddress: ResidencyAddressInput

  """Email. Length must be from 0 to 255 characters"""
  email: String

  """Language of the onboarding process. Must be compliant with RFC 5646"""
  language: String

  """Id of onboarding to be updated. Must be a valid UUID v4. Required"""
  onboardingId: ID!

  """Tax Identification Number"""
  taxIdentificationNumber: String
}

"""Possible result types for `updateIndividualOnboarding`"""
union UpdateIndividualOnboardingPayload = ForbiddenRejection | InternalErrorRejection | UpdateIndividualOnboardingSuccessPayload | ValidationRejection

"""Type of result when updateIndividualOnboarding is a success"""
type UpdateIndividualOnboardingSuccessPayload {
  onboarding: OnboardingInfo!
}

"""Inputs to update a received sepa direct debit mandate B2b."""
input UpdateReceivedSepaDirectDebitB2bMandateInput {
  """The unique mandate id"""
  receivedDirectDebitMandateId: ID!

  """The unique identifier of the received direct debit mandate"""
  mandateReference: String

  """The Sepa Creditor Identifier of the creditor"""
  creditorIdentifier: String

  """The name of the creditor"""
  creditorName: String

  """The Swan Iban of the debtor"""
  iban: String

  """
  Label that will be displayed along with this received direct debit mandate in the web banking
  """
  name: String

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

"""
Union type returned by the updateReceivedSepaDirectDebitB2bMandate mutation
"""
union UpdateReceivedSepaDirectDebitB2bMandatePayload = UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload | ReceivedDirectDebitMandateNotFoundRejection | ForbiddenRejection | ReceivedDirectDebitMandateAlreadyExistRejection | ReceivedDirectDebitMandateNotB2bRejection | AccountNotFoundRejection

"""
Return type in case of a successful response of the updateReceivedSepaDirectDebitB2bMandate mutation
"""
type UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload {
  """The received direct debit mandate updated"""
  receivedDirectDebitMandate: ReceivedDirectDebitMandate!
}

input UpdateSupportingDocumentInput {
  supportingDocumentId: ID!
  supportingDocumentType: SupportingDocumentType
  supportingDocumentPurpose: SupportingDocumentPurposeEnum
}

union UpdateSupportingDocumentPayload = UpdateSupportingDocumentSuccessPayload | ForbiddenRejection | InternalErrorRejection | SupportingDocumentCollectionNotFoundRejection | SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection | SupportingDocumentNotFoundRejection | SupportingDocumentStatusDoesNotAllowUpdateRejection | ValidationRejection

type UpdateSupportingDocumentSuccessPayload {
  supportingDocument: SupportingDocument!
}

input UpdateUserConsentSettingsInput {
  """Swan user id"""
  userId: ID!

  """Preferred consent notification channel, Sms or App"""
  preferredNotificationChannel: PreferredNotificationChannel!
}

union UpdateUserConsentSettingsPayload = UpdateUserConsentSettingsSuccessPayload | UpdateUserConsentSettingsTokenRejection

type UpdateUserConsentSettingsSuccessPayload {
  userConsentSettings: UserConsentSettings!
}

type UpdateUserConsentSettingsTokenRejection implements Rejection {
  message: String!
}

scalar Upload

"""
URL that follows the WHATWG URL Standard.

[Examples of parsed URLs](https://url.spec.whatwg.org/#example-url-parsing) may be found in the Standard itself.
"""
scalar URL

"""The User is the unique user, natural person, of the Swan app."""
type User {
  """unique identifier of the user"""
  id: ID!

  """The list of account memberships"""
  accountMemberships(first: Int! = 50, before: String, after: String, filters: AccountMembershipsFilterInput): AccountMembershipConnection!

  """
  mobile phone number with the international format (Example: +33689788967)
  """
  mobilePhoneNumber: PhoneNumber

  """first name"""
  firstName: String

  """last name"""
  lastName: String

  """list of first names"""
  allFirstNames: [String!]

  """birth date"""
  birthDate: Date

  """nationality"""
  nationalityCCA3: CCA3

  """`true` if Swan has verified the user's identity"""
  idVerified: Boolean!

  """the methods used to authenticate this user"""
  authenticators: [Authenticator!]

  """
  Identification status
  
  Each attempt to go through our identity verification process will update this value.
  
  This field is only available for the current user.
  """
  identificationStatus: IdentificationStatus

  """
  List of identification levels available for the user.
  
  Whenever TRUE, it means the identification was successful for the associated level.
  """
  identificationLevels: IdentificationLevels

  """
  Preferred notification channel
  
  When it is "null" it means that the preferences have not been updated. Default SMS in use
  """
  preferredNotificationChannel: PreferredNotificationChannel

  """Creation date of the user"""
  createdAt: DateTime!

  """Last update date of the user"""
  updatedAt: DateTime!

  """
  Date on which the user joined the project. Joining the project is done after the first accepted OAuth login.
  """
  joinedAt: DateTime!
  identifications(
    """Maximum number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after an element"""
    after: String

    """When the list of identifications needs to be filtered"""
    filters: IdentificationFiltersInput

    """
    When the list of identifications needs to be ordered, by default the list will be ordered by the latest identification (valid or not)
    """
    orderBy: IdentificationsOrderByInput
  ): IdentificationConnection
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type UserConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """UserEdge list"""
  edges: [UserEdge!]!
}

type UserConsentSettings {
  """Preferred notification channel"""
  preferredNotificationChannel: PreferredNotificationChannel!

  """User identifier"""
  userId: String!

  """Project identifier"""
  projectId: String!
}

"""Implements the Relay Edge interface"""
type UserEdge implements Edge {
  """
  Opaque identifier pointing to this consent node in the pagination mechanism
  """
  cursor: String!

  """The consent"""
  node: User!
}

input UserFilterInput {
  birthDate: Date
  firstName: String
  identificationLevel: IdentificationLevelInput
  lastName: String
  mobilePhoneNumber: String
  nationalityCCA3: CCA3
  preferredNotificationChannel: PreferredNotificationChannel

  """
  Searches first name, last name, phone number and id
  Min length : 3 characters
  """
  search: String
}

type UserNotAllowedToDisableItsOwnAccountMembershipRejection implements Rejection {
  accountMembershipId: String!
  message: String!
}

"""
Rejection returned if a identity does not have enough permission to manage account membership
"""
type UserNotAllowedToManageAccountMembershipRejection implements Rejection {
  message: String!
}

type UserNotAllowedToSuspendItsOwnAccountMembershipRejection implements Rejection {
  accountMembershipId: String!
  message: String!
}

"""Rejection returned when the User is not the Card Holder"""
type UserNotCardHolderRejection implements Rejection {
  message: String!
}

"""Field we can use when ordering that can be applied when listing users"""
enum UserOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing users"""
input UserOrderByInput {
  field: UserOrderByFieldInput
  direction: OrderByDirection
}

"""A detail of a validation error : what field is errored and why"""
type ValidationError {
  """
  Onboarding property that is not matching requirements to allow a finalization
  """
  field: String!

  """Constraints that are not matched on the Onboarding property"""
  errors: [FieldValidationError!]
}

type ValidationFieldError {
  code: ValidationFieldErrorCode!
  message: String!
  path: [String!]!
}

enum ValidationFieldErrorCode {
  InvalidString
  InvalidType
  TooLong
  TooShort
  UnrecognizedKeys
}

"""Rejection returned if an input contains invalid data"""
type ValidationRejection implements Rejection {
  fields: [ValidationFieldError!]!
  message: String!
}

"""Information extracted from a valid IBAN"""
type ValidIban {
  """Iban from input"""
  iban: IBAN!

  """Account Number extracted from the IBAN"""
  accountNumber: String!

  """Checksum extracted from the IBAN"""
  checksum: String!

  """Bank that owns this IBAN"""
  bank: Bank!

  """Reachability of this IBAN over different payment methods"""
  reachability: Reachability!
}

"""
Describes a valid identification level for the process associated to this identification, and identification documents can be accessed
"""
type ValidIdentificationLevelStatusInfo {
  """Always set to `Valid`"""
  status: SwanIdentificationStatus!
}

"""Verification Flow."""
enum VerificationFlow {
  """
  When you ask the account holder to start the verification process at the beginning of the relationship to get an unlimited account.
  """
  Upfront

  """
  When you ask the account holder the minimum required to comply the law at the beginning of the relationship.
  """
  Progressive
}

"""Verification status of an account holder"""
enum VerificationStatus {
  """
  When the account holder has not started to answer the verification process.
  """
  NotStarted

  """
  When Swan is waiting for information about the account holder to continue the verification process.
  """
  WaitingForInformation

  """When the verification process is pending."""
  Pending

  """When the account holder is verified."""
  Verified

  """When the account holder is refused."""
  Refused
}

"""Enabled Information"""
type VerifiedStatusInfo implements AccountVerificationStatusInfo {
  """Date at which the verification was verified"""
  verifiedAt: DateTime!

  """Account verification status (Verified)"""
  status: AccountVerificationStatus!
}

input ViewCardNumbersInput {
  """Unique identifier of a card"""
  cardId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ViewCardNumbersPayload = ViewCardNumbersSuccessPayload | UserNotCardHolderRejection | CardNotFoundRejection | ValidationRejection

type ViewCardNumbersSuccessPayload {
  """The consent required to view card numbers"""
  consent: Consent!
}

input ViewPhysicalCardNumbersInput {
  """Unique identifier of a card"""
  cardId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ViewPhysicalCardNumbersPayload = ViewPhysicalCardNumbersSuccessPayload | UserNotCardHolderRejection | CardNotFoundRejection | ValidationRejection

type ViewPhysicalCardNumbersSuccessPayload {
  """The consent required to view card numbers"""
  consent: Consent!
}

input ViewPhysicalCardPinInput {
  """Unique identifier of a card"""
  cardId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ViewPhysicalCardPinPayload = ViewPhysicalCardPinSuccessPayload | CardNotFoundRejection | PhysicalCardNotFoundRejection | PINNotReadyRejection | UserNotCardHolderRejection | ValidationRejection

type ViewPhysicalCardPinSuccessPayload {
  """The consent required to view card numbers"""
  consent: Consent!
}

"""
Virtual IBAN can be used by the account holder to receive SCT (Sepa Credit Transfer) or to be debited by SDD (Sepa Direct Debit).
"""
type VirtualIBANEntry {
  """Unique identifier of a Virtual IBAN entry"""
  id: ID!

  """International Bank Account Number"""
  IBAN: IBAN!

  """Bank Identifier Code"""
  BIC: BIC!

  """Label (could be used to identify)"""
  label: String

  """Status of the Iban"""
  status: IBANStatus!

  """`true` if the Virtual IBAN refuses all Sepa Direct Debit received"""
  blockSDD: Boolean!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type VirtualIBANEntryConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """VirtualIBANEntryEdge list"""
  edges: [VirtualIBANEntryEdge!]!
}

"""Implements the Relay Edge interface"""
type VirtualIBANEntryEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The virtual iban entry"""
  node: VirtualIBANEntry!
}

"""Wallet Provider (ApplePay, GooglePay ...)"""
type WalletProvider {
  """name of the Wallet Provider (Apple / Google / Amazon or Unknown)"""
  name: String!

  """id of the Wallet Provider"""
  id: String!
}

"""Wallet Provider"""
enum WalletProviderType {
  ApplePay
  GooglePay
}

scalar WalletToken

type WebBankingSettings {
  canViewAccountDetails: Boolean
  canViewAccountStatement: Boolean
  canManageVirtualIbans: Boolean
  canInitiatePaymentsToNewBeneficiaries: Boolean
  canViewPaymentList: Boolean
  canOrderVirtualCards: Boolean
  canOrderPhysicalCards: Boolean
  canViewMembers: Boolean
  canAddNewMembers: Boolean
}

"""Rejection returned when a parameter has a wrong value"""
type WrongValueProvidedRejection implements Rejection {
  message: String!
  valueProvided: String!
  parameterName: String!
}