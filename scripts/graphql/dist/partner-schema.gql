input AcceptConsentInput {
  consentId: String!
}

"""Rejection returned when the Consent purpose is not allowed"""
type AcceptConsentNotAllowedForConsentPurposeRejection implements Rejection {
  message: String!
}

union AcceptConsentPayload = AcceptConsentSuccessPayload | ConsentNotFoundRejection | OperationNotAllowedRejection | UserNotFoundRejection | AcceptConsentNotAllowedForConsentPurposeRejection | NotAllowedUserStatusRejection | NotReachableConsentStatusRejection

type AcceptConsentSuccessPayload {
  consent: Consent
}

"""
Whether you call it a wallet, monetary account, payment account or bank account, the notion of account is fundamental at Swan. All payment flows necessarily go through an account.
"""
type Account {
  """Unique identifier of an account"""
  id: ID!

  """Unique account number"""
  number: AccountNumber!

  """Account name"""
  name: String!

  """Account holder"""
  holder: AccountHolder!

  """Cash account type"""
  cashAccountType: CashAccountType!

  """Country of the account"""
  country: AccountCountry!

  """Payment level"""
  paymentLevel: PaymentLevel!

  """
  Bank Identifier Code
  Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited`
  """
  BIC: BIC!

  """
  International Bank Account Number
  Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited`
  """
  IBAN: IBAN

  """Currency"""
  currency: Currency!

  """`true` if the main IBAN refuses all Sepa Direct Debit received"""
  blockSDD: Boolean

  """Status of the account"""
  statusInfo: AccountStatusInfo!

  """Partnership status"""
  partnershipStatusInfo: PartnershipStatusInfo

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  List of Virtual IBAN
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  virtualIbanEntries(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String
  ): VirtualIBANEntryConnection!

  """
  List of account membership for this account
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  memberships(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: MembershipsFilterInput

    """an order you can apply to your list of connections"""
    orderBy: AccountMembershipOrderByInput
  ): AccountMembershipConnection!

  """`true`if a consent is required to fetch new transactions"""
  requiredConsentToFetchNewTransactions: Boolean!

  """Language used for account statements"""
  language: AccountLanguage!

  """Legal representative account membership"""
  legalRepresentativeMembership: AccountMembership!

  """
  Type of the account : EMoney if account holder has not finished the KYC requirements, PaymentService otherwise
  """
  paymentAccountType: PaymentAccountType!

  """Date of the account going from eMoney to PaymentService"""
  upgradedAt: DateTime

  """Link to the account's bank details"""
  bankDetails: String

  """
  Legal Documents linked to the account
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  legalDocuments(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: LegalDocumentsFilterInput
  ): LegalDocumentConnection

  """A list of balances regarding an account."""
  balances: AccountBalances

  """
  List of statements of an account.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  *For a Project access token, this is all the transactions of the project (only available with project access token)*
  """
  statements(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: StatementFiltersInput
  ): StatementConnection

  """
  A list of transactions of an account.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  transactions(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: TransactionsOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """
  A list of invoices of an account.
  The list is ordered by creation date (from newest to oldest)
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  invoices(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 10

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String
  ): InvoiceConnection

  """
  A list of receive Direct Mandates of an account.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  receivedDirectDebitMandates(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value updatedAt desc)
    """
    orderBy: AccountReceivedDirectDebitOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: AccountReceivedDirectDebitMandateFiltersInput
  ): ReceivedDirectDebitMandateConnection

  """List of merchant profiles created on the account"""
  merchantProfiles(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be ordered"""
    orderBy: MerchantProfileOrderByInput

    """When the list of elements needs to be filtered"""
    filters: MerchantProfileFiltersInput
  ): MerchantProfileConnection

  """
  A list of standing orders regarding an account.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  standingOrders(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """an offset to start at"""
    offset: Int

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: AccountStandingOrderOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: AccountStandingOrderFiltersInput
  ): StandingOrderConnection!

  """
  List of funding source created on the account
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  fundingSources(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """an offset to start at"""
    offset: Int

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: FundingSourceOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: FundingSourceFiltersInput
  ): FundingSourceConnection

  """
  List of trusted beneficiaries of an account.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  trustedBeneficiaries(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    offset: Int

    """
    an order you can apply to your list of connections (default value label asc)
    """
    orderBy: TrustedBeneficiaryOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: TrustedBeneficiaryFiltersInput
  ): TrustedBeneficiaryConnection!
}

"""
Account and Requested Card, it the return type of accountByCardToken & accountByCardId;
"""
type AccountAndCard {
  """Account"""
  account: Account!

  """Requested Card"""
  cardRequested: Card!
}

"""A list of balances regarding an account."""
type AccountBalances {
  """
  Balance composed of booked, pending transactions and rolling reserve used known at the time of calculation.
  """
  available: Amount!

  """Balance just composed of pending transactions."""
  pending: Amount!

  """Balance just composed of booked transactions."""
  booked: Amount!

  """Balance just composed of rolling reserve used in booked transactions."""
  reserved: Amount!
}

"""Account Closed status information"""
type AccountClosedStatus implements AccountStatusInfo {
  """Account status (always Closed for type AccountClosedStatus)"""
  status: AccountStatus!

  """Reason why the account is suspended"""
  reason: String! @deprecated(reason: "Use `reasonInfo` instead.")

  """Reason why the account is currently closed"""
  reasonInfo: CloseAccountStatusReason!
  closedAt: DateTime!
  closingAt: DateTime!
}

"""Account Closing status information"""
type AccountClosingStatus implements AccountStatusInfo {
  """Account status (always Closing for type AccountClosingStatus)"""
  status: AccountStatus!

  """Reason why the account is suspended"""
  reason: String! @deprecated(reason: "Use `reasonInfo` instead.")

  """Reason why the account is currently in closing"""
  reasonInfo: CloseAccountStatusReason!
  closingAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type AccountConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """AccountEdge list"""
  edges: [AccountEdge!]!
}

"""
Refers to the country of the account. It will determine the country code of the local IBAN of the account.

Available Account Country: CCA3
"""
enum AccountCountry {
  """French account with a French IBAN, starting with FR."""
  FRA

  """German account with a German IBAN, starting with DE."""
  DEU

  """Spanish account with a Spanish IBAN, starting with ES."""
  ESP

  """Dutch account with a Dutch IBAN, starting with DU."""
  NLD

  """
  Italian account with an Italian IBAN, starting with IT (Coming Soon, not supported yet).
  """
  ITA
}

"""Implements the Relay Edge interface"""
type AccountEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The account"""
  node: Account!
}

"""Filters that can be applied when listing accounts"""
input AccountFilterInput {
  """Filter by status"""
  status: [AccountStatus!]

  """Filter by payment level"""
  paymentLevels: [PaymentLevel!]

  """
  Search string to look for.
  
  Search will be performed in following fields:
   - Account holder's first name
   - Account holder's last name
   - Account holder's email
   - Account holder's ID
   - Name
   - Number
   - ID
  """
  search: String
}

enum AccountFundingLimitsReachedReason {
  """Account Holder instant funding limit exceeded"""
  InstantFundingLimitExceededRejection

  """Account Holder funding limit exceeded"""
  FundingLimitExceededRejection

  """Project instant funding limit exceeded"""
  ProjectInstantFundingLimitExceededRejection

  """Project funding limit exceeded"""
  ProjectFundingLimitExceededRejection

  """Global instant funding limit exceeded"""
  GlobalInstantFundingLimitExceededRejection

  """Global funding limit exceeded"""
  GlobalFundingLimitExceededRejection

  """Insufficient funds rejection"""
  InsufficientFundsRejection
}

"""
The account holder is the person who owns the money stored in the account. The account holder can be one of your customers, whether it is a natural person or a legal person, or quite simply you.
"""
type AccountHolder {
  """Unique identifier of the account holder."""
  id: ID!

  """
  Verification status.
  *Banking regulations require financial institutions such as Swan to know and verify their customers in order to comply with their anti-money laundering and terrorist financing obligations. In banking jargon, we talk about KYC (Know Your Customers) procedure*
  """
  verificationStatus: VerificationStatus!

  """Account holder verification Status information."""
  verificationStatusInfo: AccountHolderVerificationStatusInfo!

  """Account holder type information."""
  info: AccountHolderInfo!

  """Account holder status information."""
  statusInfo: AccountHolderStatusInfo

  """Residency address."""
  residencyAddress: AddressInfo!

  """Created date."""
  createdDate: DateTime!

  """Updated date."""
  updatedDate: DateTime!

  """
  List of accounts owned by the account holder.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  accounts(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """an order you can apply to your list of connections"""
    orderBy: AccountOrderByInput
  ): AccountConnection!

  """
  List of supporting document collection for an account holder
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  supportingDocumentCollections(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """When the list of supporting document collections needs to be filtered"""
    filters: SupportingDocumentCollectionFilterInput
  ): SupportingDocumentCollectionConnection!

  """
  List of funding limit settings change request for an account holder
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  fundingLimitSettingsChangeRequests(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String
  ): FundingLimitSettingsChangeRequestConnection!

  """Account holder onboarding"""
  onboarding: Onboarding

  """
  List of external account owned by the account holder
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  externalAccounts(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String
  ): ExternalAccountConnection!

  """
  A list of Payment Mandates for an account holder.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  paymentMandates(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value updatedAt desc)
    """
    orderBy: PaymentMandateOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: PaymentMandateFiltersInput
  ): PaymentMandateConnection

  """Funding limit settings"""
  fundingLimitSettings: FundingLimitSettings
}

"""Account Holder Canceled Status Information"""
type AccountHolderCanceledStatusInfo implements AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!

  """Reason why the account holder is suspended."""
  reason: String!
}

type AccountHolderCompanyInfo implements AccountHolderInfo {
  """Account holder type (always Company for type AccountHolderCompanyInfo)"""
  type: AccountHolderType!

  """Name of the company."""
  name: String!

  """
  Registration number of the company (for example, Système d'Identification du Répertoire des ENtreprises [SIREN] in France, ...).
  - Length must be from 0 to 50 characters.
  """
  registrationNumber: String

  """Registration date of the company."""
  companyRegistrationDate: Date

  """Legal form of the company (SAS, SCI, SASU, ...)."""
  companyType: CompanyType

  """Business activity."""
  businessActivity: BusinessActivity!

  """
  Business activity description.
  This must be 1024 characters long maximum.
  """
  businessActivityDescription: String!

  """Estimated monthly payment volume (euro)."""
  monthlyPaymentVolume: MonthlyPaymentVolume!

  """
  The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
  
  The ultimate beneficiary is :
  - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
  - either the natural person (s) who exercise, by other means, a power of control of the company;
  """
  individualUltimateBeneficialOwners: [IndividualUltimateBeneficialOwner!]!

  """
  Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT
  """
  vatNumber: String

  """Tax Identification Number"""
  taxIdentificationNumber: String

  """Legal representative personal address"""
  legalRepresentativePersonalAddress: AddressInformation
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)).
"""
type AccountHolderConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """AccountHolderEdge list"""
  edges: [AccountHolderEdge!]!
}

"""Implements the Relay Edge interface."""
type AccountHolderEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The account holder"""
  node: AccountHolder!
}

"""Account Holder Enabled Status Information"""
type AccountHolderEnabledStatusInfo implements AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!
}

"""Filters that can be applied when listing account holders"""
input AccountHolderFilterInput {
  """Filter by birth date"""
  birthDate: String

  """
  Filter by registration number of the company
  (for example, Système d'Identification du Répertoire des ENtreprises [SIREN] in France, ...).
  
  - Length must be from 0 to 50 characters.
  """
  registrationNumber: String

  """Filter by status"""
  status: [AccountHolderStatus!]

  """Filter by type"""
  types: [AccountHolderType!]

  """Filter by verification status"""
  verificationStatus: [VerificationStatus!]

  """
  Search string to look for
  
  Search will be performed in following fields:
   - First name
   - Last name
   - Company name
   - ID
  """
  search: String

  """
  Search by first name
  
  @deprecated(reason: "use `search` instead")
  """
  firstName: String

  """
  Search by last name
  
  @deprecated(reason: "use `search` instead")
  """
  lastName: String
}

"""Individual account holder."""
type AccountHolderIndividualInfo implements AccountHolderInfo {
  """
  Account holder type (always Individual for type AccountHolderIndividualInfo).
  """
  type: AccountHolderType!

  """Account Holder's first name and last name."""
  name: String!

  """Employment status of the account holder (regulatory questions)."""
  employmentStatus: EmploymentStatus!

  """Monthly income of the account holder (regulatory questions)."""
  monthlyIncome: MonthlyIncome!

  """User of the individual account holder."""
  user: User!

  """Tax Identification Number"""
  taxIdentificationNumber: String
}

"""Account holder types."""
interface AccountHolderInfo {
  """Account holder type"""
  type: AccountHolderType!

  """Account holder name"""
  name: String!
}

"""Rejection returned when the Account Holder was not found"""
type AccountHolderNotFoundRejection implements Rejection {
  message: String!
}

type AccountHolderNotStartedVerificationStatusInfo implements AccountHolderVerificationStatusInfo {
  """Verification Status of the account holder."""
  status: VerificationStatus!
}

"""
Field we can use when ordering that can be applied when listing account holders
"""
enum AccountHolderOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing account holders"""
input AccountHolderOrderByInput {
  field: AccountHolderOrderByFieldInput
  direction: OrderByDirection
}

type AccountHolderPendingVerificationStatusInfo implements AccountHolderVerificationStatusInfo {
  """Verification Status of the account holder."""
  status: VerificationStatus!

  """ISO Date string at which the account holder status was set to Pending"""
  pendingAt: DateTime!
}

type AccountHolderRefusedVerificationStatusInfo implements AccountHolderVerificationStatusInfo {
  """Verification Status of the account holder."""
  status: VerificationStatus!

  """ISO Date string at which the account holder status was set to Refused"""
  refusedAt: DateTime!

  """Reason for which the account holder was refused"""
  reason: String!
}

"""Account holder status."""
enum AccountHolderStatus {
  """When the account holder is enabled."""
  Enabled

  """When the account holder is suspended."""
  Suspended

  """When the account holder is canceled."""
  Canceled
}

"""Account Holder Status Information"""
interface AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!
}

"""Account Holder Suspended Status Information"""
type AccountHolderSuspendedStatusInfo implements AccountHolderStatusInfo {
  """Status of the account holder."""
  status: AccountHolderStatus!

  """Reason why the account holder is suspended."""
  reason: String!
}

"""Account holder type"""
enum AccountHolderType {
  """Individual (Natural person)"""
  Individual

  """Company (Legal person)"""
  Company
}

"""
Rejection returned if the account holder type is individual.
An individual account holder can't create a b2b received direct debit mandate.
"""
type AccountHolderTypeIndividualRejection implements Rejection {
  message: String!
}

"""Account Holder Verification Status Information"""
interface AccountHolderVerificationStatusInfo {
  """Verification Status of the account holder."""
  status: VerificationStatus!
}

type AccountHolderVerifiedVerificationStatusInfo implements AccountHolderVerificationStatusInfo {
  """Verification Status of the account holder."""
  status: VerificationStatus!

  """ISO Date string at which the account holder status was set to Verified"""
  verifiedAt: DateTime!
}

type AccountHolderWaitingForInformationVerificationStatusInfo implements AccountHolderVerificationStatusInfo {
  """Verification Status of the account holder."""
  status: VerificationStatus!
  verificationRequirements: [VerificationRequirement!]!

  """@deprecated(reason: "Use `waitingForInformationAt` instead")"""
  WaitingForInformationAt: DateTime! @deprecated

  """
  ISO Date string at which the account holder status was set to WaitingForInformation
  """
  waitingForInformationAt: DateTime!
}

"""Language: ISO 639-1 language code"""
enum AccountLanguage {
  de
  en
  fr
  it
  nl
  es
  pt
  fi
}

"""
An account membership represents the rights of a user for a given account.

*Each account is administered by an account membership having the capacity of legal representative. He has the possibility of delegating rights on this account to other users.*
"""
type AccountMembership {
  """Unique identifier of an account membership"""
  id: ID!

  """email"""
  email: String!

  """user of this account membership"""
  user: User

  """
  `true` if this account membership having the capacity of the legal representative of the account holder.
  """
  legalRepresentative: Boolean!

  """
  `true` if this account membership can view account balances and transactions history
  """
  canViewAccount: Boolean!

  """`true` if this account membership can add or canceled beneficiaries"""
  canManageBeneficiaries: Boolean!

  """`true` if this account membership can initiate credit transfers"""
  canInitiatePayments: Boolean!

  """
  `true` if this account membership can invite, update, suspend or resume memberships
  """
  canManageAccountMembership: Boolean!

  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean!

  """status of the account membership"""
  statusInfo: AccountMembershipStatusInfo!

  """Unique identifier of the account of the account membership"""
  accountId: ID!

  """account of the account membership"""
  account: Account

  """Periodic Spending limit list"""
  spendingLimits: [SpendingLimit!]

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  version of the account membership started from '1' and incremented at every updates
  """
  version: String!

  """Residency address of the member"""
  residencyAddress: AddressInfo

  """Tax Identification Number of the member"""
  taxIdentificationNumber: String

  """List of accepted identification level"""
  acceptedIdentificationLevels: [IdentificationLevel]!

  """Recommended identification level"""
  recommendedIdentificationLevel: IdentificationLevel!

  """
  Indicate if the identity bound to the account membership has required identification level
  """
  hasRequiredIdentificationLevel: Boolean

  """Disabled date"""
  disabledAt: DateTime

  """Language of the account membership"""
  language: AccountLanguage

  """
  Refers to the country of the account. It will determine the country code of the local IBAN of the account.
  
  Available Account Country: CCA3
  """
  accountCountry: AccountCountry!

  """account membership's cards"""
  cards(
    first: Int! = 50
    before: String
    after: String

    """When the list of elements needs to be ordered"""
    orderBy: CardOrderByInput

    """When the list of elements needs to be filtered"""
    filters: CardFiltersInput
  ): CardConnection!

  """Periodic Spending"""
  spending: Spending
}

"""when a user is bound with the error to the account membership"""
type AccountMembershipBindingUserErrorStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always BindingUserError for type AccountMembershipBindingUserErrorStatusInfo)
  """
  status: AccountMembershipStatus!

  """
  `true` if the first name of the bound user doesn't match with the invitation
  """
  firstNameMatchError: Boolean!

  """
  `true` if the email of the bound user doesn't match with the invitation
  """
  emailVerifiedMatchError: Boolean!

  """`true` if Swan hasn't verified the user's identity"""
  idVerifiedMatchError: Boolean!

  """
  `true` if the last name of the bound user doesn't match with the invitation
  """
  lastNameMatchError: Boolean!

  """
  `true` if the phone number of the bound user doesn't match with the invitation
  """
  phoneNumberMatchError: Boolean!

  """
  `true` if the birth date of the bound user doesn't match with the invitation
  """
  birthDateMatchError: Boolean!

  """restricted to a user"""
  restrictedTo: RestrictedTo!
}

type AccountMembershipCannotBeDisabledRejection implements Rejection {
  accountMembershipId: String!
  message: String!
}

type AccountMembershipCannotBeUpdatedRejection implements Rejection {
  id: String!
  message: String!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type AccountMembershipConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """AccountMembershipEdge list"""
  edges: [AccountMembershipEdge!]!
}

"""when the user has to consent to invite a new account membership"""
type AccountMembershipConsentPendingStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always ConsentPending for type AccountMembershipConsentPendingStatusInfo)
  """
  status: AccountMembershipStatus!

  """The consent required to invite this account membership"""
  consent: Consent!

  """restricted to a user"""
  restrictedTo: RestrictedTo!
}

"""when the account membership is disabled"""
type AccountMembershipDisabledStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always Disabled for type AccountMembershipDisabledStatusInfo)
  """
  status: AccountMembershipStatus!

  """reason why the account membership is disabled"""
  reason: String!
}

"""Implements the Relay Edge interface"""
type AccountMembershipEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The account membership"""
  node: AccountMembership!
}

"""when the account membership is enabled"""
type AccountMembershipEnabledStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always Enabled for type AccountMembershipEnabledStatusInfo)
  """
  status: AccountMembershipStatus!
}

"""
when a new account membership is invited and there is no user bound yet
"""
type AccountMembershipInvitationSentStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always InvitationSent for type AccountMembershipInvitationSentStatusInfo)
  """
  status: AccountMembershipStatus!

  """restricted to a user"""
  restrictedTo: RestrictedTo!
}

"""
Rejection returned when the Account Membership is not allowed to use an operation.
"""
type AccountMembershipNotAllowedRejection implements Rejection {
  message: String!
}

type AccountMembershipNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Rejection returned if invitation has not been sent to user yet"""
type AccountMembershipNotReadyToBeBoundRejection implements Rejection {
  id: String!
  message: String!
}

type AccountMembershipNotReadyToBeUpdatedRejection {
  message: String!
}

"""
Field we can use when ordering that can be applied when listing account memberships
"""
enum AccountMembershipOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing account memberships"""
input AccountMembershipOrderByInput {
  field: AccountMembershipOrderByFieldInput
  direction: OrderByDirection
}

"""Filters that can be applied when listing account memberships"""
input AccountMembershipsFilterInput {
  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean

  """Can the user initiate payments on this account"""
  canInitiatePayments: Boolean

  """Can the user manage account membership"""
  canManageAccountMembership: Boolean

  """Can the user manage beneficiaries"""
  canManageBeneficiaries: Boolean

  """Can the user view account"""
  canViewAccount: Boolean

  """Account memberships status/statuses we're looking for"""
  status: [AccountMembershipStatus!]

  """
  Search by email
  
  @deprecated(reason: "use `search` instead")
  """
  email: String

  """
  Search by first name
  
  @deprecated(reason: "use `search` instead")
  """
  firstName: String

  """
  Search by last name
  
  @deprecated(reason: "use `search` instead")
  """
  lastName: String

  """
  Search string to look for
  
  Search will be performed in following fields:
   - First name
   - Last name
   - Email
   - ID
  """
  search: String

  """Filter by account"""
  accountId: String
}

"""AccountMembership enabled"""
enum AccountMembershipStatus {
  """when the consent to invite the account membership is pending"""
  ConsentPending

  """when the account membership is invited"""
  InvitationSent

  """when the user bound with errors to the account membership"""
  BindingUserError

  """when the account membership is enabled"""
  Enabled

  """when the account membership is suspended"""
  Suspended

  """when the account membership is disabled"""
  Disabled
}

"""here are the different account membership status:"""
interface AccountMembershipStatusInfo {
  """AccountMembership status"""
  status: AccountMembershipStatus!
}

"""when the account membership is suspended"""
type AccountMembershipSuspendedStatusInfo implements AccountMembershipStatusInfo {
  """
  AccountMembership status (always Suspended for type AccountMembershipSuspendedStatusInfo)
  """
  status: AccountMembershipStatus!

  """reason why the account membership is suspended"""
  reason: String!
}

"""Thrown when an related account is not eligible to the feature"""
type AccountNotEligibleRejection implements Rejection {
  message: String!
}

"""
Rejection returned if the account was not found or if the user does not have the rights to know that the card exists
"""
type AccountNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Swan account number"""
scalar AccountNumber

"""Account Opened status information"""
type AccountOpenedStatus implements AccountStatusInfo {
  """Account status (always Opened for type AccountOpenedStatus)"""
  status: AccountStatus!
}

"""Fields that can be used when ordering accounts"""
enum AccountOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing accounts"""
input AccountOrderByInput {
  field: AccountOrderByFieldInput
  direction: OrderByDirection
}

"""
Filter that can be passed to get the received direct debit mandate in a specific data range
"""
input AccountReceivedDirectDebitMandateFiltersInput {
  """To filter on status values"""
  status: [ReceivedDirectDebitMandateStatus!]

  """To filter on scheme values"""
  scheme: [ReceivedDirectDebitMandateScheme!]
}

"""
Field we can use when ordering that can be applied when listing receives direct debit mandate results
"""
enum AccountReceivedDirectDebitOrderByFieldInput {
  createdAt
  updatedAt
}

"""
Order that can be applied when listing receives direct debit mandate results
"""
input AccountReceivedDirectDebitOrderByInput {
  field: AccountReceivedDirectDebitOrderByFieldInput
  direction: OrderByDirection
}

"""Filters that can be applied when listing Standing orders"""
input AccountStandingOrderFiltersInput {
  status: [StandingOrderStatus!]
}

"""
Field we can use when ordering that can be applied when listing standing order results
"""
enum AccountStandingOrderOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing standing order results"""
input AccountStandingOrderOrderByInput {
  field: AccountStandingOrderOrderByFieldInput
  direction: OrderByDirection
}

enum AccountStatus {
  """When the account is opened"""
  Opened

  """When the account is suspended"""
  Suspended

  """When the account is currently closing"""
  Closing

  """When the account is closed"""
  Closed
}

interface AccountStatusInfo {
  """Account status"""
  status: AccountStatus!
}

"""Account Suspended status information"""
type AccountSuspendedStatus implements AccountStatusInfo {
  """Account status (always Suspended for type AccountSuspendedStatus)"""
  status: AccountStatus!

  """Reason why the account is suspended"""
  reason: String! @deprecated(reason: "Use `reasonInfo` instead.")

  """Reason why the account is currently suspend"""
  reasonInfo: SuspendAccountStatusReason!
}

"""Account Verification"""
interface AccountVerification {
  """Creation date of the account verification"""
  createdAt: DateTime!

  """Unique identifier of the Account Verification"""
  id: ID!

  """Account Verification Status Information"""
  statusInfo: AccountVerificationStatusInfo!

  """Last update date of the account verification"""
  updatedAt: DateTime!
}

"""
Rejection returned when the external account has already been rejected.

In such a case, contact Swan directly to resolve the situation for this specific account holder.
"""
type AccountVerificationAlreadyRejectedRejection implements Rejection {
  message: String!
}

"""Account Verification Status"""
enum AccountVerificationStatus {
  """
  We are waiting for the end user to send a credit transfer from his external iban to any Swan owned iban
  """
  PendingVerification

  """
  We could not automatically match the external iban based on last received transfer.
  Manuel review process is underway
  """
  PendingReview

  """Account has been verified"""
  Verified

  """Account verification has been rejected"""
  Rejected
}

"""Account Verification Status Information"""
interface AccountVerificationStatusInfo {
  """Account verification status"""
  status: AccountVerificationStatus!
}

"""
Rejection returned when the Account Verification is not in the expected status
"""
type AccountVerificationWrongStatusRejection implements Rejection {
  message: String!
}

type ActionNotAllowedRejection implements Rejection {
  message: String!
}

input ActivatePhysicalCardInput {
  """Unique identifier present on physical card"""
  identifier: String!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ActivatePhysicalCardPayload = ActivatePhysicalCardSuccessPayload | BadAccountStatusRejection | PhysicalCardNotFoundRejection | PhysicalCardWrongStatusRejection | CannotActivatePhysicalCardRejection | ForbiddenRejection | CardNotFoundRejection | UserNotCardHolderRejection | ValidationRejection

type ActivatePhysicalCardSuccessPayload {
  """The consent required to activate this physical card"""
  consent: Consent!

  """The physicalCard to activate"""
  physicalCard: PhysicalCard!
}

type ActiveMerchantPaymentLinkStatusInfo implements MerchantPaymentLinkStatusInfo {
  status: MerchantPaymentLinkStatus!

  """
  The date when the payment link expires.
  By default the payment link expires 120 days after it was created.
  """
  expiresAt: DateTime!
}

"""Inputs to add a new account membership"""
input AddAccountMembershipInput {
  """Unique identifier of a given account"""
  accountId: ID!

  """Email address"""
  email: String!

  """Restricted to a user if necessary"""
  restrictedTo: RestrictedToInput!

  """
  `true` if this account membership can view account balances and transactions history
  """
  canViewAccount: Boolean!

  """`true` if this account membership can add or canceled beneficiaries"""
  canManageBeneficiaries: Boolean!

  """`true` if this account membership can initiate credit transfers"""
  canInitiatePayments: Boolean!

  """
  `true` if this account membership can invite, update, suspend or resume account membership
  """
  canManageAccountMembership: Boolean!

  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Residency address of the member to be added"""
  residencyAddress: ResidencyAddressInput

  """Tax Identification Number of the user added"""
  taxIdentificationNumber: String

  """Language of the account membership"""
  language: AccountLanguage
}

union AddAccountMembershipPayload = AddAccountMembershipSuccessPayload | BadAccountStatusRejection | ForbiddenRejection | InvalidPhoneNumberRejection | MissingPhoneNumberRestrictionRejection | PermissionCannotBeGrantedRejection | ValidationRejection

"""Inputs to add a new account membership"""
input AddAccountMembershipsInput {
  """Unique identifier of a given account"""
  accountId: ID!

  """Memberships to add to the account"""
  memberships: [MembershipInfoInput!]!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union AddAccountMembershipsPayload = AddAccountMembershipsSuccessPayload | BadAccountStatusRejection | ForbiddenRejection | InvalidPhoneNumberRejection | MissingPhoneNumberRestrictionRejection | PermissionCannotBeGrantedRejection | TooManyItemsRejection | ValidationRejection

type AddAccountMembershipsSuccessPayload {
  accountMemberships: [AccountMembership!]!
}

type AddAccountMembershipSuccessPayload {
  accountMembership: AccountMembership!
}

"""Inputs to add a new card"""
input AddCardInput {
  """Unique identifier of a given account membership"""
  accountMembershipId: ID!

  """Card expiration date  if `null` it does not have an expiration date"""
  cardContractExpiryDate: DateTime

  """`true` if this card allows cash withdrawals"""
  withdrawal: Boolean!

  """`true` if this card allows payments outside of the country"""
  international: Boolean!

  """
  `true` if this card allows transactions outside of the card's main currency
  """
  nonMainCurrencyTransactions: Boolean!

  """`true` if this card allows transactions at eCommerce sites"""
  eCommerce: Boolean!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Card name"""
  name: String

  """`true` to show the card confidential information in the same request"""
  viewCardNumber: Boolean

  """The id of the card product to use to create the new card."""
  cardProductId: ID

  """Spending limit"""
  spendingLimit: SpendingLimitInput
}

union AddCardPayload = AddCardSuccessPayload | AccountMembershipNotAllowedRejection | BadAccountStatusRejection | CardProductDisabledRejection | CardProductSuspendedRejection | EnabledCardDesignNotFoundRejection | ForbiddenRejection | MissingMandatoryFieldRejection | ValidationRejection

"""Input to add a new cards"""
input AddCardsInput {
  """The configuration of all the cards you want to add"""
  cards: [CardConfigInput!]!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """The id of the card product to use to create the new cards."""
  cardProductId: ID
}

union AddCardsPayload = AddCardsSuccessPayload | AddingCardsToDifferentAccountsRejection | BadAccountStatusRejection | TooManyItemsRejection | AccountMembershipNotAllowedRejection | CardProductSuspendedRejection | CardProductNotApplicableToPhysicalCardsRejection | CardProductDisabledRejection | EnabledCardDesignNotFoundRejection | MissingMandatoryFieldRejection | ValidationRejection

type AddCardsSuccessPayload {
  """The newly created cards"""
  cards: [Card!]!
}

type AddCardSuccessPayload {
  """The new card added"""
  card: Card!
}

"""Input to add a new cards"""
input AddCardsWithGroupDeliveryInput {
  """Address to deliver the printed physical cards"""
  groupDeliveryAddress: CompleteAddressWithContactInput!

  """The configuration of all the cards you want to add"""
  cards: [CardConfigWithGroupDeliveryInput!]!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """The id of the card product to use to create the new cards."""
  cardProductId: ID
}

union AddCardsWithGroupDeliveryPayload = AddCardsWithGroupDeliverySuccessPayload | AddingCardsToDifferentAccountsRejection | BadAccountStatusRejection | TooManyItemsRejection | AccountMembershipNotAllowedRejection | CardProductSuspendedRejection | CardProductNotApplicableToPhysicalCardsRejection | CardProductDisabledRejection | EnabledCardDesignNotFoundRejection | MissingMandatoryFieldRejection | ValidationRejection

type AddCardsWithGroupDeliverySuccessPayload {
  """The newly created cards"""
  cards: [Card!]!
}

"""Inputs to add a new digital card"""
input AddDigitalCardInput {
  """Unique identifier of a card"""
  cardId: ID!

  """Provider for which to generate a digitalCard"""
  walletProvider: WalletProviderType!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

"""Payload returned on mutation completion"""
union AddDigitalCardPayload = AddDigitalCardSuccessPayload | CardNotFoundRejection | CardCanNotBeDigitalizedRejection | ApplePayNotAllowedForProjectRejection | BadAccountStatusRejection | AccountMembershipNotAllowedRejection | UserNotCardHolderRejection | CardProductDisabledRejection | EnabledCardDesignNotFoundRejection | MissingMandatoryFieldRejection | ValidationRejection

type AddDigitalCardSuccessPayload {
  """
  Digital Card used for ApplePay or GooglePay
  
  The consent can be found in the digital card status information.
  """
  digitalCard: PendingDigitalCard!
}

"""Input to add a Direct Debit Funding Source"""
input AddDirectDebitFundingSourceInput {
  """Scheme of the underlying payment mandate"""
  scheme: SEPADirectDebitScheme!

  """
  Id of the account on which to create a funding source.
  Money will be funded to this account when an `initiateFundingRequest` is done using this funding source
  """
  accountId: ID!

  """
  IBAN to use in the direct debit transaction that will be triggered when funding the account.
  Money will be debited from this IBAN when an `initiateFundingRequest` is done using this funding source
  """
  iban: IBAN!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Name to give to this funding source"""
  name: String
}

"""Add Direct Debit Funding Source Payload"""
union AddDirectDebitFundingSourcePayload = AddDirectDebitFundingSourceSuccessPayload | ForbiddenRejection | NotFoundRejection | AccountVerificationAlreadyRejectedRejection | IBANNotReachableRejection | ValidationRejection

"""Add Direct Debit Funding Source Success Payload"""
type AddDirectDebitFundingSourceSuccessPayload {
  """The created funding source"""
  fundingSource: FundingSource!
}

input AddExternalAccountBalanceInput {
  """Unique identifier of a given external account"""
  externalAccountId: ID!

  """Amount of the balance"""
  amount: AmountInput!

  """Type of the balance"""
  type: ExternalAccountBalanceType!

  """Last changed Date"""
  lastChangedAt: DateTime!
}

union AddExternalAccountBalancePayload = AddExternalAccountBalanceSuccessPayload | ValidationRejection | ExternalAccountBalanceAlreadyExistsRejection | ForbiddenRejection

type AddExternalAccountBalanceSuccessPayload {
  """The added external balance"""
  externalAccountBalance: ExternalAccountBalance!
}

input AddExternalAccountInput {
  """Unique identifier of a given account holder"""
  accountHolderId: ID!

  """External account identifier"""
  externalId: String!

  """Name of the account"""
  name: String

  """Type of account"""
  cashAccountType: CashAccountType!

  """Bank Identifier Code"""
  BIC: BIC!

  """International Bank Account Number"""
  IBAN: IBAN!

  """Currency"""
  currency: Currency!

  """Account Holder name"""
  holderName: String!

  """Country"""
  country: CCA3!

  """Original Created date"""
  originalCreatedAt: DateTime!

  """Usage information of the account"""
  usage: ExternalAccountUsage!

  """Source of the account information"""
  source: String!

  """Balances"""
  balances: [ExternalAccountBalanceInput!]
}

union AddExternalAccountPayload = AddExternalAccountSuccessPayload | ValidationRejection | IbanValidationRejection | ExternalAccountAlreadyExistsRejection | ForbiddenRejection

type AddExternalAccountSuccessPayload {
  """The added external account"""
  externalAccount: ExternalAccount!
}

"""Inputs to add a new request for funding limit settings change"""
input AddFundingLimitSettingsChangeRequestInput {
  """Requested amount settings for the instant funding limit"""
  instantFundingLimit: FundingLimitAmountInput!

  """Requested amount settings for the funding limit"""
  fundingLimit: FundingLimitAmountInput!

  """Unique identifier of a given account holder"""
  accountHolderId: ID!
}

"""Payload returned on mutation completion"""
union AddFundingLimitSettingsChangeRequestPayload = AddFundingLimitSettingsChangeRequestSuccessPayload | FundingLimitSettingsChangeRequestBadAmountRejection | AccountHolderNotFoundRejection | ForbiddenRejection | ValidationRejection

"""Add Funding Limit Settings Change Request Success Payload"""
type AddFundingLimitSettingsChangeRequestSuccessPayload {
  """The new request for funding limit settings change"""
  fundingLimitSettingsChangeRequest: FundingLimitSettingsChangeRequest!
}

"""
Rejection returned if the attempting to add cards to different accounts.
"""
type AddingCardsToDifferentAccountsRejection implements Rejection {
  message: String!
}

"""Inputs to add an Internal Direct Debit Payment Mandate"""
input AddInternalDirectDebitPaymentMandateInput {
  """The ID of the concerned merchant payment method"""
  paymentMethodId: ID!

  """Determines whether the payment mandate is a one-off or recurrent"""
  sequence: InternalDirectDebitSequence

  """Reference of the payment mandate"""
  reference: String

  """Language that will be used to produce the mandate PDF document"""
  language: MandateLanguage

  """ID of the Swan account of the debtor"""
  debtorAccountId: ID!

  """Signature date of the Internal Direct Debit mandate"""
  signatureDate: Date

  """Custom name of the Internal Direct Debit mandate"""
  name: String
}

"""Union type return by the addInternalDirectDebitPaymentMandate mutation"""
union AddInternalDirectDebitPaymentMandatePayload = AddInternalDirectDebitPaymentMandateSuccessPayload | ForbiddenRejection | NotFoundRejection | DebtorAccountNotAllowedRejection | DebtorAccountClosedRejection | SchemeWrongRejection | PaymentMandateReferenceAlreadyUsedRejection | MerchantProfileNotValidRejection | IBANNotValidRejection | IBANNotReachableRejection | PaymentMethodNotCompatibleRejection | InternalErrorRejection

"""
Return type in case of a successful response of the addInternalDirectDebitPaymentMandate mutation
"""
type AddInternalDirectDebitPaymentMandateSuccessPayload {
  paymentMandate: InternalPaymentDirectDebitMandate!
}

"""Input to add a Merchant Profile"""
input AddMerchantProfileInput {
  """ID of the Swan account which the merchantProfile is associated to"""
  accountId: ID!

  """
  Business name of the merchant, i.e. name that will be displayed on debtors' bank statements
  """
  merchantName: String!

  """Url of the merchant's website"""
  merchantWebsite: String

  """base64 encoded merchant's logo"""
  merchantLogo: String

  """
  Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
  """
  productType: ProductType!

  """Expected annual activity volumes for all payment methods."""
  expectedMonthlyPaymentVolume: AmountInput!

  """expected average basket value."""
  expectedAverageBasket: AmountInput!

  """
  Your accent color, used in white label interfaces.
  This color would also be inherited in the Swan Merchant Payment page.
  """
  accentColor: String
}

"""Add Merchant Profile Payload"""
union AddMerchantProfilePayload = AddMerchantProfileSuccessPayload | ForbiddenRejection | AccountNotFoundRejection | InternalErrorRejection | ValidationRejection

"""Add Merchant Profile Success Payload"""
type AddMerchantProfileSuccessPayload {
  """Merchant Profile"""
  merchantProfile: MerchantProfile!
}

input AddOrUpdateExternalAccountBalanceInput {
  """Unique identifier of a given external account"""
  externalAccountId: ID!

  """Amount of the balance"""
  amount: AmountInput!

  """Type of the balance"""
  type: ExternalAccountBalanceType!

  """Last changed Date"""
  lastChangedAt: DateTime!
}

union AddOrUpdateExternalAccountBalancePayload = AddOrUpdateExternalAccountBalanceSuccessPayload | ValidationRejection | ForbiddenRejection

type AddOrUpdateExternalAccountBalanceSuccessPayload {
  """The added external balance"""
  externalAccountBalance: ExternalAccountBalance!
}

"""Inputs to add a received internal direct debit mandate B2b."""
input AddReceivedInternalDirectDebitB2bMandateInput {
  """The associated Payment Mandate ID"""
  paymentMandateId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """
  Label that will be displayed along with this received direct debit mandate in the web banking
  """
  name: String
}

"""
Union type return by the addReceivedInternalDirectDebitB2bMandate mutation
"""
union AddReceivedInternalDirectDebitB2bMandatePayload = AddReceivedInternalDirectDebitB2bMandateSuccessPayload | ForbiddenRejection | PaymentMandateMandateNotFoundRejection | AccountHolderTypeIndividualRejection | ValidationRejection

"""
Return type in case of a successful response of the addReceivedInternalDirectDebitB2bMandate mutation
"""
type AddReceivedInternalDirectDebitB2bMandateSuccessPayload {
  """The received direct debit mandate is added"""
  receivedDirectDebitMandate: ReceivedDirectDebitMandate!
}

"""Inputs to add a received sepa direct debit mandate B2b."""
input AddReceivedSepaDirectDebitB2bMandateInput {
  """The unique identifier of the received direct debit mandate"""
  mandateReference: String!

  """The Sepa Creditor Identifier of the creditor"""
  creditorIdentifier: String!

  """The name of the creditor"""
  creditorName: String!

  """The Swan Iban of the debtor"""
  iban: String!

  """
  Label that will be displayed along with this received direct debit mandate in the web banking
  """
  name: String

  """Sequence of the mandate"""
  sequence: SEPAReceivedDirectDebitMandateSequence!

  """Date of signature of the mandate"""
  signatureDate: Date

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

"""Union type return by the addReceivedSepaDirectDebitB2bMandate mutation"""
union AddReceivedSepaDirectDebitB2bMandatePayload = AddReceivedSepaDirectDebitB2bMandateSuccessPayload | ForbiddenRejection | AccountNotFoundRejection | AccountHolderTypeIndividualRejection | ValidationRejection

"""
Return type in case of a successful response of the addReceivedSepaDirectDebitB2bMandate mutation
"""
type AddReceivedSepaDirectDebitB2bMandateSuccessPayload {
  """The received direct debit mandate is added"""
  receivedDirectDebitMandate: ReceivedDirectDebitMandate!
}

"""Address Information"""
type Address {
  """address line 1"""
  addressLine1: String

  """addressLine2"""
  addressLine2: String

  """city"""
  city: String

  """postal code (max 10 characters)"""
  postalCode: String

  """state"""
  state: String

  """country"""
  country: CCA3
}

"""Address information."""
type AddressInfo {
  """Address line 1."""
  addressLine1: String

  """Address line 2."""
  addressLine2: String

  """City."""
  city: String

  """Postal code."""
  postalCode: String

  """State."""
  state: String

  """Country."""
  country: CCA3
}

"""Address"""
type AddressInformation {
  """Address"""
  addressLine1: String!

  """Address"""
  addressLine2: String

  """City"""
  city: String!

  """Country"""
  country: CCA3!

  """Postal code"""
  postalCode: String!

  """State"""
  state: String
}

"""Address"""
input AddressInformationInput {
  """Address"""
  addressLine1: String

  """Address"""
  addressLine2: String

  """City"""
  city: String

  """Country"""
  country: CCA3!

  """Postal code"""
  postalCode: String

  """State"""
  state: String
}

"""Address Information"""
input AddressInput {
  """address line 1 (max 100 characters)"""
  addressLine1: String

  """address line 2 (max 100 characters)"""
  addressLine2: String

  """city (max 100 characters)"""
  city: String

  """postal code (max 10 characters)"""
  postalCode: String

  """state (max 100 characters)"""
  state: String

  """country code"""
  country: CCA3!
}

input AddSepaDirectDebitPaymentMandateInput {
  """
  Specifies payment ID of a SEPA Direct Debit CORE or B2B payment method.
  """
  paymentMethodId: ID!

  """Determines whether the payment mandate is a one-off or recurrent"""
  sequence: DirectDebitSequence!

  """Unique reference of the SEPA Direct Debit Payment Mandate."""
  reference: String

  """Language that will be used to produce the mandate PDF document"""
  language: MandateLanguage!

  """Signature date of the SEPA Direct Debit Payment Mandate"""
  signatureDate: Date!

  """Debtor of the SEPA Direct Debit Payment Mandate"""
  debtor: SepaPaymentMandateDebtorInput!

  """Custom name of the SEPA Direct Debit Payment Mandate"""
  name: String
}

"""Union type return by the addSepaDirectDebitPaymentMandate mutation"""
union AddSepaDirectDebitPaymentMandatePayload = AddSepaDirectDebitPaymentMandateSuccessPayload | ForbiddenRejection | NotFoundRejection | DebtorAccountNotAllowedRejection | DebtorAccountClosedRejection | SchemeWrongRejection | PaymentMandateReferenceAlreadyUsedRejection | ValidationRejection | PaymentMethodNotCompatibleRejection | InternalErrorRejection | MerchantProfileNotValidRejection | IBANNotValidRejection | IBANNotReachableRejection

"""
Return type in case of a successful response of the addSepaDirectDebitPaymentMandate mutation
"""
type AddSepaDirectDebitPaymentMandateSuccessPayload {
  paymentMandate: SEPAPaymentDirectDebitMandate!
}

"""Inputs to add a new card"""
input AddSingleUseVirtualCardInput {
  """Unique identifier of a given account membership"""
  accountMembershipId: ID!

  """Spending limit"""
  spendingLimit: SpendingLimitInput!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Card name"""
  name: String

  """`true` to show the card confidential information in the same request"""
  viewCardNumber: Boolean

  """The id of the card product to use to create the new card."""
  cardProductId: ID
}

union AddSingleUseVirtualCardPayload = AddSingleUseVirtualCardSuccessForUserPayload | AddSingleUseVirtualCardSuccessForProjectOwnerPayload | BadAccountStatusRejection | AccountMembershipNotAllowedRejection | CardProductSuspendedRejection | CardProductDisabledRejection | EnabledCardDesignNotFoundRejection | MissingMandatoryFieldRejection | ValidationRejection

"""Input to add a new single-use virtual cards"""
input AddSingleUseVirtualCardsInput {
  """The configuration of all the cards you want to add"""
  cards: [SingleUseVirtualCardConfigInput!]!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """The id of the card product to use to create the new cards."""
  cardProductId: ID
}

union AddSingleUseVirtualCardsPayload = AddSingleUseVirtualCardsSuccessPayload | AddingCardsToDifferentAccountsRejection | TooManyItemsRejection | BadAccountStatusRejection | AccountMembershipNotAllowedRejection | CardProductSuspendedRejection | CardProductDisabledRejection | EnabledCardDesignNotFoundRejection | MissingMandatoryFieldRejection | ValidationRejection

type AddSingleUseVirtualCardsSuccessPayload {
  """The newly created single use virtual cards"""
  cards: [Card!]!
}

type AddSingleUseVirtualCardSuccessForProjectOwnerPayload {
  """The new card added"""
  card: Card!

  """Card confidential"""
  confidential: CardConfidential!
}

type AddSingleUseVirtualCardSuccessForUserPayload {
  """The new card added"""
  card: Card!
}

"""Input to add an international trusted beneficiary"""
input AddTrustedInternationalBeneficiaryInput {
  """Account ID of the account on which the beneficiary will be created"""
  accountId: ID!

  """Currency of the international beneficiary account"""
  currency: Currency!

  """Currency-specific details of the beneficiary"""
  details: [InternationalBeneficiaryDetailsInput!]!

  """Name of the created beneficiary"""
  label: String

  """Account holder name of the international trusted beneficiary"""
  name: String!

  """Route that Swan will use to transfer the funds to that beneficiary"""
  route: InternationalCreditTransferRouteInput!

  """When the consent flow is finished the user is redirected to this URL"""
  consentRedirectUrl: String!
}

"""Add international trusted beneficiary payload"""
union AddTrustedInternationalBeneficiaryPayload = AddTrustedInternationalBeneficiarySuccessPayload | ForbiddenRejection | AccountNotFoundRejection | ValidationRejection | InternalErrorRejection

"""Add international trusted beneficiary success payload"""
type AddTrustedInternationalBeneficiarySuccessPayload {
  """The created beneficiary"""
  trustedBeneficiary: TrustedInternationalBeneficiary!
}

"""Input to add a SEPA trusted beneficiary"""
input AddTrustedSepaBeneficiaryInput {
  """Account ID of the account on which the beneficiary will be created"""
  accountId: ID!

  """IBAN of the SEPA trusted beneficiary"""
  iban: IBAN!

  """Name of the SEPA trusted beneficiary"""
  name: String!

  """
  Label of the SEPA trusted beneficiary. If not provided, the name will be used.
  """
  label: String

  """Beneficiary address"""
  address: AddressInput

  """When the consent flow is finished the user is redirected to this URL"""
  consentRedirectUrl: String!
}

"""Add sepa trusted beneficiary payload"""
union AddTrustedSepaBeneficiaryPayload = AddTrustedSepaBeneficiarySuccessPayload | ForbiddenRejection | AccountNotFoundRejection | ValidationRejection | InternalErrorRejection

"""Add SEPA trusted beneficiary success payload"""
type AddTrustedSepaBeneficiarySuccessPayload {
  """The created trusted sepa beneficiary"""
  trustedBeneficiary: TrustedSepaBeneficiary!
}

union AddVirtualIbanEntryPayload = AddVirtualIbanEntrySuccessPayload | AccountNotFoundRejection | BadAccountStatusRejection | ForbiddenRejection | ValidationRejection

type AddVirtualIbanEntrySuccessPayload {
  virtualIbanEntry: VirtualIBANEntry!
}

"""Input to Add a Virtual IBAN"""
input AddVirtualIbanInput {
  """Unique identifier of a given account"""
  accountId: ID!
}

"""Input values needed to add a webhook subscription"""
input AddWebhookSubscriptionInput {
  """
  A short descriptive label for the subscription
  (max 255 characters)
  """
  label: String!

  """
  The endpoint URL events will be sent to
  (max 255 characters)
  """
  endpoint: String!

  """
  The optional secret to secure incoming webhook calls. We recommend a UUID-4 to be future proof.
  (max 36 characters)
  """
  secret: String

  """
  The types of subscribed events
  A subset of unique IDs from `webhookEventTypes`
  """
  eventTypes: [ID!]!

  """Control if the subscription should be enabled on creation"""
  status: WebhookSubscriptionCreationStatus!
}

type AllowedValue {
  key: String!
  name: String!
}

"""Input to Allow SDD"""
input AllowSddInput {
  """Unique identifier of a given account"""
  accountId: ID!
}

union AllowSddPayload = AllowSddSuccessPayload | AccountNotFoundRejection | ValidationRejection

type AllowSddSuccessPayload {
  account: Account!
}

input AllowSddVirtualIbanEntryInput {
  ibanEntryId: ID!
}

union AllowSddVirtualIbanEntryPayload = AllowSddVirtualIbanEntrySuccessPayload | BadAccountStatusRejection | ValidationRejection

type AllowSddVirtualIbanEntrySuccessPayload {
  virtualIbanEntry: VirtualIBANEntry!
}

"""Rejection returned if card already has a valid Physical Card"""
type AlreadyValidPhysicalCardRejection implements Rejection {
  message: String!
}

enum AmlRiskLevel {
  Low
  Medium
  High
  TooHigh
}

"""Amount with its currency"""
type Amount {
  """currency"""
  currency: Currency!

  """value of the amount"""
  value: AmountValue!
}

"""Amount with its currency"""
input AmountInput {
  """value of the amount"""
  value: AmountValue!

  """currency"""
  currency: Currency!
}

"""
The amount given with fractional digits, where fractions must be compliant to the currency definition. Up to 14 significant figures. Negative amounts are signed by minus. The decimal separator is a dot.

Example: Valid representations for EUR with up to two decimals are:

1056
5768.2
-1.50
5877.78
"""
scalar AmountValue

"""Rejection return if the project is not configured to allow Apple Pay"""
type ApplePayNotAllowedForProjectRejection implements Rejection {
  id: String!
  message: String!
}

"""Approved Funding Limit"""
type ApprovedFundingLimit {
  """Requested amount settings for the instant funding limit"""
  instantFundingLimit: FundingLimitAmount!

  """Requested amount settings for the funding limit"""
  fundingLimit: FundingLimitAmount!
}

scalar AuditId

"""A method used to authenticate a user"""
type Authenticator {
  """
  Operating System parsed from the user agent (eg AIX, Amiga OS, Android, Arch, Bada, BeOS, BlackBerry, ...)
  """
  os: String

  """
  Device Brand parsed from the user agent (eg: Acer, Alcatel, Amazon, Apple, ...)
  """
  brand: String

  """Device Model parsed from the user agent"""
  model: String

  """Type of authenticator"""
  type: AuthenticatorType!

  """Raw user agent"""
  userAgent: String

  """Accept-Language header used during registration"""
  acceptLanguage: String
}

enum AuthenticatorType {
  """A Swan web authenticator"""
  SwanWeb

  """Deprecated: swan authenticator"""
  Swan
}

scalar AuthorizationId

"""Type of the card authorization transaction"""
enum AuthorizationType {
  """
  Classic authorization, nominal use-case, in order to hold the amount in the available balance that will be debited in the following days
  """
  Classic

  """
  Pre-authorization.
  Usually an authorization in order to hold the amount in the available balance that will be updated in a second time with the final amount (gaz station, car rent, etc)
  """
  PreAuthorization

  """
  Usually an authorization used by a merchant to verify if the card exists and can successfully receive a future authorization
  """
  DataRequest
}

"""Rejection returned if the status account is not valid"""
type BadAccountStatusRejection implements Rejection {
  id: String!
  message: String!
}

type BadRequestRejection implements Rejection {
  message: String!
}

"""Balance Information"""
type Balance {
  """Matching account for this balance"""
  account: Account!

  """A list of balances regarding an account."""
  balances: AccountBalances

  """Last SCT OUT transaction"""
  lastSctOut: SEPACreditTransferTransaction

  """Last SCT IN transaction"""
  lastSctIn: SEPACreditTransferTransaction
}

"""Information about the banking institution"""
type Bank {
  """Bank name"""
  name: String!

  """Bank Branch Code"""
  branch: String

  """Bank local identifier (unique by country)"""
  nationalId: String!

  """Bank BIC code"""
  bic: BIC!

  """Bank address (We might only be able to fill in the country)"""
  address: Address!
}

"""Basic Physical Card Info"""
type BasicPhysicalCardInfo {
  """Physical Card expiration date  with MM/YY string format"""
  expiryDate: String

  """Offline Spending limit defined by Swan"""
  offlineSpendingLimit: Amount!

  """Masked Card Number"""
  cardMaskedNumber: String!

  """Custom Options"""
  customOptions: PhysicalCardCustomOptions!

  """Unique identifier present on physical card"""
  identifier: String

  """`true` if physical card is expired"""
  isExpired: Boolean!
}

union Beneficiary = TrustedSepaBeneficiary | UnsavedSepaBeneficiary

"""BeneficiaryAccountHolderType"""
enum BeneficiaryAccountHolderType {
  Individual
  Company

  """Beneficiary's bank did not disclose account holder type"""
  Unknown
}

"""BeneficiaryAccountStatus"""
enum BeneficiaryAccountStatus {
  Active
  Inactive

  """Beneficiary's bank did not disclose account status"""
  Unknown
}

"""Beneficiary name and IBAN match"""
type BeneficiaryMatch {
  accountStatus: BeneficiaryAccountStatus!
  accountHolderType: BeneficiaryAccountHolderType!
}

"""Beneficiary name and IBAN did not match"""
type BeneficiaryMismatch {
  accountStatus: BeneficiaryAccountStatus!
  accountHolderType: BeneficiaryAccountHolderType!

  """
  Only returned if accountHolderType is Company and if the information is provided by the beneficiary's bank
  """
  nameSuggestion: String

  """
  Only returned if accountHolderType is Company and if the information is provided by the beneficiary's bank
  """
  accountHolderResidencyCity: String
}

"""Beneficiary type"""
enum BeneficiaryType {
  """for Internal transfer"""
  Internal

  """for International transfer"""
  International

  """for SEPA transfer"""
  Sepa
}

"""
Beneficiary name and IBAN did not match entirely possibly caused by a mistype
"""
type BeneficiaryTypo {
  accountStatus: BeneficiaryAccountStatus!
  accountHolderType: BeneficiaryAccountHolderType!

  """Only returned if the information is provided by the beneficiary's bank"""
  nameSuggestion: String
}

"""BeneficiaryVerification input"""
input BeneficiaryVerificationInput {
  """IBAN to verify"""
  iban: IBAN!

  """Name to correlate"""
  name: String!

  """AccountId of the initiator of the payment"""
  debtorAccountId: String!
}

"""BeneficiaryVerificationResult"""
union BeneficiaryVerificationResult = BeneficiaryMatch | BeneficiaryTypo | BeneficiaryMismatch | InvalidBeneficiaryVerification

"""Bank Identifier Code"""
scalar BIC

input BindAccountMembershipInput {
  accountMembershipId: ID!
}

union BindAccountMembershipPayload = BindAccountMembershipSuccessPayload | BadAccountStatusRejection | AccountMembershipNotFoundRejection | AccountMembershipNotReadyToBeBoundRejection | IdentityAlreadyBindToAccountMembershipRejection | RestrictedToUserRejection | ValidationRejection

type BindAccountMembershipSuccessPayload {
  accountMembership: AccountMembership!
}

type BlacklistedPhoneNumberRejection implements Rejection {
  message: String!
}

"""Booked transaction status information"""
type BookedTransactionStatusInfo implements TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!

  """
  The Date when the transaction is posted to an account on the Swan books.
  """
  bookingDate: DateTime!

  """The Date when the transaction is considered effective in accounting"""
  valueDate: DateTime!
}

"""Business activity."""
enum BusinessActivity {
  AdministrativeServices
  Agriculture
  Arts
  BusinessAndRetail
  Construction
  Education
  ElectricalDistributionAndWaterSupply
  FinancialAndInsuranceOperations
  Health
  Housekeeping
  InformationAndCommunication
  LodgingAndFoodServices
  ManufacturingAndMining
  Other
  PublicAdministration
  RealEstate
  ScientificActivities
  Transportation
}

type CalledByABotRejection implements Rejection {
  message: String!
}

input CancelCapitalDepositCaseInput {
  id: ID!
}

union CancelCapitalDepositCasePayload = CancelCapitalDepositCaseSuccessPayload | ForbiddenRejection | InternalErrorRejection | CapitalDepositCaseCanNotBeFoundRejection | CapitalDepositCaseCanNotBeCanceledRejection

type CancelCapitalDepositCaseSuccessPayload {
  capitalDepositCase: CapitalDepositCase
}

"""Inputs to cancel a card"""
input CancelCardInput {
  """Unique identifier of a card"""
  cardId: ID!
}

union CancelCardPayload = CancelCardSuccessPayload | AccountMembershipNotAllowedRejection | CardNotFoundRejection | ForbiddenRejection | ValidationRejection

type CancelCardSuccessPayload {
  """The canceled card"""
  card: Card!
}

"""Input of the `cancelConsent` mutation"""
input CancelConsentInput {
  consentId: ID!
}

"""Payload of the `cancelConsent` mutation"""
union CancelConsentPayload = CancelConsentSuccessPayload | ConsentNotFoundRejection | NotReachableConsentStatusRejection

"""Success payload of the `cancelConsent` mutation"""
type CancelConsentSuccessPayload {
  consent: Consent!
}

"""Inputs to cancel a digital card"""
input CancelDigitalCardInput {
  """Unique identifier of a digital card"""
  digitalCardId: ID!
}

union CancelDigitalCardPayload = CancelDigitalCardSuccessPayload | AccountMembershipNotAllowedRejection | CardNotFoundRejection | DigitalCardNotFoundRejection | ForbiddenRejection | ValidationRejection

type CancelDigitalCardSuccessPayload {
  """The canceled digital card"""
  digitalCard: DigitalCard!
}

"""Funding Source Canceled Reason"""
enum CanceledFundingSourceReason {
  """User has canceled his funding source"""
  UserCanceled

  """Underlying mandate has expired"""
  MandateExpired

  """Underlying mandate has been canceled"""
  MandateCanceled
}

"""Funding Source Canceled status information"""
type CanceledFundingSourceStatusInfo implements FundingSourceStatusInfo {
  """Funding Source Canceled status"""
  status: FundingSourceStatus!

  """Date at which the funding source was enabled"""
  enabledAt: Date

  """Date at which the funding source was canceled"""
  canceledAt: Date!

  """Reason code of the cancellation"""
  reasonCode: CanceledFundingSourceReason!
}

"""
Describes an identification level for the process associated to this identification that has been cancelled by the end-user
"""
type CanceledIdentificationLevelStatusInfo {
  """Always set to `Cancelled`"""
  status: SwanIdentificationStatus!
}

"""Canceled transaction status information"""
type CanceledTransactionStatusInfo implements TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!

  """The date when the transaction was canceled"""
  canceledDate: DateTime
}

"""Cancel Funding Source Input"""
input CancelFundingSourceInput {
  """ID of the funding source to cancel"""
  id: ID!
}

"""Cancel Funding Source Payload"""
union CancelFundingSourcePayload = CancelFundingSourceSuccessPayload | ForbiddenRejection | NotFoundRejection

"""Cancel Funding Source Success Payload"""
type CancelFundingSourceSuccessPayload {
  """Canceled Funding Source"""
  fundingSource: FundingSource
}

input CancelMerchantPaymentMethodUpdateRequestInput {
  """ID of the MerchantPaymentMethod update request"""
  requestUpdateId: ID!
}

union CancelMerchantPaymentMethodUpdateRequestPayload = CancelMerchantPaymentMethodUpdateRequestSuccessPayload | ForbiddenRejection | NotFoundRejection | InternalErrorRejection | UpdateRequestNotPendingReviewRejection

type CancelMerchantPaymentMethodUpdateRequestSuccessPayload {
  requestUpdateId: ID
}

input CancelMerchantProfileUpdateRequestInput {
  """ID of the MerchantProfile update request"""
  requestUpdateId: ID!
}

union CancelMerchantProfileUpdateRequestPayload = CancelMerchantProfileUpdateRequestSuccessPayload | ForbiddenRejection | NotFoundRejection | InternalErrorRejection | UpdateRequestNotPendingReviewRejection

type CancelMerchantProfileUpdateRequestSuccessPayload {
  requestUpdateId: ID
}

"""Inputs to cancel a physical card"""
input CancelPhysicalCardInput {
  """Unique identifier of a card"""
  cardId: ID!

  """Reason why the physical card is canceled"""
  reason: CancelPhysicalCardReason!
}

union CancelPhysicalCardPayload = CancelPhysicalCardSuccessPayload | AccountMembershipNotAllowedRejection | CardNotFoundRejection | ForbiddenRejection | PhysicalCardNotFoundRejection | ValidationRejection

"""reason why the physical card is canceled"""
enum CancelPhysicalCardReason {
  """When the cardholder never received the card"""
  NonReceived

  """When the card has been stolen"""
  Lost

  """When the card has been stolen"""
  Stolen

  """When the card doesn't work anymore"""
  Defected

  """When the cardholder wants to block his card"""
  Blocked
}

type CancelPhysicalCardSuccessPayload {
  """The canceled physical card"""
  physicalCard: PhysicalCard!
}

input CancelStandingOrderInput {
  standingOrderId: String!
}

union CancelStandingOrderPayload = CancelStandingOrderSuccessPayload | ForbiddenRejection | InternalErrorRejection | StandingOrderNotFoundRejection

type CancelStandingOrderSuccessPayload {
  standingOrder: StandingOrder!
}

"""Cancel transaction"""
input CancelTransactionInput {
  """transaction ID to cancel"""
  transactionId: ID!
}

union CancelTransactionPayload = CancelTransactionSuccessPayload | ForbiddenRejection

type CancelTransactionSuccessPayload {
  message: String!
}

input CancelVirtualIbanEntryInput {
  virtualIbanEntryId: ID!
}

union CancelVirtualIbanEntryPayload = CancelVirtualIbanEntrySuccessPayload | AccountNotFoundRejection | BadAccountStatusRejection | InternalErrorRejection | ValidationRejection

type CancelVirtualIbanEntrySuccessPayload {
  virtualIbanEntry: VirtualIBANEntry!
}

"""Rejection returned when the Physical Card cannot be activated"""
type CannotActivatePhysicalCardRejection implements Rejection {
  message: String!
  identifier: String!
}

"""Capital deposit case for a company."""
type CapitalDepositCase {
  """Unique identifier of a capital deposit case."""
  id: String!

  """List of the company’s shareholders."""
  shareholders: [Shareholder!]!

  """Amount of the capital deposit."""
  totalCapitalDepositAmount: Amount!

  """Name of the company."""
  companyName: String!

  """Onboarding information of the company."""
  companyOnboarding: Onboarding

  """Unique identifier of the company account."""
  companyAccountId: String

  """Status of the capital deposit case."""
  status: CapitalDepositCaseStatus!

  """Documents to provide to fulfill the capital deposit case."""
  documents: [CapitalDepositDocument!]!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!
}

"""
Rejection returned if the capital deposit case cannot be canceled in its current state
"""
type CapitalDepositCaseCanNotBeCanceledRejection implements Rejection {
  id: String!
  message: String!
}

"""Rejection returned if the capital deposit case cannot be found"""
type CapitalDepositCaseCanNotBeFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""
Implements the Relay Connection interface, used to paginate list of elements ([Learn More](https://docs.swan.io/api/pagination))
"""
type CapitalDepositCaseConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """CapitalDepositCaseEdge list"""
  edges: [CapitalDepositCaseEdge!]!
}

"""Implements the Relay Edge interface"""
type CapitalDepositCaseEdge implements Edge {
  """
  Opaque identifier pointing to this capital deposit case node in the pagination mechanism
  """
  cursor: String!

  """The CapitalDepositCase"""
  node: CapitalDepositCase!
}

"""Filters that can be applied when listing capital deposit cases"""
input CapitalDepositCaseFiltersInput {
  """
  Search string to look for
  
  Search will be performed in following fields:
   - Company shareholder's name
   - Individual shareholder's first name
   - Individual shareholder's last name
   - Company name
   - ID
  """
  search: String

  """Filter by status"""
  status: [CapitalDepositCaseStatus!]
}

"""
Field we can use when ordering that can be applied when listing capital deposit cases
"""
enum CapitalDepositCaseOrderByFieldInput {
  id
  createdAt
  updatedAt
}

"""Order that can be applied when listing capital deposit cases"""
input CapitalDepositCaseOrderByInput {
  field: CapitalDepositCaseOrderByFieldInput
  direction: OrderByDirection
}

"""Status of a capital deposit case."""
enum CapitalDepositCaseStatus {
  """
  Technical state when the mutation to create a new capital deposit case is called.
  """
  Initiated

  """
  A new capital deposit case is created and Swan is waiting for the required information to be provided and each shareholder to wire their share of share capital.
  """
  WaitingForRequirements

  """
  Swan is waiting for the notary to provide the Share Deposit Certificate.
  """
  WaitingForShareDepositCertificate

  """Swan is waiting for you to provide the Register Extract."""
  WaitingForRegisterExtract

  """
  Swan is waiting for the notary to wire the share capital on the account of the company being registered.
  """
  WaitingForNotaryTransfer

  """The capital deposit case is completed."""
  Completed

  """The capital deposit case is canceled."""
  Canceled
}

"""Document provided for a capital deposit case."""
type CapitalDepositDocument {
  """Unique identifier of a document."""
  id: String!

  """Type of the document."""
  type: CapitalDepositDocumentType!

  """
  Url to download the document, null if it has not already been uploaded.
  """
  downloadUrl: String

  """Date when the last version of the document has been uploaded."""
  uploadedAt: Date

  """Status of the document."""
  status: CapitalDepositDocumentStatus! @deprecated(reason: "use statusInfo.status")

  """Status info of the document."""
  statusInfo: CapitalDepositDocumentStatusInfo!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Information about capital deposit case."""
  relatedCapitalDepositCase: CapitalDepositCase

  """Information about shareholder."""
  relatedShareholder: Shareholder
}

"""
Rejection returned if the document from a capital deposit case cannot be uploaded in its context
@deprecated(reason: "use `CapitalDepositDocumentCanNotBeUploadedRejection` instead")
"""
type CapitalDepositDocumentCanNotBeUploaded implements Rejection {
  id: String!
  message: String!
}

"""
Rejection returned if the document from a capital deposit case cannot be uploaded in its context
"""
type CapitalDepositDocumentCanNotBeUploadedRejection implements Rejection {
  id: String!
  message: String!
}

"""Capital Deposit Document with Pending status"""
type CapitalDepositDocumentPendingStatusInfo implements CapitalDepositDocumentStatusInfo {
  """Pending"""
  status: CapitalDepositDocumentStatus!
}

"""Capital Deposit Document with Refused status"""
type CapitalDepositDocumentRefusedStatusInfo implements CapitalDepositDocumentStatusInfo {
  """Refused"""
  status: CapitalDepositDocumentStatus!

  """Reason for the rejection."""
  reasonCode: DocumentReasonCode!
}

"""Status of the Capital Deposit Case"""
enum CapitalDepositDocumentStatus {
  """Document is not uploaded yet."""
  Pending

  """Document has been uploaded but not verified by Swan yet."""
  Uploaded

  """Document has been uploaded and verified by Swan."""
  Validated

  """Document has been refused by Swan, it must be uploaded again."""
  Refused
}

"""Status info of the document."""
interface CapitalDepositDocumentStatusInfo {
  """Status of the document."""
  status: CapitalDepositDocumentStatus!
}

"""Type of the document."""
enum CapitalDepositDocumentType {
  """Legal document required for company’s formation."""
  ArticlesOfIncorporation

  """Commercial registry extract issued within the last 3 months."""
  RegisterExtract

  """Can be either passport, national id card or resident permit."""
  ProofOfIdentity

  """
  Document submitted to your tax bureau at the end of the last business period.
  """
  CorporateIncomeTaxReturn

  """
  Can be a utility bill (water, electricity or gas), a telephone bill or a rental receipt. The document must have been issued within the last 3 months.
  """
  ProofOfIndividualAddress

  """
  Lease agreement in the name of the business or Proof of Individual Address if the company is hosted by one of the legal representative.
  """
  CompanyLeaseAgreement

  """
  Created by the Notary, it certifies the capital of the company to have been deposited with the appropriate share for each shareholder.
  """
  CapitalShareDepositCertificate

  """Signed power of attorney document to give the power to act on behalf."""
  PowerOfAttorney
}

"""Capital Deposit Document with Uploaded status"""
type CapitalDepositDocumentUploadedStatusInfo implements CapitalDepositDocumentStatusInfo {
  """Uploaded"""
  status: CapitalDepositDocumentStatus!
}

"""Capital Deposit Document with Validated status"""
type CapitalDepositDocumentValidatedStatusInfo implements CapitalDepositDocumentStatusInfo {
  """Validated"""
  status: CapitalDepositDocumentStatus!
}

"""Card"""
type Card {
  """Unique identifier of a card"""
  id: ID!

  """
  Digital Cards linked to this card
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  digitalCards(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """an order you can apply to your list of connections"""
    orderBy: DigitalCardOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: DigitalCardFiltersInput
  ): DigitalCardConnection!

  """
  List of transactions of a card.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  transactions(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: TransactionsOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """Type of a card"""
  type: CardType!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  Account membership to define the cardholder and the account linked to the card.
  """
  accountMembership: AccountMembership!

  """Main Currency"""
  mainCurrency: Currency!

  """Card expiration date  if `null` it does not have an expiration date"""
  cardContractExpiryDate: DateTime

  """URL of the card design"""
  cardDesignUrl: String!

  """
  URL of the card with masked card information (like its number) and with full card information if connected user consented beforehand
  """
  cardUrl: String!

  """Card status information"""
  statusInfo: CardStatusInfo!

  """`true` if this card allows cash withdrawals"""
  withdrawal: Boolean!

  """`true` if this card allows payments outside of the country"""
  international: Boolean!

  """
  `true` if this card allows transactions outside of the card's main currency
  """
  nonMainCurrencyTransactions: Boolean!

  """`true` if this card allows transactions at eCommerce sites"""
  eCommerce: Boolean!

  """Periodic Spending limit list"""
  spendingLimits: [SpendingLimit!]

  """Physical card if the cardholder has ordered one"""
  physicalCard: PhysicalCard

  """Masked Card Number"""
  cardMaskedNumber: String!

  """Card expiry date with MM/YY format"""
  expiryDate: String

  """Card name"""
  name: String

  """Card product"""
  cardProduct: CardProduct!

  """Issuing Country"""
  issuingCountry: CCA3!

  """Periodic Spending"""
  spending: Spending
}

enum CardAuthorizationType {
  Classic
  PreAuthorization
  DataRequest
}

"""Card Canceled Status Information"""
type CardCanceledStatusInfo implements CardStatusInfo {
  """Card status (always Canceled for type CardCanceledStatusInfo)."""
  status: CardStatus!

  """Reason why the card is canceled"""
  reason: String!
}

"""Card Canceling Status Information"""
type CardCancelingStatusInfo implements CardStatusInfo {
  """Card status (always Canceling for type CardCancelingStatusInfo)."""
  status: CardStatus!

  """Reason why the card is about to be canceled."""
  reason: String!
}

"""Rejection returned if the card could not be digitalized"""
type CardCanNotBeDigitalizedRejection implements Rejection {
  id: String!
  message: String!
}

type CardConfidential {
  """Card number"""
  pan: String!

  """Card verification value"""
  cvv: String!

  """Expiration date"""
  expiryDate: String!
}

input CardConfigInput {
  """Unique identifier of a given account membership"""
  accountMembershipId: ID!

  """Card expiration date  if `null` it does not have an expiration date"""
  cardContractExpiryDate: DateTime

  """`true` if this card allows cash withdrawals"""
  withdrawal: Boolean!

  """`true` if this card allows payments outside of the country"""
  international: Boolean!

  """
  `true` if this card allows transactions outside of the card's main currency
  """
  nonMainCurrencyTransactions: Boolean!

  """`true` if this card allows transactions at eCommerce sites"""
  eCommerce: Boolean!

  """Card name"""
  name: String

  """Spending limit"""
  spendingLimit: SpendingLimitInput!

  """If used a physical card will be printed and sent to the given address"""
  physicalCard: PhysicalCardConfigInput
}

input CardConfigWithGroupDeliveryInput {
  """Unique identifier of a given account membership"""
  accountMembershipId: ID!

  """Card expiration date  if `null` it does not have an expiration date"""
  cardContractExpiryDate: DateTime

  """`true` if this card allows cash withdrawals"""
  withdrawal: Boolean!

  """`true` if this card allows payments outside of the country"""
  international: Boolean!

  """
  `true` if this card allows transactions outside of the card's main currency
  """
  nonMainCurrencyTransactions: Boolean!

  """`true` if this card allows transactions at eCommerce sites"""
  eCommerce: Boolean!

  """Card name"""
  name: String

  """Spending limit"""
  spendingLimit: SpendingLimitInput!

  """`true` when you wish for print an associated physical card"""
  printPhysicalCard: Boolean!

  """Custom options to use for physical cards."""
  physicalCardCustomOptions: PhysicalCardCustomOptionsForGroupDeliveryInput
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type CardConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """CardEdge list"""
  edges: [CardEdge!]!
}

"""when the user has to consent to add this card"""
type CardConsentPendingStatusInfo implements CardStatusInfo {
  """
  Card status (always ConsentPending for type CardConsentPendingStatusInfo)
  """
  status: CardStatus!

  """The consent required to add this card"""
  consent: Consent!
}

type CardDesignBackground {
  """Unique identifier of a project card design background"""
  id: ID!

  """Card design background name"""
  name: String!

  """Card design background type"""
  type: String!

  """Card design background text color"""
  cardTextColor: String!

  """Card design background url"""
  cardBackgroundUrl: String!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!
}

"""Project Card Design Background Type"""
enum CardDesignBackgroundType {
  """when Card design background is black"""
  Black

  """when Card design background is light"""
  Silver

  """when Card design background is customized"""
  Custom
}

"""Card designs Status"""
enum CardDesignStatus {
  """when card design are in Draft"""
  Draft

  """when card design are Enabled"""
  Enabled

  """when card design are Disabled"""
  Disabled

  """when card design are ToReview"""
  ToReview
}

union CardDetails = CardInDetails | CardOutDetails

"""Implements the Relay Edge interface"""
type CardEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The Card entry"""
  node: Card!
}

"""Card Enabled Status Information"""
type CardEnabledStatusInfo implements CardStatusInfo {
  """Card status (always Enabled for type CardEnabledStatusInfo)."""
  status: CardStatus!
}

"""Filters that can be applied when listing cards"""
input CardFiltersInput {
  """
  The status of the card.
  
  @deprecated(reason: "use `statuses` instead")
  """
  status: CardStatus

  """Statuses of the card."""
  statuses: [CardStatus!]

  """
  Type of card
  
  @deprecated(reason: "use `types` instead")
  """
  type: CardType

  """Types of card"""
  types: [CardType!]

  """String searched"""
  search: String

  """
  Account identifier
  
  This filter is only available for User Access Token, for the moment
  """
  accountId: String
}

enum CardFundingType {
  """Default funding type for cards"""
  Debit

  """Credit funding type for cards"""
  DeferredDebit
}

type CardInDetails {
  """payment mandate used for this transaction"""
  paymentMandate: CardPaymentMandate!
}

type CardInMerchant {
  """MerchantProfile"""
  merchantProfile: MerchantProfile!
}

union CardMerchant = CardInMerchant | CardOutMerchant

"""COMING SOON"""
type CardMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve

  """Reason of rejection when the status is Rejected"""
  rejectReason: MerchantPaymentMethodCardRejectReason
}

"""
Rejection returned if the card was not found or if the user does not have the rights to know that the account exists
"""
type CardNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Field we can use when ordering that can be applied when listing cards"""
enum CardOrderByFieldInput {
  id
  createdAt
  updatedAt
}

"""Order that can be applied when listing cards"""
input CardOrderByInput {
  field: CardOrderByFieldInput
  direction: OrderByDirection
}

type CardOutDetails {
  """card used for this transaction"""
  card: Card

  """card numbers masked (Primary Account Number)"""
  maskedPan: String!
}

type CardOutMerchant {
  """unique identifier of the merchant"""
  merchantId: String!

  """merchant name"""
  merchantName: String!

  """merchant city"""
  merchantCity: String!

  """merchant country"""
  merchantCountry: CCA3

  """merchant postal code"""
  merchantPostalCode: String

  """merchant category code (MCC)"""
  merchantCategoryCode: String!

  """
  merchant category description
  Enum that explains what the MCC corresponds to in a more readable way
  """
  merchantCategoryDescription: MerchantCategoryDescription!

  """category of the payment flow"""
  category: Category!
}

type CardPaymentMandate implements PaymentMandate {
  """Unique identifier of the Payment Mandate"""
  id: ID!

  """
  List of transactions associated with the Card Mandate.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  transactions(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: TransactionsOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """Custom name of the mandate"""
  name: String

  """Account Holder information"""
  accountHolder: AccountHolder!

  """The card associated to this mandate"""
  card: ExternalCard!

  """Creation date of the Payment Mandate"""
  createdAt: DateTime!

  """Last Update date of the Payment Mandate"""
  updatedAt: DateTime!

  """
  Date of the the last transaction executed for the concerned Payment Mandate
  """
  executedAt: DateTime

  """Expiry date of the Payment Mandate"""
  expiredAt: Date

  """Payment Mandate status information"""
  statusInfo: PaymentMandateStatusInfo!
}

enum CardPaymentMandateCategory {
  Consumer
  Commercial
}

enum CardPaymentMandateScheme {
  Visa
  Mastercard
  CartesBancaires
}

enum CardPaymentMandateType {
  Credit
  Debit
  Prepaid
  Charge
  Deferred
}

input CardPaymentMethodInput {
  """Determine whether the payment method must be activated or not"""
  activate: Boolean = false
}

"""Location where the card should be printed from"""
enum CardPrintingHub {
  France
  Spain
}

"""when the card is in the process of being ready to use"""
type CardProcessingStatusInfo implements CardStatusInfo {
  """Card status (always Processing for type CardProcessingStatusInfo)"""
  status: CardStatus!
}

"""Card Product"""
type CardProduct {
  id: ID!
  name: String
  projectId: ID!
  status: CardProductStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  applicableToPhysicalCards: Boolean!
  cardDesigns: [CardProductDesign!]!
  defaultCardProduct: Boolean!
  individualSpendingLimit: SpendingLimit!
  companySpendingLimit: SpendingLimit!

  """Card printing hub"""
  cardPrintingHub: CardPrintingHub
}

union CardProductByIdResultPayload = CardProduct | CardProductNotFoundRejection | ForbiddenRejection

"""Card design of a Card Product"""
type CardProductDesign {
  """Unique identifier of a card design"""
  id: ID!

  """Design version"""
  version: Int!

  """Logo url svg"""
  cardProjectLogoSvgUrl: String

  """Logo url 300 dpi"""
  cardProjectLogo300dpiUrl: String

  """Logo url 300 dpi"""
  cardProjectLogo600dpiUrl: String

  """Zoom level"""
  zoomRatioProjectLogo: Int

  """Card Design URL"""
  cardDesignUrl: String

  """Accent color"""
  accentColor: String!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Status of the card design"""
  status: CardDesignStatus!

  """Card Background of the Card design"""
  cardBackground: CardDesignBackground!
}

"""Rejection returned if the card product is disabled."""
type CardProductDisabledRejection implements Rejection {
  message: String!
}

"""
Rejection returned if the card product is not applicable to physical card.
"""
type CardProductNotApplicableToPhysicalCardsRejection implements Rejection {
  message: String!
}

type CardProductNotFoundRejection implements Rejection {
  message: String!
}

"""Card Product Status"""
enum CardProductStatus {
  """When card product is waiting for review"""
  PendingReview

  """When card product is Enabled"""
  Enabled

  """When card product is suspended"""
  Suspended

  """When card product is suspended"""
  Disabled
}

"""Rejection returned if the card product is suspended."""
type CardProductSuspendedRejection implements Rejection {
  message: String!
}

type CardProductUsedRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the card sensitive info are no longer available
"""
type CardSensitiveInfoNoLongerAvailableRejection implements Rejection {
  message: String!
}

"""Card settings for a Project"""
type CardSettings {
  """Unique identifier of a project card settings"""
  id: ID!

  """Flag used to indicate if ApplePay is activated for the project"""
  allowsApplePay: Boolean! @deprecated

  """Settings version"""
  version: Int!

  """Logo url svg"""
  cardProjectLogoSvgUrl: String

  """Logo url 300 dpi"""
  cardProjectLogo300dpiUrl: String

  """Logo url 300 dpi"""
  cardProjectLogo600dpiUrl: String

  """Zoom level"""
  zoomRatioProjectLogo: Int

  """Card Design URL"""
  cardDesignUrl: String

  """Accent color"""
  accentColor: String!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Status of the card settings"""
  status: ProjectCardStatus!

  """Card Background of the Card Settings"""
  cardBackground: CardSettingsBackground!
}

type CardSettingsBackground {
  """Unique identifier of a project card settings"""
  id: ID!

  """Card settings background name"""
  name: String!

  """Card settings background type"""
  type: String!

  """Card settings background text color"""
  cardTextColor: String!

  """Card settings background url"""
  cardBackgroundUrl: String!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!
}

"""Card Settings Background Type"""
enum CardSettingsBackgroundType {
  """when Card background is black"""
  Black

  """when Card background is light"""
  Silver

  """when Card background is customized"""
  Custom
}

"""Card Status"""
enum CardStatus {
  """when the consent to add this card is pending"""
  ConsentPending

  """when the card is in the process of being ready to use"""
  Processing

  """when the card is enabled"""
  Enabled

  """when the card is canceled"""
  Canceled

  """when the card is about to be canceled"""
  Canceling
}

"""Card Status Information"""
interface CardStatusInfo {
  """Status of the card."""
  status: CardStatus!
}

scalar CardToken

"""Card transaction"""
type CardTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!
  supportingDocumentCollections(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: SupportingDocumentCollectionFilterInput
  ): SupportingDocumentCollectionConnection!

  """external identifier of the transaction"""
  reference: String!

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """card numbers masked (Primary Account Number)"""
  maskedPan: String @deprecated(reason: "Use cardDetails.maskedPan instead")

  """unique identifier of the card"""
  cardId: String @deprecated(reason: "Use cardDetails.card.id instead")

  """card used for this transaction"""
  card: Card @deprecated(reason: "Use cardDetails.card instead")

  """unique identifier of the terminal"""
  terminalId: String

  """original amount and currency of the transaction"""
  originalAmount: Amount!

  """currency exchange if any"""
  currencyExchange: [ReportExchangeRate!]!

  """merchant associated"""
  merchant: CardMerchant

  """cardDetails associated"""
  cardDetails: CardDetails

  """unique identifier of the merchant"""
  merchantId: String @deprecated(reason: "Use merchant.merchantId instead")

  """merchant name"""
  merchantName: String @deprecated(reason: "Use merchant.merchantName instead")

  """merchant city"""
  merchantCity: String @deprecated(reason: "Use merchant.merchantCity instead")

  """merchant country"""
  merchantCountry: CCA3 @deprecated(reason: "Use merchant.merchantCountry instead")

  """merchant postal code"""
  merchantPostalCode: String @deprecated(reason: "Use merchant.merchantPostalCode instead")

  """merchant category code (MCC)"""
  merchantCategoryCode: String @deprecated(reason: "Use merchant.merchantCategoryCode instead")

  """
  merchant category description
  Enum that explains what the MCC corresponds to in a more readable way
  """
  merchantCategoryDescription: MerchantCategoryDescription @deprecated(reason: "Use merchant.merchantCategoryDescription instead")

  """category of the payment flow"""
  category: Category @deprecated(reason: "Use merchant.category instead")

  """
  type of the authorization.
  Only available for:
  - authorization transaction
  - debit transaction linked to a previous authorization transaction
  """
  authorizationType: AuthorizationType

  """matching account for the transaction"""
  account: Account

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """enriched data of the merchant"""
  enrichedTransactionInfo: EnrichedTransactionInfo

  """indicator of the transit type used (optional)"""
  transactionTransportType: TransactionTransportType

  """true if a transaction statement can be generated for this transaction"""
  statementCanBeGenerated: Boolean

  """project id of the transaction"""
  projectId: ID!
}

enum CardTransactionCategory {
  InStore
  eCommerce
  eCommerceWith3DS
  Withdrawal
  Other
}

"""Card Type"""
enum CardType {
  """When card is Virtual"""
  Virtual

  """When card is Virtual and Physical"""
  VirtualAndPhysical

  """When card is Single Use Virtual"""
  SingleUseVirtual
}

"""Rejection returned when the Card is not the expected status"""
type CardWrongStatusRejection implements Rejection {
  message: String!
  identifier: String!
  currentStatus: CardStatus!
  expectedStatus: CardStatus!
}

"""Cash account type (Always Current)"""
enum CashAccountType {
  """When the account is a current account."""
  Current
  CashPayment
  Charges
  CashIncome
  Commission
  ClearingParticipantSettlementAccount
  LimitedLiquiditySavingsAccount
  Loan
  MarginalLending
  MoneyMarket
  NonResidentExternal
  Overdraft
  OverNightDeposit
  OtherAccount
  Settlement
  Salary
  Savings
  Tax
  TransactingAccount
  CashTrading
}

"""Payment flow available options"""
enum Category {
  """In store payment"""
  InStore

  """Online (remote) payment"""
  eCommerce

  """Secured online (remote) payment"""
  eCommerceWith3DS

  """Cash withdraw (atm)"""
  Withdrawal

  """Other payment"""
  Other
}

"""Country code alpha 2 (ISO 3166)"""
scalar CCA2

"""Country code alpha 3 (ISO 3166)"""
scalar CCA3

"""Certificate"""
input Certificate {
  """
  CertificateType
  
  Can be either LEAF or INTERMEDIATE
  """
  key: String!

  """Base64 value of the certificate"""
  value: String!
}

"""CheckMerchantPaymentMethod"""
type CheckMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

input CheckPaymentMethodInput {
  """Determine whether the payment method must be activated or not"""
  activate: Boolean = false
}

type CheckRejection implements Rejection {
  message: String!
  fnciInfo: FnciInfo!
}

"""Check transaction"""
type CheckTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!
  supportingDocumentCollections(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: SupportingDocumentCollectionFilterInput
  ): SupportingDocumentCollectionConnection!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain.
  """
  reference: String!

  """payment method identifier used for this transaction: check number"""
  paymentMethodIdentifier: String!

  """
  31-caracter unique identifier located at the bottom of the check.
  CMC7 is composed of 3 sections (check number (7 char.), check issuing bank code (12 char.), check holder account number (12 char.)).
  Combined with RLMC key, it  allows the check traceability.
  """
  cmc7: String!

  """
  2-digit key used to check the integrity of the CMC7 line, located at the bottom right of the check.
  Combined with CMC7 line, it allows the check traceability.
  """
  rlmcKey: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """matching account for the transaction"""
  account: Account

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """reserved amount of the transaction computed with the rolling reserve."""
  reservedAmount: Amount

  """date on which reserved funds become available"""
  reservedAmountReleasedAt: DateTime

  """return reason"""
  returnReason: TransactionReasonCode

  """true if a transaction statement can be generated for this transaction"""
  statementCanBeGenerated: Boolean

  """project id of the transaction"""
  projectId: ID!

  """merchant profile associated"""
  merchant: MerchantProfile
}

input CloseAccountInput {
  accountId: ID!
  reason: PartnerCloseAccountReasonInput!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union CloseAccountPayload = CloseAccountSuccessPayload | AccountNotFoundRejection | BadAccountStatusRejection | ForbiddenRejection | InternalErrorRejection | ValidationRejection

"""
Define a reason with a message and a specific type for closing account action
"""
type CloseAccountReason implements Reason {
  type: CloseAccountReasonType!
  message: String
}

"""Specific type for closing account action"""
enum CloseAccountReasonType {
  """Compliance Reason"""
  ComplianceReason

  """Partner Reason"""
  PartnerReason

  """Inactivity"""
  Inactivity

  """Capital Deposit Reason"""
  CapitalDepositReason
}

"""
Union between PartnerCloseAccountReasonType and InternalCloseAccountReason
"""
union CloseAccountStatusReason = CloseAccountReason

type CloseAccountSuccessPayload {
  consent: Consent!
}

"""
Data provided following the search for company information by siren number
"""
type CompanyInfo {
  siren: String!
  companyName: String!
  headquarters: Headquarters!
  vatNumber: String
  taxIdentificationNumber: String
  legalRepresentativePersonalAddress: AddressInformation
}

"""Company shareholder info."""
type CompanyShareholder {
  """Whether the shareholder is an individual or a company."""
  type: ShareholderType!

  """Company name."""
  name: String!
}

"""Type of company."""
enum CompanyType {
  Association
  Company
  HomeOwnerAssociation
  Other
  SelfEmployed
}

"""Complete Address Information"""
input CompleteAddressInput {
  """address line 1 (max 38 characters)"""
  addressLine1: String!

  """address line 2 (max 38 characters)"""
  addressLine2: String

  """city (max 30 characters)"""
  city: String!

  """postal code (max 10 characters)"""
  postalCode: String!

  """state (max 30 characters)"""
  state: String

  """country code"""
  country: CCA3!
}

"""Complete Address Information with a contact"""
input CompleteAddressWithContactInput {
  """address line 1 (max 38 characters)"""
  addressLine1: String!

  """address line 2 (max 38 characters)"""
  addressLine2: String

  """city (max 30 characters)"""
  city: String!

  """postal code (max 10 characters)"""
  postalCode: String!

  """state (max 30 characters)"""
  state: String

  """country code"""
  country: CCA3!

  """contact first name"""
  firstName: String!

  """contact last name"""
  lastName: String!

  """contact phone number"""
  phoneNumber: PhoneNumber!

  """contact company name (max 38 characters)"""
  companyName: String
}

"""
Complete Digital Card used for ApplePay or GooglePay

Once the pending phase is over, more data will be available in the response
"""
type CompleteDigitalCard implements DigitalCard {
  """Unique identifier of a digital card"""
  id: ID!

  """The type of digitalization that created this digital card."""
  type: DigitalizationType!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Wallet Provider (ApplePay, GooglePay ...)"""
  walletProvider: WalletProvider!

  """
  Device
  In case of a wallet application, some information about the device will be provided
  """
  device: Device!

  """
  Id of the wallet application.
  Will not be present for Merchant
  """
  walletId: String

  """
  Masked DPAN with the last four digits visible
  
  This value is present in the user wallet application
  """
  cardMaskedNumber: String!

  """
  Digital Card status information
  
  In this type the status will be either ConsentPending or Pending
  """
  statusInfo: CompleteDigitalCardStatusInfo!

  """The project ID"""
  projectId: ID!

  """The card contract ID"""
  cardContractId: ID!
}

"""Complete Digital Card Status"""
enum CompleteDigitalCardStatus {
  """when the digital card is enabled"""
  Enabled

  """
  when the digital card is suspended
  
  the transactions will be blocked
  """
  Suspended

  """
  when the digital card is canceled
  
  this is a final state
  """
  Canceled
}

"""Complete Digital Card Status Information"""
interface CompleteDigitalCardStatusInfo {
  """Status of the digital card."""
  status: CompleteDigitalCardStatus!
}

type CompletedMerchantPaymentLinkStatusInfo implements MerchantPaymentLinkStatusInfo {
  status: MerchantPaymentLinkStatus!

  """The time when the customer completed the payment."""
  completedAt: DateTime!
}

input CompleteUserCreationInput {
  requestId: String!
  code: String!
  userInformation: UserInformationInput!
}

union CompleteUserCreationPayload = CompleteUserCreationSuccessPayload | WrongCodeRejection | UserBlockedRejection | OperationNotAllowedRejection | SmsProviderRejection | ValidationRejection

type CompleteUserCreationSuccessPayload {
  user: User!
  userAlreadyExisted: Boolean!
}

"""Inputs to confirm physical card renewal"""
input ConfirmPhysicalCardRenewalInput {
  """Unique identifier of a card"""
  cardId: ID!

  """Address to deliver the physical card"""
  address: CompleteAddressInput!

  """Custom Options"""
  customOptions: PhysicalCardCustomOptionsInput
}

union ConfirmPhysicalCardRenewalPayload = ConfirmPhysicalCardRenewalSuccessPayload | ForbiddenRejection | CardNotFoundRejection | ValidationRejection | PhysicalCardWrongStatusRejection

type ConfirmPhysicalCardRenewalSuccessPayload {
  """Physical card has been updated"""
  physicalCard: PhysicalCard!
}

"""
Relay Connection type, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
interface Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """Edge list"""
  edges: [Edge!]!
}

"""
Some sensitive operation at Swan, such as initiating a payment, require consent
"""
type Consent {
  """unique identifier of the consent"""
  id: ID!

  """`true` if the consent requires a Strong Customer Authentication"""
  requireSCA: Boolean!

  """status of the consent"""
  status: ConsentStatus!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime

  """date when the `consentUrl` was request the first time"""
  startedAt: DateTime

  """date when the consent expire"""
  expiredAt: DateTime

  """purpose of the consent"""
  purpose: ConsentPurpose!

  """Redirect the user to this URL to start the consent flow"""
  consentUrl: String!

  """When the consent flow is finished the user is redirected to this URL"""
  redirectUrl: String!

  """userId who initiated the consent"""
  userId: String!

  """user who initiated the consent"""
  user: User

  """unique hash of the consent"""
  challenge: String

  """date when the consent is accepted"""
  acceptedAt: DateTime

  """date when the consent is refused"""
  refusedAt: DateTime

  """date when the consent is canceled"""
  canceledAt: DateTime
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type ConsentConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ConsentEdge list"""
  edges: [ConsentEdge!]!
}

"""Implements the Relay Edge interface"""
type ConsentEdge implements Edge {
  """
  Opaque identifier pointing to this consent node in the pagination mechanism
  """
  cursor: String!

  """The consent"""
  node: Consent!
}

"""Consent ID with related execution order"""
input ConsentIdWithOrder {
  """
  Execution order. Consents are granted in ascending order. Consents with the same order may be granted in parallel.
  """
  order: Int! = 0

  """Consent ID"""
  consentId: String!
}

"""Rejection returned if a consent was not found"""
type ConsentNotFoundRejection implements Rejection {
  message: String!
  consentId: String!
}

"""Purpose of a consent"""
enum ConsentPurpose {
  """when accepting the partnership conditions"""
  AcceptPartnershipConditions

  """when inviting a new account membership"""
  AddAccountMembership

  """when adding several account memberships"""
  AddAccountMemberships

  """when adding a beneficiary"""
  AddBeneficiary

  """when adding a virtual card"""
  AddCard

  """when adding multiple cards"""
  AddCards

  """when adding a digital card"""
  AddDigitalCard

  """when activating a physical card"""
  ActivatePhysicalCard

  """when closing an account"""
  CloseAccount

  """when initiating a credit transfer"""
  InitPayment

  """when requesting to print physical card"""
  PrintPhysicalCard

  """when resuming an account membership"""
  ResumeAccountMembership

  """when resuming a physical card"""
  ResumePhysicalCard

  """when scheduling a standing order"""
  ScheduleStandingOrder

  """when updating an account membership"""
  UpdateAccountMembership

  """when updating a card"""
  UpdateCard

  """when updating a server consent project settings"""
  UpdateServerConsentProjectSettings

  """when viewing card confidential of a virtual card"""
  ViewCardNumbers

  """when requesting to view physical card PIN"""
  ViewPhysicalCardPin

  """when enabling a mandate"""
  EnableMandate

  """when adding a payment direct debit mandate"""
  AddDirectDebitPaymentMandate

  """when initiating a funding request"""
  InitiateFundingRequest

  """when initiating an instant funding request"""
  InitiateInstantFundingRequest

  """when initiating an international credit transfer"""
  InitiateInternationalCreditTransfer

  """when the consent is a multiple consent"""
  ConsentToMultipleConsents

  """when returning a transaction for direct debit"""
  ReturnTransactionForDirectDebit

  """when returning a transaction for international credit transfer"""
  ReturnTransactionForInternationalCreditTransfer
}

"""
Rejection returned when a the consent is already linked to another multi consent
"""
type ConsentsAlreadyLinkedToMultiConsentRejection implements Rejection {
  message: String!

  """IDs of the consents that are already linked to another multi consent"""
  consentIds: [String!]!
}

input ConsentsFiltersInput {
  userId: String
}

"""
Rejection returned when all provided consents are not in created status
"""
type ConsentsNotAllInCreatedStatusRejection implements Rejection {
  message: String!

  """IDs of the consents that are not in created status"""
  consentIds: [String!]!
}

"""Rejection returned when a consent ID passed as input does not exist."""
type ConsentsNotFoundRejection implements Rejection {
  message: String!
  ids: [String!]!
}

"""Status of a consent"""
enum ConsentStatus {
  """when the user accepted"""
  Accepted

  """when the user refused"""
  CustomerRefused

  """when the operation is committing"""
  OperationCommitting

  """
  when the user credentials were refused
  @deprecated this status has never been used and will be removed in the following months
  """
  CredentialRefused @deprecated

  """when the consent is created"""
  Created

  """when the consentUrl has been requested"""
  Started

  """when the consent is expired"""
  Expired

  """when something went wrong"""
  Failed

  """when the user or the project decided to cancel the consent"""
  Canceled
}

type ConsentTypeNotSupportedByServerConsentRejection implements Rejection {
  message: String!
}

"""Inputs to create a capital deposit case."""
input CreateCapitalDepositCaseInput {
  """
  Name ("Dénomination sociale") of the company being registered and for which the capital is being deposited.
  """
  companyName: String!

  """Array of shareholders of type company ("personne morale")."""
  companyShareholders: [OnboardCompanyShareholderInput]!

  """Array of shareholders of type individual ("personne physique")."""
  individualShareholders: [OnboardIndividualShareholderInput]!

  """Amount of the capital deposit."""
  totalCapitalDepositAmount: AmountInput!

  """Information required for the onboarding of a company."""
  onboardingCapitalDepositCompany: OnboardCompanyAccountHolderInput!
}

union CreateCapitalDepositCasePayload = CreateCapitalDepositCaseSuccessPayload | ForbiddenRejection | BadRequestRejection | ValidationRejection | InternalErrorRejection

type CreateCapitalDepositCaseSuccessPayload {
  capitalDepositCase: CapitalDepositCase!
}

input CreateMerchantPaymentLinkInput {
  """The Merchant Profile to link this Payment Link to"""
  merchantProfileId: ID!

  """Amount to be paid to sucessfully complete the payment."""
  amount: AmountInput!

  """
  Merchant Website URL to redirect the user to when the payment is completed.
  """
  redirectUrl: URL

  """URL to redirect the user to if they cancel their payment"""
  cancelRedirectUrl: URL

  """
  The customer billing Address
  These fields should be completed also to pre-fill a SEPA direct debit mandate.
  
  We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes
  """
  billingAddress: AddressInput

  """
  The date when the payment link expires.
  If not specified, the default time will be 120 days
  """
  expiresAt: DateTime

  """
  A date that reflects the time at which the user asked the transaction to be executed.
  For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
  For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
  
  Default value means that the execution will be as soon as possible
  """
  requestedExecutionAt: DateTime

  """
  Controls if the payment mandate created from this payment link is for one-time use or can be reused
  This is applicable for card and SEPA Direct Debit payment methods only.
  If not specified, the default value is OneOff.
  """
  sequence: PaymentMandateSequence

  """
  Any string that you want to be attached to this payment link.
  Usually something to help you reference the link in an external system.
  """
  externalReference: String

  """
  Optional field intended to provide a way for you to include a reference number or code.
  The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different.
  """
  reference: String

  """
  Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page.
  """
  label: String

  """
  The language used for the payment page.
  Default is the browser's language, or English if not available.
  """
  language: Language

  """
  We will use the information specified here to prefill the payment link fields
  depending on the payment method the end user chooses.
  Keep in mind that your end customer will be able to edit these fields.
  """
  customer: CustomerInput

  """
  List of payment methods enabled for this payment link.
  If the array is empty, Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit)
  If you want to make payment possible via SEPA Direct Debit, the list should be populated either by a SEPA Direct Debit CORE or B2B.
  """
  paymentMethodIds: [String!]
}

union CreateMerchantPaymentLinkPayload = CreateMerchantPaymentLinkSuccessPayload | MerchantProfileWrongStatusRejection | MerchantPaymentMethodNotActiveRejection | PaymentMethodNotCompatibleRejection | InternalErrorRejection | ForbiddenRejection | ValidationRejection

type CreateMerchantPaymentLinkSuccessPayload {
  merchantPaymentLink: MerchantPaymentLink!
}

"""Input of the `createMultiConsent` mutation"""
input CreateMultiConsentInput {
  """A list of consent IDs with their related execution orders"""
  orderedConsentIds: [ConsentIdWithOrder!]!

  """URL the user is redirected to after consent has been given"""
  redirectUrl: String!
}

"""Payload of the `createMultiConsent` mutation"""
union CreateMultiConsentPayload = CreateMultiConsentSuccessPayload | ConsentsNotAllInCreatedStatusRejection | ConsentsNotFoundRejection | TooManyChildConsentsRejection | ConsentsAlreadyLinkedToMultiConsentRejection

"""Success payload of the `createMultiConsent` mutation"""
type CreateMultiConsentSuccessPayload {
  consent: Consent
}

"""Credit transfer"""
input CreditTransferInput {
  """
  *SOON TO BE DEPRECATED*
  if the transfer will credit a beneficiary already created
  """
  beneficiaryId: ID

  """if the transfer will credit a new swan account beneficiary"""
  swanAccountBeneficiary: SwanAccountBeneficiaryInput

  """if the transfer will credit a new SEPA beneficiary"""
  sepaBeneficiary: SepaBeneficiaryInput

  """amount of the transfer"""
  amount: AmountInput!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain (regex [a-zA-Z0-9-?.+,/':() ]{1,35} and cannot begin nor end with /. Also, // is not allowed)
  """
  reference: String

  """label (max 140 characters)"""
  label: String

  """
  requested date at which the credit transfer will try to be executed, if `null` the credit transfer is executed right away
  """
  requestedExecutionAt: DateTime

  """
  an arbitrary identifier that you can define to easily identify this transaction later
  """
  externalReference: String

  """
  if the transfer will execute as instant and fallbacked to a regular one if an error happend during the instant transfer
  """
  mode: CreditTransferMode

  """
  * COMING SOON *
  if the transfer will credit an existing beneficiary
  """
  trustedBeneficiaryId: ID
}

enum CreditTransferMode {
  InstantWithoutFallback
  InstantWithFallback
  Regular
}

"""Custom information for a CSV statement"""
type CsvStatement implements StatementInfo {
  """statement type"""
  type: StatementType

  """temporary public url on which the file can be accessed"""
  url: String

  """date at which the link will not be useable anymore"""
  expiresAt: DateTime
}

"""currency code alpha 3 (ISO 4217)"""
scalar Currency

type Customer {
  """
  A customer id present in a third-party system.
  Alows to link a customer to a payment link and by extension, to a Merchant Payment.
  """
  externalCustomerId: String
  name: String
  iban: String
}

input CustomerInput {
  """
  A customer ID present in a third-party system.
  Alows to link a customer to a payment link and by extension, to a merchant payment.
  """
  externalCustomerId: String

  """Customer name"""
  name: String

  """Customer IBAN"""
  iban: String
}

"""Date with YYYY-MM-DD format"""
scalar Date

type DateField implements Field {
  example: String
  key: String!
  name: String!
  required: Boolean!
  validationRegex: String
}

"""
Date time (ISO 8601 with time information)
ex: 2021-04-12T16:28:22.867Z
"""
scalar DateTime

input DeactivateUserInput {
  """ID of the user to deactivate"""
  userId: ID!
}

union DeactivateUserPayload = DeactivateUserSuccess | UserCannotBeDeactivatedRejection | UserAlreadyDeactivatedRejection | UserNotFoundRejection

type DeactivateUserSuccess {
  user: User!
}

"""Rejection returned when the Debtor is closed"""
type DebtorAccountClosedRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the Debtor does not belong to the same project as the creditor
"""
type DebtorAccountNotAllowedRejection implements Rejection {
  message: String!
}

"""Input for the `deleteExportFile` mutation."""
input DeleteExportFileInput {
  """
  The `exportId` generated by a previous call to any export mutation.
  
  NB: The export needs to be completed for the file to be deleted.
  """
  exportId: String!
}

union DeleteExportFilePayload = DeleteExportFileSuccessPayload | UnknownExportRejection | StillExportingRejection

"""Payload of the `deleteExportFile` mutation in case of success."""
type DeleteExportFileSuccessPayload {
  """The exportId of the deleted file."""
  exportId: String!
}

input DeleteSupportingDocumentInput {
  """Id of the supporting document to delete"""
  id: ID!
}

union DeleteSupportingDocumentPayload = DeleteSupportingDocumentSuccessPayload | ForbiddenRejection | InternalErrorRejection | SupportingDocumentCollectionNotFoundRejection | SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection | SupportingDocumentNotFoundRejection | SupportingDocumentStatusDoesNotAllowDeletionRejection | ValidationRejection

type DeleteSupportingDocumentSuccessPayload {
  id: String!
}

input DenySddInput {
  accountId: ID!
}

union DenySddPayload = DenySddSuccessPayload | BadAccountStatusRejection | AccountNotFoundRejection | InvalidArgumentRejection | ValidationRejection

type DenySddSuccessPayload {
  account: Account!
}

input DenySddVirtualIbanEntryInput {
  ibanEntryId: ID!
}

union DenySddVirtualIbanEntryPayload = DenySddVirtualIbanEntrySuccessPayload | BadAccountStatusRejection | ValidationRejection

type DenySddVirtualIbanEntrySuccessPayload {
  virtualIbanEntry: VirtualIBANEntry!
}

"""Device"""
type Device {
  """The type of device. It can be a Phone, Tablet, Watch"""
  type: String

  """
  Device name
  End user defined name of the device on which the card id provided
  """
  name: String

  """Secure Element ID"""
  SEID: String
}

"""Digital Card used for ApplePay or GooglePay"""
interface DigitalCard {
  """Unique identifier of a digital card"""
  id: ID!

  """The type of digitalization that created this digital card."""
  type: DigitalizationType!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Wallet Provider (ApplePay, GooglePay ...)"""
  walletProvider: WalletProvider!

  """The project ID"""
  projectId: ID!

  """The card contract ID"""
  cardContractId: ID!
}

"""Digital Card Canceled Status Information"""
type DigitalCardCanceledStatusInfo implements CompleteDigitalCardStatusInfo {
  """Card status (always Canceled for type DigitalCardCanceledStatusInfo)."""
  status: CompleteDigitalCardStatus!

  """Enable Date"""
  enabledAt: DateTime!

  """Cancel Date"""
  canceledAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type DigitalCardConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """CardEdge list"""
  edges: [DigitalCardEdge!]!
}

"""Digital Card ConsentPending Status Information"""
type DigitalCardConsentPendingStatusInfo implements PendingDigitalCardStatusInfo {
  """
  Digital Card status (always ConsentPending for type DigitalCardConsentPendingStatusInfo).
  """
  status: PendingDigitalCardStatus!

  """A reference to the consent to validate"""
  consent: Consent!
}

"""Digital Card Declined Status Information"""
type DigitalCardDeclinedStatusInfo implements PendingDigitalCardStatusInfo {
  """
  Digital Card status (always Declined for type DigitalCardDeclinedStatusInfo).
  """
  status: PendingDigitalCardStatus!
}

"""Implements the Relay Edge interface"""
type DigitalCardEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The Card entry"""
  node: DigitalCard!
}

"""Digital Card Enabled Status Information"""
type DigitalCardEnabledStatusInfo implements CompleteDigitalCardStatusInfo {
  """
  Digital Card status (always Enabled for type DigitalCardEnabledStatusInfo).
  """
  status: CompleteDigitalCardStatus!

  """Enable Date"""
  enabledAt: DateTime!
}

"""Filters that can be applied when listing digitalCards"""
input DigitalCardFiltersInput {
  """The id of the digitalCard"""
  id: String

  """
  The status of the digital card. It can be a CompleteDigitalCardStatus or a PendingDigitalCardStatus
  """
  status: String

  """
  The Secure Element ID
  Mostly present on APple Devices
  """
  SEID: String

  """The digital card masker number"""
  cardMaskedNumber: String

  """The ID of the wallet provider in the scheme system"""
  walletProviderId: String

  """Either ApplePay, GooglePay or Merchant"""
  walletProviderName: String

  """The wallet application ID in the user phone"""
  walletId: String
}

"""Rejection returned when the Digital Card does not exist"""
type DigitalCardNotFoundRejection implements Rejection {
  message: String!
  identifier: String!
}

"""
Field we can use when ordering that can be applied when listing digital cards
"""
enum DigitalCardOrderByFieldInput {
  id
  createdAt
  updatedAt
}

"""Order that can be applied when listing digital cards"""
input DigitalCardOrderByInput {
  field: DigitalCardOrderByFieldInput
  direction: OrderByDirection
}

"""Digital Card Pending Status Information"""
type DigitalCardPendingStatusInfo implements PendingDigitalCardStatusInfo {
  """
  Digital Card status (always Pending for type DigitalCardPendingStatusInfo).
  """
  status: PendingDigitalCardStatus!
}

"""Digital Card Suspended Status Information"""
type DigitalCardSuspendedStatusInfo implements CompleteDigitalCardStatusInfo {
  """
  Digital Card status (always Suspended for type DigitalCardSuspendedStatusInfo).
  """
  status: CompleteDigitalCardStatus!

  """Enable Date"""
  enabledAt: DateTime!

  """Suspend Date"""
  suspendedAt: DateTime!
}

"""Digitalization Type"""
enum DigitalizationType {
  """
  This digital card was created by direct input of the PAN into a wallet application
  
  This direct input can also be done using the device camera
  """
  Manual

  """
  This digital card was created based on a PAN stored into a merchant application (ex: iTunes)
  """
  CardOnFile

  """This digital card was created by an in app provisioning"""
  InApp

  """We could not get the source of the digitalization"""
  Unknown
}

"""Direct Debit Account Verification"""
type DirectDebitAccountVerification implements AccountVerification {
  """Creation date of the account verification"""
  createdAt: DateTime!

  """IBAN of the account to cross check with account holder information"""
  iban: IBAN!

  """Unique identifier of the Account Verification"""
  id: ID!

  """Account Verification Status Information"""
  statusInfo: AccountVerificationStatusInfo!

  """Last update date of the account verification"""
  updatedAt: DateTime!
}

"""Funding Source with Direct Debit Mandate"""
type DirectDebitFundingSource implements FundingSource {
  """ID of the Funding Source"""
  id: ID!

  """Name of the Funding Source"""
  name: String

  """Funding Source status information"""
  statusInfo: FundingSourceStatusInfo!

  """
  IBAN to use in the direct debit transaction that will be triggered when funding the account.
  Money will be debited from this IBAN when an `initiateFundingRequest` is done using this funding source
  """
  iban: IBAN!

  """Created date"""
  createdAt: DateTime!

  """Last updated date"""
  updatedAt: DateTime!

  """
  Can be queried to check the status of the account verification for this funding source.
  If the account verification is PendingVerification, you should ask your account holder to wire some money from his external account to any swan account
  """
  accountVerification: DirectDebitAccountVerification!

  """
  Can be queried to check the status of payment payment Mandate.
  If the payment mandate is ConsentPending, you should confirm it to enable this funding source
  """
  paymentMandate: PaymentDirectDebitMandate!
}

enum DirectDebitSequence {
  OneOff
  Recurrent
}

"""Input to disable an account membership"""
input DisableAccountMembershipInput {
  """Unique identifier of the account membership to disable"""
  accountMembershipId: ID!
}

union DisableAccountMembershipPayload = DisableAccountMembershipSuccessPayload | AccountMembershipCannotBeDisabledRejection | AccountMembershipNotFoundRejection | ForbiddenRejection | InternalErrorRejection | LegalRepresentativeAccountMembershipCannotBeDisabledRejection | UserNotAllowedToDisableItsOwnAccountMembershipRejection | ValidationRejection

type DisableAccountMembershipSuccessPayload {
  accountMembership: AccountMembership
}

"""StatusInfo when funding limit settings has been disabled"""
type DisabledFundingLimitSettingsStatusInfo implements FundingLimitSettingsStatusInfo {
  status: FundingLimitSettingsStatus!
  reason: String!
}

"""EnabledMerchantPaymentMethodStatusInfo"""
type DisabledMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method disabled date"""
  disabledAt: Date!
}

"""DisabledMerchantProfileStatusInfo"""
type DisabledMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  disabledAt: Date!
}

input DisableMerchantPaymentMethodInput {
  """ID of the merchant payment method to disable"""
  merchantPaymentMethodId: ID!
}

union DisableMerchantPaymentMethodPayload = DisableMerchantPaymentMethodSuccessPayload | ForbiddenRejection | InternalErrorRejection | NotFoundRejection | MerchantPaymentMethodWrongStatusRejection

type DisableMerchantPaymentMethodSuccessPayload {
  """Merchant Payment Method ID"""
  merchantPaymentMethodId: ID!
}

input DisableMerchantProfileInput {
  """ID of the merchant profile to disable"""
  merchantProfileId: ID!
}

union DisableMerchantProfilePayload = DisableMerchantProfileSuccessPayload | ForbiddenRejection | InternalErrorRejection | NotFoundRejection

type DisableMerchantProfileSuccessPayload {
  """Merchant Profile"""
  merchantProfile: MerchantProfile!
}

"""Rejection returned if the document cannot be found"""
type DocumentCanNotBeFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Rejection returned if the document cannot be rejected"""
type DocumentCanNotBeRejectedRejection implements Rejection {
  id: String!
  message: String!
}

"""Retrieved document extracted from the identity verification"""
interface DocumentFile {
  downloadUrl: String!
}

"""From which side the document picture was taken"""
enum DocumentFileSide {
  SideA
  SideB
  BothSides
  Unknown
}

"""Rejection returned if the document-parent link is missing"""
type DocumentParentLinkMissingRejection implements Rejection {
  id: String!
  message: String!
}

"""Reason code of the document."""
enum DocumentReasonCode {
  """Company name in document doesn’t match our records"""
  CompanyNameMismatch

  """Declared amount in document doesn’t match the amount received"""
  DeclaredAmountMismatch

  """Document must be dated less than 3 months ago"""
  ExpiredDocument

  """Address in document doesn’t match our records"""
  InvalidAddress

  """Default value when none of the other values is appropriate"""
  InvalidDocument

  """Some information is missing"""
  InvalidOrMissingData

  """Missing identity document of accommodation provider"""
  MissingAccommodationProviderId

  """
  Missing identity document and proof of accommodation from accommodation provider
  """
  MissingAccommodationProviderIdLetter

  """Missing proof of accommodation from accommodation provider"""
  MissingAccommodationProviderLetter

  """Document cannot be accepted for the requested document type"""
  UnacceptableDocument

  """Accommodation provider's identity document must be in full color"""
  ProviderColorIdDocumentRequired

  """
  Document must be signed, either by hand or electronically with certification
  """
  MissingSignature

  """Document is damaged or in poor condition"""
  BadDocumentQuality

  """Only part of the document was provided"""
  FullDocumentRequired

  """Missing accommodation provider's proof of address"""
  MissingProviderProofOfAddress

  """Missing accommodation provider's proof of address and ID document"""
  MissingProviderProofOfAddressAndIdDocument

  """Power of attorney must be provided to Swan"""
  PowerOfAttorneyToSwanRequired

  """Missing company domiciliation statement"""
  MissingCompanyDomiciliationStatement

  """The signature is not handwritten or electronically certified"""
  HandwrittenOrCertifiedElectronicSignatureRequired
}

"""The type of the document"""
enum DocumentType {
  IdCard
  Passport
  ResidencePermit
  DriversLicense
  Face
  Report
}

"""The document corresponding to a driver's license"""
type DriversLicenseDocument {
  """Unique identifier of the driver's license document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """List of the associated files"""
  files: [DriversLicenseDocumentFile!]!
}

"""The file associated to the driver's license document"""
type DriversLicenseDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!

  """From which side the deiver's license's picture was taken"""
  side: DocumentFileSide!
}

"""
Edge type containing the node and cursor. The node is not defined in the interface because generic is not supported by GraphQL
but all implementation contains its own node property according to the paginated type.
"""
interface Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

scalar EmailAddress

"""Employment status."""
enum EmploymentStatus {
  Craftsman
  Employee
  Entrepreneur
  Farmer
  Manager
  Practitioner
  Retiree
  ShopOwner
  Student
  Unemployed
}

"""
Rejection returned if the card product don't have a card design enabled
"""
type EnabledCardDesignNotFoundRejection implements Rejection {
  message: String!
}

"""StatusInfo when the funding limit settings is enabled"""
type EnabledFundingLimitSettingsStatusInfo implements FundingLimitSettingsStatusInfo {
  status: FundingLimitSettingsStatus!
}

"""Funding Source Enabled status information"""
type EnabledFundingSourceStatusInfo implements FundingSourceStatusInfo {
  """Funding Source Enabled status"""
  status: FundingSourceStatus!

  """Date at which the funding source was enabled"""
  enabledAt: Date!
}

"""EnabledMerchantPaymentMethodStatusInfo"""
type EnabledMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method enabled date"""
  enabledAt: Date!
}

"""EnabledMerchantProfileStatusInfo"""
type EnabledMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  enabledAt: Date!
}

"""
Inputs to enable a received direct debit mandate, i.e. to move its status back from suspended.
"""
input EnableReceivedDirectDebitMandateInput {
  """The received direct debit id to enable"""
  receivedDirectDebitMandateId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String
}

"""Union type return by the enableReceivedDirectDebitMandate mutation"""
union EnableReceivedDirectDebitMandatePayload = EnableReceivedDirectDebitMandateSuccessPayload | ReceivedDirectDebitMandateNotFoundRejection | ReceivedDirectDebitMandateCanceledRejection | ForbiddenRejection

"""
Return type in case of a successful response of the enableReceivedDirectDebitMandate mutation
"""
type EnableReceivedDirectDebitMandateSuccessPayload {
  """
  The received direct debit mandate is enable, i.e that it is moved back to from the suspended to the enabled status
  """
  receivedDirectDebitMandate: ReceivedDirectDebitMandate!
}

type EnrichedTransactionInfo {
  """Well formatted merchant name"""
  enrichedMerchantName: String

  """URL of the merchant logo"""
  logoUrl: String

  """Merchant category"""
  category: MerchantCategory

  """Merchant subcategory"""
  subcategory: MerchantSubCategory

  """Merchant country"""
  country: CCA3

  """Merchant city"""
  city: String

  """Merchant address"""
  address: String

  """Merchant location longitude"""
  longitude: String

  """Merchant location latitude"""
  latitude: String

  """Merchant postal code"""
  postalCode: String

  """Is merchant a subcription"""
  isSubscription: Boolean

  """Transaction carbon footprint in micrograms of CO2 emitted"""
  carbonFootprint: String

  """Merchant email"""
  contactEmail: String

  """Merchant phone"""
  contactPhone: String

  """Merchant website"""
  contactWebsite: String
}

enum EnvType {
  Live
  Sandbox
}

type EventTypeHavingReachedSubscriptionLimits {
  eventType: String!
  subscriptionCount: Int!
}

"""
Describes an identification level for the process associated to this identification that has expired and is no longer considered valid
"""
type ExpiredIdentificationLevelStatusInfo {
  """Always set to `Expired`"""
  status: SwanIdentificationStatus!

  """When this identification level expired"""
  expiredAt: Date!
}

type ExpiredMerchantPaymentLinkStatusInfo implements MerchantPaymentLinkStatusInfo {
  status: MerchantPaymentLinkStatus!

  """
  The date when the payment link expired.
  By default the payment link expires 120 days after it was created.
  """
  expiredAt: DateTime!
}

type ExpiredTransactionStatementStatusInfo implements TransactionStatementStatusInfo {
  """status of the transaction statement"""
  status: TransactionStatementStatusEnum!

  """date at which the document expired"""
  expiredAt: DateTime!
}

"""
An export is the process of exporting a collection of entities from a project
"""
type Export {
  """Unique identifier of an export"""
  id: ID!

  """Type of data exported"""
  type: ExportType!

  """Status information of an export"""
  statusInfo: ExportStatusInfo!

  """Created date"""
  createdAt: DateTime!
}

"""Export Completed Status Information"""
type ExportCompletedStatusInfo implements ExportStatusInfo {
  """Status of the export."""
  status: ExportStatus!
}

"""
Implements the Relay Connection interface, used to paginate list of elements ([Learn More](https://docs.swan.io/api/pagination))
"""
type ExportConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ExportEdge list"""
  edges: [ExportEdge!]!
}

union ExportDataPayload = ExportDataSuccessPayload | MaximumSimultaneousExportsRejection | MaximumDailyExportsReachedRejection | ValidationRejection

"""Payload of any export mutation in case of success."""
type ExportDataSuccessPayload {
  """
  The unique identifier of the data export process running on our end.
  
  Used to generate a temporary download link when the process is completed.
  """
  exportId: String!
}

"""Implements the Relay Edge interface"""
type ExportEdge implements Edge {
  """
  Opaque identifier pointing to this export node in the pagination mechanism
  """
  cursor: String!

  """The export"""
  node: Export!
}

"""Export Expired Status Information"""
type ExportExpiredStatusInfo implements ExportStatusInfo {
  """Status of the export."""
  status: ExportStatus!
}

"""Export Failed Status Information"""
type ExportFailedStatusInfo implements ExportStatusInfo {
  """Status of the export."""
  status: ExportStatus!
}

input ExportFilterInput {
  """
  Filter to only retrieve exports of these types
  Defaults to all types indiscriminately
  """
  exportTypes: [ExportType!]

  """
  Lower bound to retrieve exports created after this moment
  Defaults to no bound
  """
  isAfterCreatedAt: DateTime

  """
  Upper bound to retrieve exports created before this moment
  Defaults to no bound
  """
  isBeforeCreatedAt: DateTime

  """
  Filter to only retrieve exports with these statuses
  Defaults to ally statuses indiscriminately
  """
  statuses: [ExportStatus!]
}

"""Input filters for the `exportOnboardingData` mutation."""
input ExportOnboardingDataFilters {
  """can be a partial email """
  email: String

  """Possible values for onboarding status."""
  status: [OnboardingStatus!]

  """Possible account holder type."""
  types: [AccountHolderType!]
}

"""Input for the `exportOnboardingData` mutation."""
input ExportOnboardingDataInput {
  """
  The email address that will receive a notification when the export is completed.
  """
  email: String!

  """
  The email address that will receive a notification when the export is completed.
  """
  filters: ExportOnboardingDataFilters
}

"""Export Running Status Information"""
type ExportRunningStatusInfo implements ExportStatusInfo {
  """Status of the export."""
  status: ExportStatus!
}

"""The status of any given export"""
enum ExportStatus {
  Running
  Failed
  Completed
  Expired
}

"""Export Status Information"""
interface ExportStatusInfo {
  """Status of the export."""
  status: ExportStatus!
}

"""The type of data exported for any given export"""
enum ExportType {
  Users
  Onboardings
}

"""Input for the `exportUserData` mutation."""
input ExportUserDataInput {
  """
  The email address that will receive a notification when the export is completed.
  """
  email: String!
}

type ExternalAccount {
  """Unique identifier of an external account"""
  id: ID!

  """External account identifier following ISO-20022 standard"""
  externalId: String!

  """Name of the account"""
  name: String

  """Type of the account"""
  cashAccountType: CashAccountType!

  """Bank Identifier Code"""
  BIC: BIC!

  """International Bank Account Number"""
  IBAN: IBAN!

  """Currency"""
  currency: Currency!

  """Account Holder name"""
  holderName: String!

  """Country"""
  country: CCA3!

  """Original Created date"""
  originalCreatedAt: DateTime!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  A list of balances regarding an external account.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  balances(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 90

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String
  ): ExternalBalanceConnection!

  """Source used for this account"""
  source: ExternalAccountDataSource!

  """Financial institution"""
  institution: FinancialInstitution

  """Usage information of the account"""
  usage: ExternalAccountUsage!

  """Account holder for the external account"""
  accountHolder: AccountHolder
}

type ExternalAccountAlreadyExistsRejection implements Rejection {
  iban: String!
  accountHolderId: String!
  message: String!
}

type ExternalAccountBalance {
  """Unique identifier of an external balance"""
  id: ID!

  """Amount with currency"""
  amount: Amount

  """Type of Balance"""
  type: ExternalAccountBalanceType!

  """Last changed Date"""
  lastChangedAt: DateTime!
}

type ExternalAccountBalanceAlreadyExistsRejection implements Rejection {
  type: ExternalAccountBalanceType!
  lastChangedAt: DateTime!
  message: String!
}

input ExternalAccountBalanceInput {
  """Amount with currency"""
  amount: AmountInput!

  """Type of Balance"""
  type: ExternalAccountBalanceType!

  """Last changed Date"""
  lastChangedAt: DateTime!
}

enum ExternalAccountBalanceType {
  """
  Balance of the account at the end of the pre-agreed account reporting period
  """
  ClosingBooked

  """
  Balance of the account at the previously closed account reporting period
  """
  PreviouslyClosedBooked

  """
  Available balance calculated in the course of the account servicer's business day, at the time specified, and subject to further changes during the business day
  """
  InterimAvailable

  """
  Balance composed of booked entries and pending items known at the time of calculation
  """
  Expected

  """Value-date balance"""
  ValueDate

  """Other balance"""
  Other
}

"""
Implements the Relay Connection interface, used to paginate the list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type ExternalAccountConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ExternalAccountEdge list"""
  edges: [ExternalAccountEdge!]!
}

type ExternalAccountDataSource {
  type: ExternalAccountDataSourceType!
  name: String!
}

enum ExternalAccountDataSourceType {
  """When manually added by the partner"""
  Push
}

"""Implements the Relay Edge interface"""
type ExternalAccountEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The external account"""
  node: ExternalAccount!
}

enum ExternalAccountUsage {
  Private
  Association
  Organization
  Unknown
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type ExternalBalanceConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ExternalBalanceEdge list"""
  edges: [ExternalBalanceEdge!]!
}

"""Implements the Relay Edge interface"""
type ExternalBalanceEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The external balance"""
  node: ExternalAccountBalance!
}

type ExternalCard {
  """The card scheme"""
  scheme: CardPaymentMandateScheme!

  """The local card scheme"""
  localScheme: CardPaymentMandateScheme

  """deprecated: The card type"""
  cardType: CardPaymentMandateType @deprecated(reason: "The cardType field is deprecated, use the type field instead")

  """The card type"""
  type: CardPaymentMandateType

  """The card category"""
  category: CardPaymentMandateCategory

  """The card's bank country"""
  country: CCA2

  """The card's last digits"""
  lastDigits: String!

  """The card's first 6 digits - Bank Identification Number"""
  bin: String!

  """The card's expiry date"""
  expiryDate: String
}

"""The document corresponding to a face photo"""
type FacePhotoDocument {
  """
  Unique identifier of the face photo document. For privacy reasons, no temporary download url is exposed for this document
  """
  id: String!

  """The type of the document"""
  type: DocumentType!
}

type FailedThreeDs {
  status: ThreeDsStatus!
  reason: String!
  code: String!
}

type FailedTransactionStatementStatusInfo implements TransactionStatementStatusInfo {
  """status of the transaction statement"""
  status: TransactionStatementStatusEnum!

  """reason of the failure"""
  reason: String
}

"""Fee creditor"""
interface FeeCreditor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

interface FeeDebtor {
  """full name of the debtor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Fee creditor for Incoming transaction"""
type FeeInCreditor implements FeeCreditor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Fee debtor for Incoming transaction"""
type FeeInDebtor implements FeeDebtor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Fee creditor for Outgoing transaction"""
type FeeOutCreditor implements FeeCreditor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Fee debtor for Outgoing transaction"""
type FeeOutDebtor implements FeeDebtor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

type FeeSettingsNotFoundRejection implements Rejection {
  message: String!
}

"""Fees type"""
enum FeesTypeEnum {
  """Other banking fee"""
  BankingFee

  """Online payment made with card issued by American Express"""
  CardAcquiringAmex

  """Chargeback on an online card payment"""
  CardAcquiringChargeback

  """Online payment made with a consumer card issued by Cartes Bancaires"""
  CardAcquiringConsumerCB

  """Online payment made with a commercial card issued by Cartes Bancaires"""
  CardAcquiringCommercialCB

  """
  Online payment made with a commercial card within the European Economic Area
  """
  CardAcquiringCommercialWithinEEA

  """
  Online payment made with a consumer card within the European Economic Area
  """
  CardAcquiringConsumerWithinEEA

  """
  Online payment made with a consumer card issued by Visa or Mastercard within the European Economic Area
  """
  CardAcquiringConsumerVisaMcWithinEEA

  """
  Online payment made with a commercial card issued by Visa or Mastercard within the European Economic Area
  """
  CardAcquiringCommercialVisaMcWithinEEA

  """
  Online payment made with a consumer card issued by Visa or Mastercard outside the European Economic Area
  """
  CardAcquiringConsumerVisaMcOutsideEEA

  """
  Online payment made with a commercial card issued by Visa or Mastercard outside the European Economic Area
  """
  CardAcquiringCommercialVisaMcOutsideEEA

  """
  Online payment made with a consumer or commercial card issued outside the European Economic Area
  """
  CardAcquiringOutsideEEA

  """Card transaction in foreign currency"""
  CardPaymentsOutsideSEPA

  """Cash withdrawal in foreign currency"""
  CashWithdrawalsOutsideSEPA

  """Cash withdrawal"""
  CashWithdrawalsWithinSEPA

  """Deposit of a physical check"""
  CheckDeposit

  """Rejection or return of a physical check"""
  CheckIncident

  """Drafting circulation letter"""
  CirculationLetterDraftingFee

  """Drafting Confirmation letter"""
  ConfirmationLetterDraftingFee

  """Direct debit rejection"""
  DirectDebitRejection

  """
  Incoming credit transfers not denominated and executed in euros on group 1 currencies
  """
  InternationalCreditTransferInGroup1

  """
  Incoming credit transfers not denominated and executed in euros on group 2 currencies
  """
  InternationalCreditTransferInGroup2

  """
  Incoming credit transfers not denominated and executed in euros on group 3 currencies
  """
  InternationalCreditTransferInGroup3

  """
  Incoming credit transfers not denominated and executed in euros on group 4 currencies
  """
  InternationalCreditTransferInGroup4

  """
  Outgoing credit transfers not denominated and executed in euros on group 1 currencies
  """
  InternationalCreditTransferOutGroup1

  """
  Outgoing credit transfers not denominated and executed in euros on group 2 currencies
  """
  InternationalCreditTransferOutGroup2

  """
  Outgoing credit transfers not denominated and executed in euros on group 3 currencies
  """
  InternationalCreditTransferOutGroup3

  """
  Outgoing credit transfers not denominated and executed in euros on group 4 currencies
  """
  InternationalCreditTransferOutGroup4

  """Outgoing credit transfers via SWIFT executed in euros"""
  InternationalCreditTransferOutSwiftGroup1

  """Improper use of account"""
  ImproperUseOfAccount

  """Delivery of physical cards with an express delivery provider"""
  PhysicalCardDeliveryExpress

  """Delivery of physical cards within France"""
  PhysicalCardDeliveryFrance

  """Delivery of physical cards outside of France"""
  PhysicalCardDeliveryIntl

  """Delivery of physical cards within Spain"""
  PhysicalCardDeliverySpain

  """Process of printing physical cards"""
  PhysicalCardPrinting

  """Processing judicial or administrative seizure"""
  ProcessingJudicialOrAdministrativeSeizure

  """B2B SEPA Direct Debit up to 200€"""
  SepaDirectDebitInB2bLevel1

  """B2B SEPA Direct Debit more than 200€"""
  SepaDirectDebitInB2bLevel2

  """Core SEPA Direct Debit up to 200€"""
  SepaDirectDebitInCoreLevel1

  """Core SEPA Direct Debit more than 200€"""
  SepaDirectDebitInCoreLevel2

  """Return of a Core SEPA Direct Debit"""
  SepaDirectDebitInCoreReturn

  """Unauthorized overdraft"""
  UnauthorizedOverdraft

  """Monthly account subscription fee"""
  BusinessAccountSubscription

  """Monthly account subscription fee"""
  IndividualAccountSubscription

  """Monthly account membership subscription fee"""
  AccountMembershipSubscription

  """Monthly card subscription fee"""
  VirtualCardSubscription

  """Fee for sending or receiving a SEPA Credit Transfer"""
  SepaCreditTransferIn

  """Fee for sending or receiving a SEPA Credit Transfer"""
  SepaCreditTransferOut

  """SEPA creditor identifier request"""
  SepaCreditorIdentifierRequest

  """Fee for sending or receiving a SEPA Instant Credit Transfer"""
  InstantSepaCreditTransferIn

  """Fee for sending or receiving a SEPA Instant Credit Transfer"""
  InstantSepaCreditTransferOut

  """Fee for sending or receiving a SEPA Direct Debit"""
  SepaDirectDebitIn

  """Fee for sending or receiving a SEPA Direct Debit"""
  SepaDirectDebitOut

  """Fee for creating and enabling a single-use virtual card"""
  SingleUseVirtualCard

  """Fee for sending a card transaction"""
  CardTransaction
}

"""Fee Transaction"""
type FeeTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!
  supportingDocumentCollections(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: SupportingDocumentCollectionFilterInput
  ): SupportingDocumentCollectionConnection!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire reference chain.
  """
  reference: String!

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """feesType"""
  feesType: FeesTypeEnum!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """creditor information"""
  creditor: FeeCreditor!

  """debtor information"""
  debtor: FeeDebtor!

  """matching account for the transaction"""
  account: Account

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """true if a transaction statement can be generated for this transaction"""
  statementCanBeGenerated: Boolean

  """project id of the transaction"""
  projectId: ID!
}

interface Field {
  key: String!
  name: String!
  required: Boolean!
}

enum FieldValidationError {
  Missing
}

input FinalizeOnboardingInput {
  onboardingId: String!
}

union FinalizeOnboardingPayload = FinalizeOnboardingSuccessPayload | InternalErrorRejection | ForbiddenRejection | OnboardingNotCompletedRejection | ValidationRejection

type FinalizeOnboardingSuccessPayload {
  onboarding: Onboarding!
}

type FinancialInstitution {
  id: ID!
  name: String!
  country: CCA3!
}

enum FnciColorCode {
  """
  The check doesn't match any fraudulent record from the FNCI (Fichier National des Chèques Impayés).
  """
  Green

  """
  The check matches fraudulent records from the FNCI (Fichier National des Chèques Impayés).
  """
  Orange

  """
  The check matches fraudulent records from the FNCI (Fichier National des Chèques Impayés).
  """
  Red

  """
  The check matches fraudulent records from the FNCI (Fichier National des Chèques Impayés).
  """
  White
}

type FnciInfo {
  colorCode: FnciColorCode!
  cpt1: Int!
  cpt2: Int!
  cpt3: Int!
  holderEstablishment: String!
  responseCode: Int!
}

type ForbiddenRejection implements Rejection {
  message: String!
}

type FundingLimit {
  """Maximum Funding Amount authorized"""
  amount: Amount!

  """Funding Amount that has already been used during the interval"""
  funding: Amount

  """Interval in number of calendar days where the limit is applied"""
  rollingDays: Int!
}

"""Funding Limit Amount"""
type FundingLimitAmount {
  """The amount settings"""
  amount: Amount!
}

"""Funding Limit Amount Input"""
input FundingLimitAmountInput {
  """The amount settings"""
  amount: AmountInput!
}

"""Rejection returned when the Account Holder Funding has been exceeded"""
type FundingLimitExceededRejection implements Rejection {
  message: String!
}

type FundingLimitSettings {
  """Instant funding limit"""
  instantFundingLimit: InstantFundingLimit

  """Periodic funding limit"""
  fundingLimit: FundingLimit

  """Related change request"""
  fundingLimitSettingsChangeRequest: FundingLimitSettingsChangeRequest

  """Status of the resource"""
  statusInfo: FundingLimitSettingsStatusInfo!
}

"""Funding Limit Settings Change Request"""
type FundingLimitSettingsChangeRequest {
  """Unique identifier of a funding limit settings change request"""
  id: ID!

  """Requested amount settings for the instant funding limit"""
  instantFundingLimit: FundingLimitAmount!

  """Requested amount settings for the funding limit"""
  fundingLimit: FundingLimitAmount!

  """
  Approved amount settings for the the instant funding limit and the funding limit
  """
  approved: ApprovedFundingLimit

  """Status of the request"""
  statusInfo: FundingLimitSettingsChangeRequestStatusInfo!

  """Date of creation"""
  createdAt: Date

  """Date of last update"""
  updatedAt: Date
}

"""
StatusInfo when funding limit settings change request has been approved
"""
type FundingLimitSettingsChangeRequestApprovedStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
  reason: String!
}

"""Funding Limit Settings Change Request Bad Amount Rejection"""
type FundingLimitSettingsChangeRequestBadAmountRejection implements Rejection {
  message: String!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type FundingLimitSettingsChangeRequestConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """FundingLimitSettingsChangeRequestEdge list"""
  edges: [FundingLimitSettingsChangeRequestEdge!]!
}

"""Implements the Relay Edge interface"""
type FundingLimitSettingsChangeRequestEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The FundingLimitSettingsChangeRequest"""
  node: FundingLimitSettingsChangeRequest!
}

"""
Filters that can be applied when listing funding limit settings change requests
"""
input FundingLimitSettingsChangeRequestFiltersInput {
  """Filter by IDs"""
  id: [String!]

  """Filter by status"""
  status: [FundingLimitSettingsChangeRequestStatus!]
}

"""
Field we can use when ordering that can be applied when listing funding limit settings change requests
"""
enum FundingLimitSettingsChangeRequestOrderByFieldInput {
  id
  createdAt
  updatedAt
}

"""
Order that can be applied when listing funding limit settings change requests
"""
input FundingLimitSettingsChangeRequestOrderByInput {
  field: FundingLimitSettingsChangeRequestOrderByFieldInput
  direction: OrderByDirection
}

"""StatusInfo when funding limit settings change request is pending"""
type FundingLimitSettingsChangeRequestPendingStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
}

"""
StatusInfo when funding limit settings change request has been rejected
"""
type FundingLimitSettingsChangeRequestRefusedStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
  reason: String!
}

"""Funding Limit Settings Change Request Status"""
enum FundingLimitSettingsChangeRequestStatus {
  """When the request is in waiting for information"""
  WaitingForInformation

  """When the request is in pending"""
  Pending

  """When the request is approved"""
  Approved

  """When the request is refused"""
  Refused
}

"""
Object containing details about funding limit settings change request status
"""
interface FundingLimitSettingsChangeRequestStatusInfo {
  """Current limit settings change request status."""
  status: FundingLimitSettingsChangeRequestStatus!
}

"""
StatusInfo when funding limit settings change request is waiting for more information
"""
type FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo implements FundingLimitSettingsChangeRequestStatusInfo {
  status: FundingLimitSettingsChangeRequestStatus!
}

"""Possible values for funding limit settings status"""
enum FundingLimitSettingsStatus {
  """When the funding limit settings is enabled"""
  Enabled

  """When the funding limit settings is suspended"""
  Suspended

  """When the funding limit settings is disabled"""
  Disabled
}

"""Object containing details about funding limit settings status"""
interface FundingLimitSettingsStatusInfo {
  """Current funding limit settings."""
  status: FundingLimitSettingsStatus!
}

"""Funding Source"""
interface FundingSource {
  """ID of the Funding Source"""
  id: ID!

  """Name of the Funding Source"""
  name: String

  """Funding Source status information"""
  statusInfo: FundingSourceStatusInfo!

  """Created date"""
  createdAt: DateTime!

  """Last updated date"""
  updatedAt: DateTime!
}

"""Please see the Connection interface"""
type FundingSourceConnection implements Connection {
  pageInfo: PageInfo!
  edges: [FundingSourceEdge!]!
  totalCount: Int!
}

"""Please see the Connection interface"""
type FundingSourceEdge implements Edge {
  node: FundingSource!
  cursor: String!
}

"""Filters that can be applied when listing Funding Sources"""
input FundingSourceFiltersInput {
  status: [FundingSourceStatus!]!
}

type FundingSourceNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""
Field we can use when ordering that can be applied when listing funding source results
"""
enum FundingSourceOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing funding source results"""
input FundingSourceOrderByInput {
  field: FundingSourceOrderByFieldInput
  direction: OrderByDirection
}

"""Funding Source Statuses"""
enum FundingSourceStatus {
  Pending
  Enabled
  Canceled
  Rejected
  Suspended
}

"""Funding Source status information"""
interface FundingSourceStatusInfo {
  """Funding Source Pending status"""
  status: FundingSourceStatus!
}

"""
Rejection returned when the Funding Source is not in the expected status
"""
type FundingSourceWrongStatusRejection implements Rejection {
  message: String!
  currentStatus: FundingSourceStatus!
  expectedStatus: FundingSourceStatus!
}

"""Inputs to generate an account"""
input GenerateAccountStatementInput {
  """Unique identifier of an account"""
  accountId: ID!

  """starting date of the date window"""
  openingDate: DateTime!

  """ending date of the date window"""
  closingDate: DateTime!

  """language to generate the statement in (default to account's language)"""
  language: AccountLanguage

  """Type of statement to generate"""
  statementType: StatementType = PDF
}

input GenerateCapitalDepositDocumentUploadUrlInput {
  """Unique identifier of the document."""
  documentId: ID!

  """
  Unique identifier of the capitalDepositCase associated to the document.
  """
  capitalDepositCaseId: ID!

  """Filename of the document."""
  filename: String!
}

union GenerateCapitalDepositDocumentUploadUrlPayload = GenerateCapitalDepositDocumentUploadUrlSuccessPayload | CapitalDepositDocumentCanNotBeUploaded | CapitalDepositDocumentCanNotBeUploadedRejection | ForbiddenRejection | BadRequestRejection | InternalErrorRejection

type GenerateCapitalDepositDocumentUploadUrlSuccessPayload {
  """URL to be used to upload the document."""
  uploadUrl: String
}

type GeneratedTransactionStatementStatusInfo implements TransactionStatementStatusInfo {
  """status of the transaction statement"""
  status: TransactionStatementStatusEnum!

  """temporary public url on which the file can be accessed"""
  url: URL!

  """date at which the document will expire"""
  expiresAt: DateTime!
}

"""Input for the `generateExportDownloadLink` mutation."""
input GenerateExportDownloadLinkInput {
  """
  The `exportId` generated by a previous call to any export mutation.
  
  NB: The export needs to be completed for the link to be generated.
  """
  exportId: String!
}

union GenerateExportDownloadLinkPayload = GenerateExportDownloadLinkSuccessPayload | UnknownExportRejection | StillExportingRejection

"""
Payload of the `generateExportDownloadLink` mutation in case of success.
"""
type GenerateExportDownloadLinkSuccessPayload {
  """
  A temporary link to download the related export file.
  
  NB: This link lasts a few minutes only.
  """
  link: String!
}

input GenerateSupportingDocumentUploadUrlInput {
  """Unique identifier of a supporting document collection"""
  supportingDocumentCollectionId: ID!

  """Type of document"""
  supportingDocumentType: SupportingDocumentType

  """Name of the document which will be sent"""
  filename: String!

  """Purpose of document"""
  supportingDocumentPurpose: SupportingDocumentPurposeEnum
}

union GenerateSupportingDocumentUploadUrlPayload = GenerateSupportingDocumentUploadUrlSuccessPayload | SupportingDocumentCollectionNotFoundRejection | ForbiddenRejection | InternalErrorRejection | SupportingDocumentUploadNotAllowedRejection | ValidationRejection

type GenerateSupportingDocumentUploadUrlSuccessPayload {
  """Id of the supporting document created for this uploadUrl"""
  supportingDocumentId: String!

  """
  Info to upload the document : url and fields to add along file in form (POST)
  """
  upload: SupportingDocumentUploadInfo!
}

"""Inputs to generate an account"""
input GenerateTransactionStatementInput {
  """Id of the transaction for which the statement is generated."""
  transactionId: ID!

  """
  Language to use to generate the statement (account language will be used by default). Must be compliant with RFC 5646.
  """
  language: TransactionStatementLanguage
}

"""Result of the generation."""
union GenerateTransactionStatementPayload = GenerateTransactionStatementSuccessPayload | GenerationNotAllowedRejection | ValidationRejection | ForbiddenRejection | TransactionNotFoundRejection

type GenerateTransactionStatementSuccessPayload {
  transactionStatement: TransactionStatement
}

input GenerateTransactionSupportingDocumentUploadUrlInput {
  """Transaction for which the document is uploaded"""
  transactionId: ID!

  """Type of document"""
  supportingDocumentType: SupportingDocumentType

  """Name of the document which will be sent"""
  filename: String!

  """Purpose of document"""
  supportingDocumentPurpose: SupportingDocumentPurposeEnum!
}

union GenerateTransactionSupportingDocumentUploadUrlPayload = GenerateTransactionSupportingDocumentUploadUrlSuccessPayload | AccountNotFoundRejection | ForbiddenRejection | InternalErrorRejection | TransactionNotFoundRejection | ValidationRejection

type GenerateTransactionSupportingDocumentUploadUrlSuccessPayload {
  """Id of the supporting document created for this uploadUrl"""
  supportingDocumentId: String!

  """
  Id of the supporting document collection the supporting document is related to
  """
  supportingDocumentCollectionId: String!

  """
  Info to upload the document : url and fields to add along file in form (POST)
  """
  upload: SupportingDocumentUploadInfo!
}

"""
Rejection returned if a transaction statement can’t be generated for this transaction.
"""
type GenerationNotAllowedRejection implements Rejection {
  message: String!
}

"""Rejection returned when the Global Funding has been exceeded"""
type GlobalFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the Global Instant Funding limit has been exceeded
"""
type GlobalInstantFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""Input of the `grantConsentWithServerSignature` mutation"""
input GrantConsentWithServerSignatureInput {
  """ID of the consent to grant"""
  consentId: ID!

  """Consent challenge signed with server consent credentials"""
  signature: String!
}

"""Payload of the `grantConsentWithServerSignature` mutation"""
union GrantConsentWithServerSignaturePayload = GrantConsentWithServerSignatureSuccessPayload | ConsentNotFoundRejection | NotReachableConsentStatusRejection | ForbiddenRejection | ConsentTypeNotSupportedByServerConsentRejection | ServerConsentNotAllowedForConsentOperationRejection | ProjectNotFoundRejection | ServerConsentNotAllowedForProjectRejection | ServerConsentProjectSettingsNotFoundRejection | ServerConsentProjectCredentialMissingRejection | ServerConsentProjectCredentialNotFoundRejection | ServerConsentCredentialsNotValidOrOutdatedRejection | ServerConsentSignatureNotValidRejection

"""Success payload of the `grantConsentWithServerSignature` mutation"""
type GrantConsentWithServerSignatureSuccessPayload {
  consent: Consent!
}

type Headquarters {
  town: String!
  zipCode: String!
  address: String!
}

scalar HexColorCode

"""International Bank Account Number"""
scalar IBAN

"""Rejection returned when the IBAN is not reachable"""
type IBANNotReachableRejection implements Rejection {
  message: String!
}

"""Rejection returned when the IBAN is not valid"""
type IBANNotValidRejection implements Rejection {
  message: String!
}

"""Virtual IBAN Status"""
enum IBANStatus {
  """When the virtual IBAN accept to receive Sepa payments"""
  Enabled

  """When the virtual IBAN refuse definitely to receive Sepa payments"""
  Canceled

  """When the virtual IBAN refuse temporarily to receive Sepa payments"""
  Suspended
}

"""ibanValidation input"""
input IbanValidationInput {
  """IBAN to validate"""
  iban: IBAN!
}

type IbanValidationRejection implements Rejection {
  message: String!
}

"""IbanValidationResult"""
union IbanValidationResult = ValidIban | InvalidIban

"""The document corresponding to an ID card"""
type IdCardDocument {
  """Unique identifier of the ID card document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """The date at which the ID card was issued"""
  issueDate: Date

  """The date at which the ID card expires"""
  expiryDate: Date

  """Machine-readable zone code of the ID card"""
  mrz: String

  """Number of the ID card"""
  number: String

  """List of the associated files"""
  files: [IdCardDocumentFile!]!
}

"""The file associated to the ID card document"""
type IdCardDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!

  """From which side the ID card's picture was taken"""
  side: DocumentFileSide!
}

"""
The identification represents an ongoing identification process or its result
"""
type Identification {
  """Unique identifier of the identification"""
  id: String!

  """Creation date of the identification"""
  createdAt: DateTime!

  """Last update date of the identification"""
  updatedAt: DateTime!

  """The global status of the identification"""
  status: SwanIdentificationStatus!

  """The process that was used for this identification"""
  process: IdentificationProcess!

  """
  The status and results associated to the available identification processes
  """
  levels: IdentificationLevelStatusesInfo!

  """
  The available documents related to the identification (id doc, selfie, report...)
  """
  documents: [IdentificationDocument!]

  """
  The identity document type used for the current identification (passport, id card ...)
  """
  identityDocumentType: IdentityDocumentType
}

"""
Fields we can use when ordering that can be applied when listing identifications
"""
type IdentificationConnection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """IdentificationEdge list"""
  edges: [IdentificationEdge!]!
}

"""Union representing all the possible identification document types"""
union IdentificationDocument = IdCardDocument | PassportDocument | ResidencePermitDocument | DriversLicenseDocument | FacePhotoDocument | ReportDocument

"""Implements the Relay Edge interface"""
type IdentificationEdge implements Edge {
  """The identification entry"""
  node: Identification!

  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

"""
Filter that can be passed to get the identifications in specific data ranges
"""
input IdentificationFiltersInput {
  """To filter on status values"""
  statuses: [SwanIdentificationStatus!]

  """To filter on level values"""
  levels: [IdentificationLevel!]

  """To filter on process values"""
  processes: [IdentificationProcess!]
}

"""
If requested by sending the right parameters to the initial oauth2 url,
it contains the identification level that is requested to be fulfilled
after the oauth2 consent by starting the right identification.

QES => use the `startFourthlineExpertIdVerificationIdentification` mutation

Expert => use the `startUbbleExpertIdVerificationIdentification` mutation

PVID => use the `startUbblePvidIdVerificationIdentification` mutation

Auto => use query `recommendedIdentificationFlow` to let Swan recommend the best flow and level for a user
"""
enum IdentificationFlowLevel {
  Auto
  Expert
  PVID
  QES
}

"""The various reasons that can lead to an invalid identification level"""
enum IdentificationInvalidReason {
  """Face must be fully present in the photo"""
  AbsentOrIncompleteFace

  """Applicant used a device that has been technically altered / modified"""
  AlteredDevice

  """Light on actual document is insufficient"""
  BadDocumentLighting

  """
  Something about the document is damaged (could be as tiny as a bent corner)
  """
  DamagedDocument

  """Expiry date of document has passed"""
  ExpiredDocument

  """Attempt to commit fraud detected"""
  FraudDetected

  """
  Video quality isn’t sufficient or video is missing required information
  """
  InadequateVideo

  """Lighting on applicant’s face is insufficient"""
  InsufficientApplicantLighting

  """Applicant isn’t meeting movement requirements"""
  InsufficientApplicantLiveness

  """Internet connection quality is insufficient"""
  InsufficientConnectionQuality

  """Video of document doesn’t meet movement requirements"""
  InsufficientDocumentLiveness

  """Document is blurry or otherwise distorted"""
  InsufficientDocumentReadability

  """Face is blurry or otherwise distorted"""
  InsufficientFaceReadability

  """Video is blurry or otherwise distorted"""
  InsufficientVideoReadability

  """There was a technical error"""
  InternalError

  """Address is not valid or accepted"""
  InvalidAddress

  """Identification data is invalid or missing"""
  InvalidOrMissingData

  """Applicant seems to be doing verification against their will"""
  InvoluntaryIdentification

  """Geolocation data is required but not available"""
  MissingGeolocationData

  """Applicant appears on unacceptable news list"""
  NegativeNewsHit

  """Applicant’s identity does not match the expected ID info"""
  NonMatchingIdentity

  """Applicant presented a duplicate of the document (digital or paper)"""
  NonOriginalDocument

  """Applicant appears on a sanctions list"""
  SanctionListHit

  """Applicant required to provide a second document"""
  SecondDocumentRequired

  """There was a technical error with the electronic signature process"""
  TechnicalSignatureError

  """The time to complete the signature timed out"""
  TimeoutSignatureFlow

  """Document not on list of acceptable document types"""
  UnacceptableDocument

  """Applicant is under the minimum required age"""
  UnderageApplicant
}

"""Possible value for the field IdentificationLevel"""
enum IdentificationLevel {
  """Human identity verification"""
  Expert

  """Identity verification with Qualified Electronic Signature"""
  QES

  """Identity verification with PVID"""
  PVID
}

"""User identification levels input payload."""
enum IdentificationLevelInput {
  """Identity verified by an expert (Ubble-like)"""
  Expert

  """
  Identity verified by an expert with a Remote Identity Verification Service
  """
  PVID

  """
  Identity verified by an expert and a Qualified Electronic Signature has been done
  """
  QES
}

"""Identification levels"""
type IdentificationLevels {
  PVID: Boolean!
  QES: Boolean!
  expert: Boolean!
}

"""
The status and results associated to the available identification processes
"""
type IdentificationLevelStatusesInfo {
  """The status and results associated to the expert level"""
  expert: IdentificationLevelStatusInfo!

  """
  The status and results associated to the Qualified Electronic Signature level
  """
  qes: IdentificationLevelStatusInfo!

  """
  The status and results associated to the Remote Identity Verification Service level
  """
  pvid: IdentificationLevelStatusInfo!
}

"""
Union representing all the possible statuses: not supported, not started, pending, valid, invalid, cancelled, expired
Each variant contains its relevant data, for example invalid contains a `reason` field, expired contains an `expiredAt` field, valid contains a `documents` field
"""
union IdentificationLevelStatusInfo = NotSupportedIdentificationLevelStatusInfo | NotStartedIdentificationLevelStatusInfo | StartedIdentificationLevelStatusInfo | PendingIdentificationLevelStatusInfo | ValidIdentificationLevelStatusInfo | InvalidIdentificationLevelStatusInfo | CanceledIdentificationLevelStatusInfo | ExpiredIdentificationLevelStatusInfo

"""Process of the identification"""
enum IdentificationProcess {
  """Identity verified by an expert"""
  Expert

  """
  Identity verified by an expert and a Qualified Electronic Signature has been done
  """
  QES

  """
  Identity verified by an expert with a Remote Identity Verification Service
  """
  PVID
}

"""
Fields we can use when ordering that can be applied when listing identifications
"""
enum IdentificationsOrderByField {
  createdAt
  updatedAt
}

"""Order that can be applied when listing identifications"""
input IdentificationsOrderByInput {
  """The field by which the Identification list should be ordered"""
  field: IdentificationsOrderByField

  """The order in which the Identification list should be ordered"""
  direction: OrderByDirection
}

"""
Rejection returned if identity and the account memberships are already bind
"""
type IdentityAlreadyBindToAccountMembershipRejection implements Rejection {
  accountId: String!
  identityId: String!
  message: String!
}

"""The type of the identity document"""
enum IdentityDocumentType {
  IdCard
  Passport
  ResidencePermit
  DriversLicense
}

"""Data used for in app provisioning"""
type InAppProvisioningData {
  """Cryptographic OTP used to pre-validate digitalization"""
  activationData: String!

  """
  Base64 public key used with the wallet provider public key to encrypt the card data
  """
  ephemeralPublicKey: String!

  """Encrypted card data"""
  encryptedData: String!

  """IV used to encrypt the card Data (Useful for Google Pay)"""
  iv: String

  """
  public key fingerprint of the key used to encrypt card data (Useful for Google Pay)
  """
  publicKeyFingerprint: String

  """
  hash algorithm used during encryption of the card data (Useful for Google Pay)
  """
  oaepHashingAlgorithm: String
}

"""Individual shareholder info."""
type IndividualShareholder {
  """Whether the shareholder is an individual or a company."""
  type: ShareholderType!

  """First name of the shareholder."""
  firstName: String!

  """Last name of the shareholder."""
  lastName: String!

  """Birth date of the shareholder."""
  birthDate: String!

  """CCA3 code for the country of nationality of the shareholder."""
  nationality: CCA3!
}

"""
Individual Ultimate Beneficial Owner
You need to describe the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company.
Please describe the company (s) that owns the company that wishes to open an account, when an individual holds in fine more than 25%
"""
type IndividualUltimateBeneficialOwner {
  """individual first name"""
  firstName: String

  """individual last name"""
  lastName: String

  """individual birth date"""
  birthDate: DateTime

  """individual birth city"""
  birthCity: String

  """individual birth city postal code"""
  birthCityPostalCode: String

  """individual birth country code"""
  birthCountryCode: CCA3

  """Information relating to the type of the UBO"""
  info: IndividualUltimateBeneficialOwnerInfo!

  """Individual beneficial owner Tax or Identification Number"""
  taxIdentificationNumber: String

  """Individual beneficial owner residency Address"""
  residencyAddress: AddressInformation

  """Individual beneficial owner title (Mr/Ms)"""
  title: TitleEnum

  """Ultimate beneficial owner's identity document details"""
  identityDocumentDetails: UBOIdentityDocumentDetails
}

"""Define the type of the UBO"""
interface IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!
}

input IndividualUltimateBeneficialOwnerInput {
  """
  Individual beneficial owner first name. Length must be from 0 to 100 characters
  """
  firstName: String

  """
  Individual beneficial owner last name. Length must be from 0 to 100 characters
  """
  lastName: String

  """Individual birth date. Must be a valid date in the YYYY/MM/DD format"""
  birthDate: String

  """Individual birth city. Length must be from 0 to 100 characters"""
  birthCity: String

  """
  Individual birth city postal code. Length must be from 0 to 50 characters
  """
  birthCityPostalCode: String

  """Individual birth country code"""
  birthCountryCode: CCA3

  """Define UBO is an Indirect Owner"""
  indirect: Boolean

  """Define UBO is a Direct Owner"""
  direct: Boolean

  """
  Total of capital (in percentage, ex: 50 = 50%). Must be between 1 and 100.
  """
  totalCapitalPercentage: Float

  """Define UBO is a Legal Representative"""
  type: IndividualUltimateBeneficialOwnerTypeEnum

  """Individual beneficial owner Tax or Identification Number"""
  taxIdentificationNumber: String

  """Individual beneficial owner residency address"""
  residencyAddress: ResidencyAddressInput

  """Individual ultimate beneficial owner title (Mr/Ms)"""
  title: TitleEnum

  """Ultimate beneficial owner's identity document details"""
  identityDocumentDetails: UBOIdentityDocumentDetailsInput
}

"""Individual Ultimate beneficial owner nature"""
enum IndividualUltimateBeneficialOwnerTypeEnum {
  """The Beneficial Owner is the representant legal"""
  LegalRepresentative

  """The Beneficial Owner have shares"""
  HasCapital

  """Other"""
  Other
}

"""Individual Ultimate Beneficial Owner Type Has Capital"""
type IndividualUltimateBeneficialOwnerTypeHasCapital implements IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!

  """Define UBO is an Indirect Owner"""
  indirect: Boolean

  """Define UBO is an Direct Owner"""
  direct: Boolean

  """Total of capital (in percentage, ex: 50 = 50%)"""
  totalCapitalPercentage: Float
}

"""Individual Ultimate Beneficial Owner Type Legal Representative"""
type IndividualUltimateBeneficialOwnerTypeLegalRepresentative implements IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!
}

"""Individual Ultimate Beneficial Owner Type Other"""
type IndividualUltimateBeneficialOwnerTypeOther implements IndividualUltimateBeneficialOwnerInfo {
  """Individual type"""
  type: IndividualUltimateBeneficialOwnerTypeEnum!
}

input InitiateCheckMerchantPaymentInput {
  """
  Amount of the concerned payment collection. For check deposit, the amount should not exceed 10 000€.
  """
  amount: AmountInput!

  """
  Label of the concerned payment collection, which will be displayed on Swan bank statement.
  If empty, default label will be set as "Check N° [1st 7 characters of CMC7]
  """
  label: String

  """End-to-end reference of the concerned payment collection."""
  reference: String

  """ID of the merchant profile associated to the Swan creditor account."""
  merchantProfileId: ID!

  """
  31-character unique identifier located at the bottom of the check.
  CMC7 is composed of 3 sections (check number (7 characters), check issuing bank code (12 characters), check holder account number (12 characters)).
  Combined with RLMC key, it  allows the check to be traced.
  """
  cmc7: String!

  """
  2-digit key used to check the integrity of the CMC7 line, located at the bottom right of the check.
  Combined with CMC7 line, it allows the check to be traced.
  """
  rlmcKey: String!
}

union InitiateCheckMerchantPaymentPayload = InitiateCheckMerchantPaymentSuccessPayload | ForbiddenRejection | NotFoundRejection | InternalErrorRejection | ValidationRejection | CheckRejection

type InitiateCheckMerchantPaymentSuccessPayload {
  merchantPayment: Payment!

  """
  Details of the FNCI (Fichier national des chèques irréguliers) response
  """
  fnciInfo: FnciInfo!
}

"""Initiate credit transfers"""
input InitiateCreditTransfersInput {
  """account to be debited identified by number"""
  accountNumber: AccountNumber

  """account id to be debited identified by id"""
  accountId: ID

  """credit transfers (max 2500 records)"""
  creditTransfers: [CreditTransferInput!]!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union InitiateCreditTransfersPayload = InitiateCreditTransfersSuccessPayload | AccountNotFoundRejection | ForbiddenRejection | InternalErrorRejection

type InitiateCreditTransfersSuccessPayload {
  payment: Payment!
}

"""Input to initiate a funding request"""
input InitiateFundingRequestInput {
  """ID of the funding source to be used to fund the concerned account"""
  fundingSourceId: ID!

  """
  Amount of the requested funding, i.e. amount that will credit the concerned Swan account and debit the external funding source.
  """
  amount: AmountInput!

  """
  Reference of the funding request that will be shown on the account holder statement and on the debtor account used.
  """
  reference: String

  """
  Label of the funding request that will be shown on the account holder statement and on the debtor account used
  Always starts with 'Partner Name' truncated at 19 characters followed by a space.
  If empty, default label is "Partner Name - Account Holder Name".
  """
  label: String

  """
  Url to which the authorized account member must be redirected once the consent has been finalized.
  """
  consentRedirectUrl: String!

  """
  When the funding request should be executed. If `null`, it will be executed as soon as possible.
  It is not possible to define this value when the option `isInstant` is set to true.
  """
  requestedExecutionAt: DateTime

  """
  *SOON TO BE DEPRECATED*
  If `true` the funds should be available immediately. If `false` or `null`, the funds will be available
  after the resolution of the credit transaction.
  """
  isInstant: Boolean
}

"""Initiate A Funding Request Payload"""
union InitiateFundingRequestPayload = InitiateFundingRequestSuccessPayload | ForbiddenRejection | ValidationRejection | FundingLimitExceededRejection | ProjectFundingLimitExceededRejection | GlobalFundingLimitExceededRejection | FundingSourceWrongStatusRejection | FundingSourceNotFoundRejection | InsufficientFundsRejection | InstantFundingLimitExceededRejection | ProjectInstantFundingLimitExceededRejection | GlobalInstantFundingLimitExceededRejection | AccountVerificationWrongStatusRejection

"""Initiate A Funding Request Success Payload"""
type InitiateFundingRequestSuccessPayload {
  """Details of the funding payment created"""
  payment: Payment!
}

"""Input to create a quote and an international beneficiary"""
input InitiateInternationalCreditTransferInput {
  """Account ID of the originator of the international credit transfer"""
  accountId: ID

  """Account number if the beneficiary is a swan account"""
  accountNumber: AccountNumber

  """Target amount of the international credit transfer"""
  targetAmount: AmountInput!

  """if the transfer will credit a new international beneficiary"""
  internationalBeneficiary: InternationalBeneficiaryInput

  """
  * COMING SOON *
  if the transfer will credit an existing international beneficiary
  """
  trustedBeneficiaryId: ID

  """Transfer details"""
  internationalCreditTransferDetails: [InternationalCreditTransferDetailsInput!]!

  """When the consent flow is finished the user is redirected to this URL"""
  consentRedirectUrl: String!

  """External reference"""
  externalReference: String

  """Language used to output errors"""
  language: InternationalCreditTransferDisplayLanguage
}

"""Initiate International Credit Transfer Response Payload"""
union InitiateInternationalCreditTransferResponsePayload = InitiateInternationalCreditTransferResponseSuccessPayload | AccountNotFoundRejection | ForbiddenRejection | InternalErrorRejection | ValidationRejection

"""Initiate International Credit Transfer Response Success Payload"""
type InitiateInternationalCreditTransferResponseSuccessPayload {
  """Details of the international credit transfer created"""
  payment: Payment!

  """Details for the quote of international credit transfer"""
  quote: InternationalCreditTransferQuote!
}

input InitiateMerchantPaymentCollectionInput {
  """
  Amount of the concerned payment collection. For check deposit, the amount should not exceed 10 000€.
  """
  amount: AmountInput!

  """
  Label of the concerned payment collection, which will be displayed on Swan bank statement -
  For checks transaction, if empty, default label will be set as "Check N° [1st part of CMC7 - 7 char.]
  """
  label: String

  """end-to-end reference of the concerned payment collection"""
  reference: String

  """
  external reference (JSON) that can be used by the Swan merchant for reconciliation purposes
  """
  externalReference: String

  """Internal direct debit type of payment collection"""
  internalDirectDebit: InternalDirectDebitPaymentCollectionInput

  """Sepa Direct Debit type of payment collection"""
  sepaDirectDebit: SepaDirectDebitPaymentCollectionInput
}

union InitiateMerchantPaymentCollectionPayload = InitiateMerchantPaymentCollectionSuccessPayload | ForbiddenRejection | NotFoundRejection | InternalErrorRejection | ValidationRejection

type InitiateMerchantPaymentCollectionSuccessPayload {
  merchantPaymentCollection: Payment!
}

type InstantFundingLimit {
  """Maximum Instant Funding Amount authorized"""
  amount: Amount!

  """Instant Funding Amount that has already been used"""
  funding: Amount
}

"""
Rejection returned when the Account Holder Instant Funding limit has been exceeded
"""
type InstantFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""Rejection returned when the Available balance is insufficient"""
type InsufficientFundsRejection implements Rejection {
  message: String!
}

"""Internal Beneficiary"""
type InternalBeneficiary {
  """
  unique identifier of a beneficiary
  *SOON TO BE DEPRECATED*
  Always empty, It will be removed soon.
  """
  id: ID @deprecated(reason: "this field is never filled. It will be removed soon.")

  """full name of the beneficiary"""
  name: String!

  """
  `true` if this new beneficiary is the account holder himself in an other financial institution.
  *SOON TO BE DEPRECATED*
  Not used. It will be removed soon.
  """
  isMyOwnIban: Boolean! @deprecated(reason: "this field is never filled. It will be removed soon.")

  """account number if the beneficiary is a swan account"""
  accountNumber: AccountNumber! @deprecated(reason: "because it is not already implemented (a default value is set).")
}

"""Internal Credit Transfer transaction"""
type InternalCreditTransfer implements Transaction {
  """unique identifier of the transaction"""
  id: ID!
  supportingDocumentCollections(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: SupportingDocumentCollectionFilterInput
  ): SupportingDocumentCollectionConnection!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire reference chain.
  """
  reference: String!

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """creditor information"""
  creditor: InternalCreditTransferCreditor!

  """debtor information"""
  debtor: InternalCreditTransferDebtor!

  """matching account for the transaction"""
  account: Account

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """r-transaction reason"""
  returnReason: TransactionReasonCode

  """true if a transaction statement can be generated for this transaction"""
  statementCanBeGenerated: Boolean

  """project id of the transaction"""
  projectId: ID!
}

"""Internal Credit Transfer creditor"""
interface InternalCreditTransferCreditor {
  """full name of the Creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Internal Credit Transfer debtor"""
interface InternalCreditTransferDebtor {
  """full name of the debtor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Internal Credit Transfer creditor for Incoming transaction"""
type InternalCreditTransferInCreditor implements InternalCreditTransferCreditor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Internal Credit Transfer debtor for Incoming transaction"""
type InternalCreditTransferInDebtor implements InternalCreditTransferDebtor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Internal Credit Transfer creditor for Outgoing transaction"""
type InternalCreditTransferOutCreditor implements InternalCreditTransferCreditor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""Internal Credit Transfer debtor for Outgoing transaction"""
type InternalCreditTransferOutDebtor implements InternalCreditTransferDebtor {
  """full name of the creditor"""
  name: String!

  """account number"""
  accountNumber: AccountNumber!
}

"""InternalDirectDebitB2BMerchantPaymentMethod"""
type InternalDirectDebitB2BMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

input InternalDirectDebitB2BPaymentMethodInput {
  """If `true`, the Payment Method will be Pending Review"""
  activate: Boolean = false
}

"""Internal Direct Debit Creditor"""
type InternalDirectDebitCreditor {
  """unique identifier of the creditor account"""
  accountId: ID!
}

"""Internal Direct Debit Debtor"""
type InternalDirectDebitDebtor {
  """unique identifier of the debtor account"""
  accountId: ID!
}

interface InternalDirectDebitMandate {
  """
  Unique identifier of the internal direct debit mandate, generated by Swan
  """
  id: ID!
}

input InternalDirectDebitPaymentCollectionInput {
  """ID of the concerned payment mandate"""
  mandateId: ID!

  """Date at which the Swan merchant wishes the payment to be executed"""
  requestedExecutionAt: DateTime
}

enum InternalDirectDebitSequence {
  OneOff
  Recurrent
}

"""InternalDirectDebitStandardMerchantPaymentMethod"""
type InternalDirectDebitStandardMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

input InternalDirectDebitStandardPaymentMethodInput {
  """If `true`, the Payment Method will be Pending Review"""
  activate: Boolean = false
}

"""Internal Direct Debit transaction"""
type InternalDirectDebitTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!
  supportingDocumentCollections(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: SupportingDocumentCollectionFilterInput
  ): SupportingDocumentCollectionConnection!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain.
  """
  reference: String!

  """payment method identifier used for this transaction: accountNumber"""
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """creditor information"""
  creditor: InternalDirectDebitCreditor!

  """debtor information"""
  debtor: InternalDirectDebitDebtor!

  """matching account for the transaction"""
  account: Account

  """matching Internal mandate for the transaction"""
  mandate: InternalDirectDebitMandate

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """reserved amount of the transaction computed with the rolling reserve."""
  reservedAmount: Amount

  """date on which reserved funds become available."""
  reservedAmountReleasedAt: DateTime

  """r-transaction reason"""
  returnReason: TransactionReasonCode

  """true if a transaction statement can be generated for this transaction"""
  statementCanBeGenerated: Boolean

  """project id of the transaction"""
  projectId: ID!

  """merchant profile associated"""
  merchant: MerchantProfile
}

"""Rejection returned on unexpected server error"""
type InternalErrorRejection implements Rejection {
  message: String!
}

"""Payment direct debit mandate for Internal"""
type InternalPaymentDirectDebitMandate implements InternalDirectDebitMandate & PaymentDirectDebitMandate & PaymentMandate {
  """Unique identifier of the Internal Direct Debit Payment Mandate"""
  id: ID!

  """
  List of transactions associated with the Internal Payment Direct Debit Mandate.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  transactions(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: TransactionsOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """Unique reference of the Internal Direct Debit Payment Mandate"""
  reference: String!

  """Internal Direct Debit Payment Mandate scheme"""
  scheme: InternalPaymentMandateScheme!

  """Internal Direct Debit Payment Mandate status information"""
  statusInfo: PaymentMandateStatusInfo!

  """Internal Direct Debit Payment Mandate sequence"""
  sequence: PaymentMandateSequence!

  """Internal Direct Debit Payment Mandate PDF document URL"""
  mandateDocumentUrl: String!

  """Internal Direct Debit Payment Mandate debtor information"""
  debtor: InternalPaymentMandateDebtor!

  """Internal direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """Internal Direct Debit Payment Mandate creditor information"""
  creditor: InternalPaymentMandateCreditor!

  """Signature date of the Internal Direct Debit Payment Mandate"""
  signatureDate: Date

  """Creation date of the Internal Direct Debit Payment Mandate"""
  createdAt: DateTime!

  """Last Update date of the Internal Direct Debit Payment Mandate"""
  updatedAt: DateTime!

  """
  Date of the the last transaction executed for the concerned Internal Direct Debit Payment Mandate
  """
  executedAt: DateTime

  """Expiry date of the Internal Direct Debit Payment Mandate"""
  expiredAt: Date

  """Account Holder information"""
  accountHolder: AccountHolder!

  """Language that will be used to produce the mandate PDF document"""
  language: String!

  """Custom name of the mandate"""
  name: String
}

type InternalPaymentMandateCreditor implements PaymentMandateCreditor {
  """Internal Direct Debit Payment Mandate creditor UUID"""
  id: ID!

  """Internal Direct Debit Payment Mandate Creditor Idenfier"""
  identifier: ID!

  """Internal Direct Debit Payment Mandate creditor name"""
  name: String!

  """Internal Direct Debit Payment Mandate creditor address"""
  address: Address!
}

type InternalPaymentMandateDebtor implements PaymentMandateDebtor {
  """Internal Direct Debit Payment Mandate debtor name"""
  name: String!

  """Internal Direct Debit Payment Mandate debtor e-mail"""
  email: String!

  """Internal Direct Debit Payment Mandate debtor country"""
  country: CCA3!

  """
  Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries
  """
  address: Address

  """
  Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries
  """
  accountId: ID
}

enum InternalPaymentMandateScheme {
  """Internal Direct Debit Standard"""
  InternalDirectDebitStandard

  """Internal Direct Debit B2B"""
  InternalDirectDebitB2b
}

"""Received direct debit mandate for SEPA"""
type InternalReceivedDirectDebitMandate implements InternalDirectDebitMandate & ReceivedDirectDebitMandate {
  """
  Unique identifier of the received internal direct debit mandate, generated by Swan
  """
  id: ID!

  """
  List of transactions associated with the Internal Receive Direct Debit Mandate.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  transactions(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """Version of the received internal direct debit mandate"""
  version: String!

  """Creation date of the received internal direct debit mandate"""
  createdAt: DateTime!

  """Last Update date of the received internal direct debit mandate"""
  updatedAt: DateTime!

  """Received internal direct debit Unique Mandate Reference (UMR)"""
  reference: String!

  """Received internal direct debit mandate scheme"""
  scheme: InternalReceivedDirectDebitMandateScheme!

  """Received internal direct debit mandate sequence"""
  sequence: InternalReceivedDirectDebitMandateSequence!

  """Received internal direct debit creditor"""
  creditor: InternalReceivedDirectDebitMandateCreditor!

  """Received internal direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """
  Date of the last internal direct debit transaction executed for the concerned received internal direct debit mandate
  """
  executedAt: DateTime

  """Date of signature of the received internal direct debit mandate"""
  signatureDate: Date

  """
  Expiry date of the received internal direct debit mandate, computed automatically (36 months from the executedAt date)
  """
  expiredAt: Date

  """
  Mandate status information of the received internal direct debit mandate
  """
  statusInfo: ReceivedDirectDebitMandateStatusInfo!

  """Account of the received internal direct debit mandate debtor"""
  account: Account

  """Iban of the received internal direct debit mandate debtor"""
  iban: IBAN!

  """Mandate name"""
  name: String
}

"""Internal received direct debit mandate creditor"""
type InternalReceivedDirectDebitMandateCreditor {
  """Creditor identifier"""
  identifier: String!

  """Name of the creditor"""
  name: String!

  """Address of the creditor"""
  address: Address!
}

"""Received internal direct debit mandate scheme"""
enum InternalReceivedDirectDebitMandateScheme {
  """
  When the received internal direct debit mandate can only be used for internal B2B direct debit transactions
  """
  InternalDirectDebitB2b

  """
  When the received internal direct debit mandate can only be used for internal Standard direct debit transactions
  """
  InternalDirectDebitStandard
}

"""Internal received direct debit mandate sequence"""
enum InternalReceivedDirectDebitMandateSequence {
  """
  When the authorisation is given once by the Debtor to collect only one single internal direct debit
  """
  OneOff

  """
  When the authorisation by the Debtor can be used for regular internal direct debits initiated by the Creditor
  """
  Recurrent
}

"""Address of an international beneficiary"""
input InternationalAddressInput {
  """Address 1"""
  address1: String

  """City"""
  city: String

  """Country"""
  country: String

  """Zip Code"""
  zipCode: String

  """State"""
  state: String
}

interface InternationalBeneficiary {
  """Currency of the international beneficiary"""
  currency: Currency!

  """Route that Swan will use to transfer the funds"""
  route: InternationalCreditTransferRoute!

  """Currency-specific details of the beneficiary"""
  details: [InternationalCreditTransferDetails!]!

  """name of the beneficiary"""
  name: String!
}

"""International Beneficiary Details"""
input InternationalBeneficiaryDetailsInput {
  """Key"""
  key: String!

  """Value"""
  value: String!
}

"""International Beneficiary Dynamic Forms"""
type InternationalBeneficiaryDynamicForms {
  """Schemes"""
  schemes: [Scheme!]!
}

"""International Beneficiary"""
input InternationalBeneficiaryInput {
  """Account holder name"""
  name: String!

  """Currency of the international beneficiary account"""
  currency: Currency!

  """Currency-specific details of the beneficiary"""
  details: [InternationalBeneficiaryDetailsInput!]!

  """Route that Swan will use to transfer the funds"""
  route: InternationalCreditTransferRouteInput!

  """
  Whether to save or not this beneficiary to the beneficiary list of the debited account
  """
  save: Boolean
}

union InternationalCreditTransferCreditor = InternationalCreditTransferOutCreditor | InternationalCreditTransferInCreditor | InternationalCreditTransferInDebtor

"""International Currency Exchange / Quote"""
type InternationalCreditTransferCurrencyExchange {
  """Rate of the quote"""
  exchangeRate: String!

  """Fees"""
  feesAmount: Amount

  """Source amount of the quote"""
  sourceAmount: Amount

  """target amount of the quote"""
  targetAmount: Amount
}

union InternationalCreditTransferDebtor = InternationalCreditTransferOutDebtor | InternationalCreditTransferInDebtor | InternationalCreditTransferInCreditor

"""
International Credit Transfer - Currency-specific details of the beneficiary
"""
type InternationalCreditTransferDetails {
  """Key"""
  key: String!

  """Value"""
  value: String!
}

"""International Credit Transfer Details"""
input InternationalCreditTransferDetailsInput {
  """Key"""
  key: String!

  """Value"""
  value: String!
}

"""Language: ISO 639-1 language code"""
enum InternationalCreditTransferDisplayLanguage {
  """British English"""
  en

  """Dutch"""
  nl

  """French"""
  fr

  """German"""
  de

  """Italian"""
  it

  """Portuguese"""
  pt

  """Spanish"""
  es
}

"""International Credit Transfer Dynamic Form"""
type InternationalCreditTransferDynamicForm {
  """List of international transaction fields"""
  fields: [Field!]!

  """
  Number of fields that need to be updated to fill the form completely. Please re run the query internationalCreditTransferTransactionDetailsDynamicForm with updated refreshableFields if the value of this field is not 0
  """
  remainingFieldsToRefreshCount: Int!
}

"""International Credit Transfer In - Creditor info"""
type InternationalCreditTransferInCreditor {
  """Account holder name"""
  name: String!

  """Bank Identifier Code"""
  BIC: BIC!

  """
  International Bank Account Number
  Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited`
  """
  IBAN: IBAN!

  """
  maskedIBAN if the beneficiary is a an account in an other financial institution
  """
  maskedIBAN: String!

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID
}

type InternationalCreditTransferInDebtor {
  """Account holder name"""
  name: String!

  """Account Number"""
  accountNumber: String!

  """BIC"""
  bic: String
}

"""International Credit Transfer Out - Creditor info"""
type InternationalCreditTransferOutCreditor {
  """Currency of the international beneficiary account"""
  currency: Currency!

  """Currency-specific details of the beneficiary"""
  details: [InternationalCreditTransferDetails!]!

  """Account holder name"""
  name: String!

  """Route that Swan will use to transfer the funds"""
  route: InternationalCreditTransferRoute!
}

type InternationalCreditTransferOutDebtor {
  """Account holder name"""
  name: String!
}

"""International Quote"""
type InternationalCreditTransferQuote {
  """Rate of the quote"""
  exchangeRate: String!

  """Source amount of the quote"""
  sourceAmount: Amount!

  """target amount of the quote"""
  targetAmount: Amount!

  """Fees"""
  feesAmount: Amount!
}

"""International Credit Transfer Route"""
enum InternationalCreditTransferRoute {
  """Unknown route"""
  Unknown

  """American ACH for low-value payments"""
  Aba

  """Argentinian local route"""
  Argentina

  """Australian local route"""
  Australian

  """Australian local route Bpay usually used for bill payments"""
  AustralianBpay

  """Brazilian local route"""
  Brazil

  """Canadian local route"""
  Canadian

  """Chilean local route"""
  Chile

  """Costa Rican local route"""
  CostaRica

  """Czech local route"""
  Czech

  """Emirate local route"""
  Emirates

  """
  American credit transfers service for large-value and time-critical payments
  """
  FedwireLocal

  """M-PAiSA"""
  FijiMobile

  """Faster Payment System"""
  HongKongFps

  """Hong Kong's local route"""
  Hongkong

  """Hungarian local route"""
  Hungarian

  """Local route using an IBAN as recipient account identifier"""
  Iban

  """Indian local route"""
  Indian

  """Indian instant payment system Unified Payments Interface"""
  IndianUpi

  """Indonesian local route"""
  Indonesian

  """Canadian payment network Interac"""
  Interac

  """Israeli local route"""
  IsraeliLocal

  """Japanese local route"""
  Japanese

  """Kenyan local route"""
  KenyaLocal

  """Kenyan mobile payment network M-PESA"""
  KenyaMobile

  """Malaysian local route"""
  Malaysian

  """Malaysian payment network DuitNow"""
  MalaysianDuitnow

  """Mexican local route"""
  Mexican

  """Moroccan local route"""
  Morocco

  """Nepalese local route"""
  Nepal

  """New Zealand local route"""
  NewZealand

  """Filipino local route"""
  Philippines

  """Filipino mobile payment network"""
  PhilippinesMobile

  """Polish local route"""
  Polish

  """Ukranian local route"""
  PrivatBank

  """Singapore local route"""
  Singapore

  """Singapore mobile payment network PayNow"""
  SingaporePaynow

  """British local route"""
  SortCode

  """South African local route"""
  SouthAfrica

  """South Korean payment network Paygate"""
  SouthKoreanPaygate

  """South Korean payment network Paygate for corporates"""
  SouthKoreanPaygateBusiness

  """Swift"""
  SwiftCode

  """Thai local route"""
  Thailand

  """Turkish local route"""
  TurkishEarthport

  """Uruguayan local route"""
  Uruguay

  """Vietnamese local route"""
  VietnameEarthport
}

"""International Credit Transfer Route"""
enum InternationalCreditTransferRouteInput {
  """American ACH for low-value payments"""
  Aba

  """Argentinian local route"""
  Argentina

  """Australian local route"""
  Australian

  """Australian local route Bpay usually used for bill payments"""
  AustralianBpay

  """Brazilian local route"""
  Brazil

  """Canadian local route"""
  Canadian

  """Chilean local route"""
  Chile

  """Costa Rican local route"""
  CostaRica

  """Czech local route"""
  Czech

  """Emirate local route"""
  Emirates

  """
  American credit transfers service for large-value and time-critical payments
  """
  FedwireLocal

  """M-PAiSA"""
  FijiMobile

  """Faster Payment System"""
  HongKongFps

  """Hong Kong's local route"""
  Hongkong

  """Hungarian local route"""
  Hungarian

  """Local route using an IBAN as recipient account identifier"""
  Iban

  """Indian local route"""
  Indian

  """Indian instant payment system Unified Payments Interface"""
  IndianUpi

  """Indonesian local route"""
  Indonesian

  """Canadian payment network Interac"""
  Interac

  """Israeli local route"""
  IsraeliLocal

  """Japanese local route"""
  Japanese

  """Kenyan local route"""
  KenyaLocal

  """Kenyan mobile payment network M-PESA"""
  KenyaMobile

  """Malaysian local route"""
  Malaysian

  """Malaysian payment network DuitNow"""
  MalaysianDuitnow

  """Mexican local route"""
  Mexican

  """Moroccan local route"""
  Morocco

  """Nepalese local route"""
  Nepal

  """New Zealand local route"""
  NewZealand

  """Filipino local route"""
  Philippines

  """Filipino mobile payment network"""
  PhilippinesMobile

  """Polish local route"""
  Polish

  """Ukranian local route"""
  PrivatBank

  """Singapore local route"""
  Singapore

  """Singapore mobile payment network PayNow"""
  SingaporePaynow

  """British local route"""
  SortCode

  """South Korean payment network Paygate"""
  SouthKoreanPaygate

  """South Korean payment network Paygate for corporates"""
  SouthKoreanPaygateBusiness

  """South African local route"""
  SouthAfrica

  """Swift"""
  SwiftCode

  """Thai local route"""
  Thailand

  """Turkish local route"""
  TurkishEarthport

  """Uruguayan local route"""
  Uruguay

  """Vietnamese local route"""
  VietnameEarthport
}

type InternationalCreditTransferTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!
  supportingDocumentCollections(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: SupportingDocumentCollectionFilterInput
  ): SupportingDocumentCollectionConnection!

  """matching account for this transaction"""
  account: Account

  """amount"""
  amount: Amount!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """created date"""
  createdAt: DateTime!

  """creditor information"""
  creditor: InternationalCreditTransferCreditor!

  """debtor information"""
  debtor: InternationalCreditTransferDebtor!

  """
  The delivery estimate indicates the expected time for the transfer to reach the beneficiary's bank account.
  """
  estimatedDeliveryAt: DateTime

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """@deprecated(reason: "use `quote.feesAmount` instead")"""
  fees: Amount

  """instructed amount"""
  instructedAmount: Amount

  """instructed amount"""
  intermediaryBankFees: [Amount!]

  """label"""
  label: String!

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """payment associated to this transaction"""
  payment: Payment

  """ID of the payment associated to this transaction"""
  paymentId: String

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """quote given by our international provider"""
  currencyExchange: InternationalCreditTransferCurrencyExchange!

  """external identifier of the transaction"""
  reference: String!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """return reason"""
  returnReason: TransactionReasonCode

  """side (Credit or Debit)"""
  side: TransactionSide!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """type"""
  type: TransactionTypeEnum!

  """updated date"""
  updatedAt: DateTime!

  """true if a transaction statement can be generated for this transaction"""
  statementCanBeGenerated: Boolean

  """project id of the transaction"""
  projectId: ID!

  """International beneficiary linked to the transaction"""
  beneficiary: InternationalBeneficiary
}

"""Rejection returned on invalid argument error"""
type InvalidArgumentRejection implements Rejection {
  message: String!
  code: InvalidArgumentRejectionCode!
  fields: [InvalidArgumentRejectionField!]!
}

enum InvalidArgumentRejectionCode {
  INVALID_INPUT
}

type InvalidArgumentRejectionField {
  name: String!
  errors: [String!]!
}

"""InvalidVerification"""
type InvalidBeneficiaryVerification {
  message: String!
}

"""Information about the invalidity of the IBAN"""
type InvalidIban {
  """Iban from input"""
  iban: IBAN!

  """Enum that can be used to discriminate on the error"""
  code: InvalidIbanCode!

  """Message that give a bit of context during development"""
  message: String!
}

"""InvalidIbanCode"""
enum InvalidIbanCode {
  """
  Iban is either too short (<2) or does not match this country's specified length
  """
  InvalidLength

  """
  We do not know this IBAN Structure (Meaning that the country code is probably wrong)
  """
  InvalidStructure

  """The IBAN does not verify the mod97 algorithm"""
  InvalidChecksum

  """We do not know the banking institution referenced in this IBAN."""
  InvalidBank
}

"""
Describes an invalid identification level for the process associated to this identification, and the invalid reason can be accessed
"""
type InvalidIdentificationLevelStatusInfo {
  """Always set to `Invalid`"""
  status: SwanIdentificationStatus!

  """The reasons why this identification level is invalid"""
  reasons: [IdentificationInvalidReason!]
}

type InvalidMerchantPaymentMethodError {
  code: InvalidMerchantPaymentMethodErrorCode!
  message: String!
  type: String!
  id: String
}

enum InvalidMerchantPaymentMethodErrorCode {
  AlreadyActive
  AlreadyInactive
  Suspended
  MissingPaymentMethod
  InvalidSepaDirectDebitConfiguration
}

type InvalidPaymentMethodRequestRejection implements Rejection {
  paymentMethods: [InvalidMerchantPaymentMethodError!]!
  message: String!
}

"""Rejection returned if phone number is not well formatted"""
type InvalidPhoneNumberRejection implements Rejection {
  message: String!
}

"""Rejection returned if siren number is not well formatted"""
type InvalidSirenNumberRejection implements Rejection {
  message: String!
}

"""Invoice"""
type Invoice {
  """unique id"""
  id: ID!

  """account id"""
  accountId: ID!

  """name of the invoice"""
  name: String!

  """type of the invoice"""
  type: InvoiceType!

  """status of the invoice"""
  status: InvoiceStatus!

  """due amount"""
  amount: Amount!

  """temporary public url on which the file can be accessible"""
  url: String

  """date at which the link will not be useable anymore"""
  expiresAt: DateTime

  """starting date of the billing window"""
  openingDate: DateTime!

  """ending date of the billing window"""
  closingDate: DateTime!

  """creation date"""
  createdAt: DateTime!

  """last update date"""
  updatedAt: DateTime!
}

"""Please see the Connection interface"""
type InvoiceConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Int!
  edges: [InvoiceEdge!]!
}

"""Please see the Edge interface"""
type InvoiceEdge implements Edge {
  node: Invoice!
  cursor: String!
}

"""The different statuses of invoice"""
enum InvoiceStatus {
  Failed
  NotPaid
  Paid
  PaymentDue
  Pending
  Voided
}

enum InvoiceType {
  Invoice
  RefundNote
}

"""Key value details"""
type KeyValue {
  """Key"""
  key: String!

  """Value"""
  value: String!
}

enum Language {
  de
  en
  fr
  it
  nl
  es
}

type LegalDocument {
  """ID of the legal document"""
  id: ID!

  """Type of the legal document"""
  type: LegalDocumentType!

  """Status of the Legal Document"""
  statusInfo: LegalDocumentStatusInfo!

  """Language of the Legal Document"""
  language: AccountLanguage!

  """Url to download the Document"""
  url: String!
}

type LegalDocumentActiveStatusInfo implements LegalDocumentStatusInfo {
  """
  LegalDocument status (always Active for type LegalDocumentActiveStatusInfo)
  """
  status: LegalDocumentStatus!

  """Creation date"""
  createdAt: DateTime!

  """Activation date"""
  activatedAt: DateTime
}

"""
Implements the Relay Connection interface, used to paginate the list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type LegalDocumentConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """LegalDocumentEdge list"""
  edges: [LegalDocumentEdge!]!
}

"""Implements the Relay Edge interface"""
type LegalDocumentEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The account membership"""
  node: LegalDocument!
}

type LegalDocumentInactiveStatusInfo implements LegalDocumentStatusInfo {
  """
  LegalDocument status (always Inactive for type LegalDocumentInactiveStatusInfo)
  """
  status: LegalDocumentStatus!

  """Creation date"""
  createdAt: DateTime!

  """Activation date"""
  activatedAt: DateTime

  """Deactivation date"""
  deactivatedAt: DateTime
}

input LegalDocumentsFilterInput {
  status: LegalDocumentStatus
  type: LegalDocumentType
}

enum LegalDocumentStatus {
  """When the LegalDocument will be the next active on the account"""
  Upcoming

  """When the LegalDocument is currently active on the account"""
  Active

  """When the LegalDocument is no more active on the account"""
  Inactive
}

interface LegalDocumentStatusInfo {
  """LegalDocument Status"""
  status: LegalDocumentStatus!
}

enum LegalDocumentType {
  """Swan Terms & Conditions of Use"""
  SwanTCU
}

type LegalDocumentUpcomingStatusInfo implements LegalDocumentStatusInfo {
  """
  LegalDocument status (always Upcoming for type LegalDocumentUpcomingStatusInfo)
  """
  status: LegalDocumentStatus!

  """Creation date"""
  createdAt: DateTime!

  """Date when the LegalDocument will be activated"""
  effectiveDate: DateTime
}

type LegalRepresentativeAccountMembershipCannotBeDisabledRejection implements Rejection {
  accountMembershipId: String!
  message: String!
}

type LegalRepresentativeAccountMembershipCannotBeSuspendedRejection implements Rejection {
  id: String!
  message: String!
}

type LegalRepresentativeEmailCannotBeUpdatedRejection {
  message: String!
}

type LegalRepresentativePermissionsCannotBeUpdatedRejection {
  message: String!
}

"""Language: ISO 639-1 language code"""
enum MandateLanguage {
  de
  en
  fr
  it
  nl
  es
  pt
  fi
}

"""
Rejection returned when the project has already reached the maximum daily exports
"""
type MaximumDailyExportsReachedRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the project has already started exports of the same type
"""
type MaximumSimultaneousExportsRejection implements Rejection {
  message: String!
}

input MembershipInfoInput {
  """Email address"""
  email: String!

  """Restricted to a user if necessary"""
  restrictedTo: RestrictedToInput!

  """
  `true` if this account membership can view account balances and transactions history
  """
  canViewAccount: Boolean!

  """`true` if this account membership can add or canceled beneficiaries"""
  canManageBeneficiaries: Boolean!

  """`true` if this account membership can initiate credit transfers"""
  canInitiatePayments: Boolean!

  """
  `true` if this account membership can invite, update, suspend or resume account membership
  """
  canManageAccountMembership: Boolean!

  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean

  """Residency address of the member to be added"""
  residencyAddress: ResidencyAddressInput

  """Tax Identification Number of the user added"""
  taxIdentificationNumber: String

  """Language of the account membership"""
  language: AccountLanguage
}

"""Filters that can be applied when listing account memberships"""
input MembershipsFilterInput {
  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean

  """Can the user initiate payments on this account"""
  canInitiatePayments: Boolean

  """Can the user manage account membership"""
  canManageAccountMembership: Boolean

  """Can the user manage beneficiaries"""
  canManageBeneficiaries: Boolean

  """Can the user view account"""
  canViewAccount: Boolean

  """Account memberships status/statuses we're looking for"""
  status: [AccountMembershipStatus!]

  """
  Search by email
  
  @deprecated(reason: "use `search` instead")
  """
  email: String

  """
  Search by first name
  
  @deprecated(reason: "use `search` instead")
  """
  firstName: String

  """
  Search by last name
  
  @deprecated(reason: "use `search` instead")
  """
  lastName: String

  """
  Search string to look for
  
  Search will be performed in following fields:
   - First name
   - Last name
   - Email
   - ID
  """
  search: String

  """Filter by user"""
  userId: String
}

"""
The different balances of the payment. Use this to understand in details what actions have been taken on the payment and what actions can be taken moving forward.
"""
type MerchantBalance {
  """The amount that can be canceled on this payment"""
  availableToCancel: Amount!

  """The amount that can be captured on this payment"""
  availableToCapture: Amount!

  """The amount that can be refunded on this payment"""
  availableToRefund: Amount!

  """The amount authorised"""
  totalAuthorized: Amount!

  """The amount canceled"""
  totalCanceled: Amount!

  """The amount captured"""
  totalCaptured: Amount!

  """The amount disputed"""
  totalDisputed: Amount!

  """The amount refunded"""
  totalRefunded: Amount!
}

"""Rejection returned when the Merchant Card Payment is declined"""
type MerchantCardPaymentDeclinedRejection implements Rejection {
  message: String!
}

enum MerchantCategory {
  Culture
  Entertainment
  Finance
  Groceries
  HealthAndBeauty
  HomeAndUtilities
  Other
  ProfessionalServices
  PublicAdministrations
  Restaurants
  Shopping
  Software
  Transport
  Travel
}

"""MerchantCategoryDescription"""
enum MerchantCategoryDescription {
  AccessoryAndApparelStoresMiscellaneous
  AccountingAuditingAndBookkeepingServices
  AdvertisingServices
  AgriculturalCooperatives
  AirCarriersAirlinesNotElsewhereClassified
  AirConditioningAndRefrigerationRepairShops
  AirConditioningHeatingAndPlumbingContractors
  AirlinesAirCarriers
  AirportsAirportTerminalsFlyingFields
  AlterationsMendingSeamstressesTailors
  AmbulanceServices
  AmusementParksCarnivalsCircusesFortuneTellers
  AntiqueReproductionStores
  AntiqueShopsSalesRepairsAndRestorationServices
  ApplianceRepairShopsElectricalAndSmall
  AquariumsDolphinariumsZoosAndSeaquariums
  ArchitecturalEngineeringAndSurveyingServices
  ArtDealersAndGalleries
  ArtistSupplyStoresCraftShops
  AssociationsCivicSocialAndFraternal
  AthleticFieldsCommercialSportsProfessionalSportsClubsSportsPromoters
  AttorneysLegalServices
  AutomatedCashDisbursementsCustomerFinancialInstitution
  AutomobileAndTruckDealersSalesServiceRepairsPartsAndLeasing
  AutomobileAndTruckDealersUsedOnlySales
  AutomobileAssociations
  AutomobileParkingLotsAndGarages
  AutomobileRentalAgencyNotElsewhereClassified
  AutomotiveBodyRepairShops
  AutomotivePaintShops
  AutomotivePartsAccessoriesStores
  AutomotiveServiceShops
  AutomotiveTireStores
  AutoStoreHomeSupplyStores
  BailAndBondPayments
  Bakeries
  BandsOrchestrasAndMiscellaneousEntertainersNotElsewhereClassified
  BarberAndBeautyShops
  BarsCocktailLoungesDiscothequesNightclubsAndTavernsDrinkingPlacesAlcoholicBeverages
  BicycleShopsSalesAndService
  BoatDealers
  BoatLeasesAndBoatRentals
  BooksPeriodicalsAndNewspapers
  BookStores
  BowlingAlleys
  BridgeAndRoadFeesTolls
  BuildingMaterialsLumberStores
  BusinessServicesNotElsewhereClassified
  BusLines
  BuyingOrShoppingClubsServices
  CableSatelliteAndOtherPayTelevisionAndRadioServices
  CameraAndPhotographicSupplyStores
  CamperDealersRecreationalAndUtilityTrailers
  CampgroundsAndTrailerParks
  CandyNutConfectioneryStores
  CardGiftNoveltyAndSouvenirShops
  CarpentryContractors
  CarpetAndUpholsteryCleaning
  CarRentalAgencies
  CarWashes
  Caterers
  ChemicalsAndAlliedProductsNotElsewhereClassified
  ChildCareServices
  ChildrenAndInfantsWearStores
  ChiropodistsPodiatrists
  Chiropractors
  CigarStoresAndStands
  CleaningAndMaintenanceJanitorialServices
  CleaningGarmentAndLaundryServices
  ClockJewelryAndWatchRepairShops
  ClockJewelryWatchAndSilverwareStore
  ClothingRentalCostumesUniformsAndFormalWear
  ClubsCountryClubsMembershipAthleticRecreationSportsPrivateGolfCourses
  CollegesUniversitiesProfessionalSchoolsAndJuniorColleges
  CommercialArtGraphicsPhotography
  CommercialEquipmentNotElsewhereClassified
  CommercialFootwear
  ComputerMaintenanceRepairAndServicesNotElsewhereClassified
  ComputerNetworkOrInformationServices
  ComputerProgrammingDataProcessingAndIntegratedSystemsDesignServices
  ComputersComputerPeripheralEquipmentSoftware
  ComputerSoftwareStores
  ConcreteWorkContractors
  ConstructionMaterialsNotElsewhereClassified
  ConsultingManagementAndPublicRelationsServices
  ConsumerCreditReportingAgencies
  ContractorsSpecialTradeNotElsewhereClassified
  CosmeticStores
  CourierServiceAirAndGroundFreightForwarders
  CourtCostsIncludingAlimonyAndChildSupport
  CruiseLines
  CrystalAndGlasswareStores
  DairyProductsStores
  DanceHallsSchoolsAndStudios
  DatingServices
  DebtMarriagePersonalCounselingService
  DentalAndMedicalLaboratories
  DentalLaboratoryMedicalOphthalmicHospitalEquipmentAndSupplies
  DentistsOrthodontists
  DepartmentStores
  DetectiveAgenciesProtectiveAgenciesSecurityServicesIncludingArmoredCarsGuardDogs
  DigitalGoodsAudiovisualMediaIncludingBooksMoviesAndMusic
  DigitalGoodsGames
  DigitalGoodsMultiCategory
  DigitalGoodsSoftwareApplicationsExcludingGames
  DirectMarketingCatalogMerchants
  DirectMarketingCombinationCatalogAndRetailMerchants
  DirectMarketingContinuitySubscriptionMerchants
  DirectMarketingInboundTelemarketingMerchants
  DirectMarketingInsuranceServices
  DirectMarketingOtherDirectMarketersNotElsewhereClassified
  DirectMarketingOutboundTelemarketingMerchants
  DirectMarketingTravelRelatedArrangementServices
  DiscountStores
  DoctorsNotElsewhereClassified
  DoorToDoorSales
  DraperyUpholsteryAndWindowCoveringsStores
  DrugsDrugProprietorsAndDruggistsSundries
  DrugStoresPharmacies
  DryCleaners
  DurableGoodsNotElsewhereClassified
  DutyFreeStores
  EatingPlacesRestaurants
  ElectricalContractors
  ElectricalPartsAndEquipment
  ElectricRazorStoresSalesAndService
  ElectricVehicleCharging
  ElectronicRepairShops
  ElectronicSales
  EmploymentAgenciesTemporaryHelpServices
  EquipmentFurnitureAndHomeFurnishingsStoresExceptAppliances
  EquipmentRentalAndLeasingServicesFurnitureRentalToolRental
  ExterminatingAndDisinfectingServices
  FabricNeedleworkPieceGoodsAndSewingStores
  FamilyClothingStores
  FastFoodRestaurants
  Fines
  FireplaceFireplaceScreensAndAccessoriesStores
  FloorCoveringStores
  Florists
  FloristsSuppliesNurseryStockAndFlowers
  FreezerLockerMeatProvisioners
  FuelDealersCoalFuelOilLiquefiedPetroleumWood
  FuelDispenserAutomated
  FuneralServiceAndCrematories
  FurnitureReupholsteryAndRepairRefinishing
  FurriersAndFurShops
  GamblingTransactions
  GameToyAndHobbyShops
  GeneralContractorsResidentialAndCommercial
  GlassPaintWallpaperStores
  GolfCoursesPublic
  GovernmentLicensedHorseOrDogRacingUSRegionOnly
  GovernmentOwnedLotterySpecificCountries
  GovernmentOwnedLotteryUSRegionOnly
  GovernmentServicesNotElsewhereClassified
  GroceryStoresSupermarkets
  HardwareEquipmentAndSupplies
  HardwareStores
  HatCleaningShopsShoeRepairShopsShoeShineParlors
  HealthAndBeautySpas
  HealthPractitionersMedicalServicesNotElsewhereClassified
  HearingAidsSalesServiceSupplyStores
  HomeSupplyWarehouseStores
  HorticulturalAndLandscapingServices
  Hospitals
  HouseholdApplianceStores
  IndustrialSuppliesNotElsewhereClassified
  InformationRetrievalServices
  InsulationMasonryPlasteringStoneworkAndTileSettingContractors
  InsuranceSalesUnderwritingAndPremiums
  InternetGamblingUSRegionOnly
  IntraGovernmentPurchasesGovernmentOnly
  KeyEntryTelecomMerchantProvidingSingleLocalAndLongDistancePhoneCallsUsingACentralAccessNumberInANonFaceToFaceEnvironmentUsingKeyEntry
  LaundryServicesFamilyAndCommercial
  LawnAndGardenSupplyStores
  LeatherGoodsAndLuggageStores
  LimousinesAndTaxicabs
  LodgingHotelsMotelsResorts
  LodgingHotelsMotelsResortsNotElsewhereClassified
  ManualCashDisbursementsCustomerFinancialInstitution
  MarinasMarineServiceSupplies
  MassageParlors
  MenAndBoysClothingAndAccessoriesStores
  MenAndWomenClothingStores
  MenWomenAndChildrenUniformsAndCommercialClothing
  MerchandiseAndServicesCustomerFinancialInstitution
  MetalServiceCentersAndOffices
  MiscellaneousAndSpecialtyRetailStores
  MiscellaneousAutomotiveAircraftAndFarmEquipmentDealersNotElsewhereClassified
  MiscellaneousFoodStoresConvenienceStoresMarketsSpecialtyStores
  MiscellaneousGeneralMerchandiseStores
  MiscellaneousHouseFurnishingSpecialtyShops
  MiscellaneousPublishingAndPrinting
  MiscellaneousRepairShopsAndRelatedServices
  MobileHomeDealers
  MoneySendFunding
  MoneySendInterCountry
  MoneySendIntraCountry
  MoneyTransfer
  MotionPictureAndVideoTapeProductionAndDistribution
  MotionPictureTheaters
  MotorcycleShopsAndDealers
  MotorFreightCarriersTruckingLocalLongDistanceMovingAndStorageCompaniesLocalDelivery
  MotorHomeAndRecreationalVehicleRental
  MotorHomeDealers
  MotorVehicleSuppliesAndNewParts
  MusicStoresMusicalInstrumentsPianosSheetMusic
  NewsDealersAndNewsstands
  NondurableGoodsNotElsewhereClassified
  NursingAndPersonalCareFacilities
  OfficeAndCommercialFurniture
  OfficePhotographicPhotocopyAndMicrofilmEquipment
  OfficeSchoolSupplyAndStationeryStores
  OpticiansOpticalGoodsAndEyeglasses
  OptometristsOphthalmologists
  OrganizationsCharitableAndSocialService
  OrganizationsMembershipNotElsewhereClassified
  OrganizationsPolitical
  OrganizationsReligious
  OrthopedicGoodsArtificialLimbStores
  OsteopathicPhysicians
  OtherServicesNotElsewhereClassified
  PackageStoresBeerWineAndLiquor
  PaintsVarnishesAndSupplies
  PassengerRailways
  PawnShops
  PaymentTransactionCustomerFinancialInstitution
  PaymentTransactionMerchant
  PetroleumAndPetroleumProducts
  PetShopsPetFoodAndSupplies
  PhotoDevelopingPhotofinishingLaboratories
  PhotographicStudios
  PieceGoodsNotionsAndOtherDryGoods
  PlumbingAndHeatingEquipment
  PoiFundingTransactions
  PoolAndBilliardEstablishments
  PostalServicesGovernmentOnly
  PreciousStonesAndMetalsWatchesAndJewelry
  ProfessionalServicesNotElsewhereClassified
  PublicWarehousingFarmProductsRefrigeratedGoodsHouseholdGoodsStorage
  QuasiCashCustomerFinancialInstitution
  QuasiCashMerchant
  QuickCopyReproductionAndBlueprintingServices
  RailroadsFreight
  RealEstateAgentsAndManagersRentals
  RecordShops
  RecreationalAndSportingCamps
  RecreationServicesNotElsewhereClassified
  ReligiousGoodsStores
  RoofingAndSidingSheetMetalWorkContractors
  SalvageAndWreckingYards
  SanitationPolishingAndSpecialtyCleaningPreparations
  SchoolsAndEducationalServicesNotElsewhereClassified
  SchoolsBusinessAndSecretarial
  SchoolsCorrespondence
  SchoolsElementaryAndSecondary
  SchoolsTradeAndVocational
  SecondHandStoresUsedMerchandiseStores
  SecuritiesBrokersDealers
  ServiceStationsWithOrWithoutAncillaryServices
  ShoeStores
  SnowmobileDealers
  SportingGoodsStores
  SportsApparelRidingApparelStores
  StampAndCoinStoresPhilatelicAndNumismaticSupplies
  StationeryOfficeSuppliesPrintingAndWritingPaper
  StenographicAndSecretarialSupportServices
  SwimmingPoolsSalesAndSupplies
  TaxPayments
  TaxPreparationService
  TelecommunicationEquipmentIncludingTelephoneSales
  TelecommunicationServicesIncludingButNotLimitedToPrepaidPhoneServicesAndRecurringPhoneServices
  TelegraphServices
  TentAndAwningShops
  TestingLaboratoriesNonMedical
  TheatricalProducersExceptMotionPicturesAndTicketAgencies
  Timeshares
  TireRetreadingAndRepairShops
  TouristAttractionsAndExhibits
  TowingServices
  TransportationServicesNotElsewhereClassified
  TransportationSuburbanAndLocalCommuterPassengerIncludingFerries
  TravelAgenciesAndTourOperators
  TruckRental
  TypesettingPlateMakingAndRelatedServices
  TypewriterStoresRentalsSalesService
  Unknown
  UtilitiesElectricGasHeatingOilSanitaryWater
  VarietyStores
  VeterinaryServices
  VideoAmusementGameSupplies
  VideoEntertainmentRentalStores
  VideoGameArcadesOrEstablishments
  WeldingRepair
  WholesaleClubs
  WigAndToupeeShops
  WomenAccessoryAndSpecialtyStores
  WomenReadyToWearStores
}

type MerchantPayment {
  """unique identifier of a merchant payment"""
  id: ID!

  """
  List of transactions associated with the Merchant Payment.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  transactions(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: TransactionsOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """status information"""
  statusInfo: MerchantPaymentStatusInfo!

  """amount"""
  amount: Amount!

  """unique identifier of the payment mandate associated to the payment"""
  paymentMandateId: ID!

  """unique identifier of the payment link associated to the payment"""
  paymentLinkId: ID

  """unique identifier of the merchant profile associated to the payment"""
  merchantProfileId: ID!

  """unique identifier of the payment method associated to the payment"""
  paymentMethodId: ID!
  balance: MerchantBalance!

  """Label"""
  label: String
  reference: String

  """
  an arbitrary identifier that was defined by you when you created this payment
  """
  externalReference: String

  """The billing address associated to the payment"""
  billingAddress: Address
  threeDS: ThreeDS

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Authorized date"""
  authorizedAt: DateTime

  """Canceled date"""
  canceledAt: DateTime

  """Captured date"""
  capturedAt: DateTime

  """Rejected date"""
  rejectedAt: DateTime

  """Refunded date"""
  refundedAt: DateTime

  """Disputed date"""
  disputedAt: DateTime
}

"""Merchant Payment status authorized"""
type MerchantPaymentAuthorized implements MerchantPaymentStatusInfo {
  """status of the merchant payment"""
  status: MerchantPaymentStatus!
}

"""Merchant Payment status captured"""
type MerchantPaymentCaptured implements MerchantPaymentStatusInfo {
  """status of the merchant payment"""
  status: MerchantPaymentStatus!
}

type MerchantPaymentConnection implements Connection {
  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """Edge list"""
  edges: [MerchantPaymentEdge!]!

  """Total number of element in the list"""
  totalCount: Int!
}

type MerchantPaymentEdge implements Edge {
  node: MerchantPayment!

  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

input MerchantPaymentFiltersInput {
  """To filter on some Merchant Payment Link Status (all if empty)"""
  status: [MerchantPaymentStatus!]

  """To filter on some Merchant Payment Method Type (all if empty)"""
  paymentMethod: [MerchantPaymentMethodType!]

  """To filter after a createdAt value"""
  isAfterCreatedAt: DateTime

  """To filter before a createdAt value"""
  isBeforeCreatedAt: DateTime

  """To filter on some text occurrences (words or ids)"""
  search: String
  amountSmallerThan: AmountValue
  amountGreaterThan: AmountValue
}

"""Merchant Payment status initiated"""
type MerchantPaymentInitiated implements MerchantPaymentStatusInfo {
  """status of the merchant payment"""
  status: MerchantPaymentStatus!
}

type MerchantPaymentLink {
  """Merchant payment link's unique ID."""
  id: String!

  """ID of the related project"""
  projectId: ID!

  """The URL at which the customer can complete the payment."""
  url: String!

  """The merchant payment link status."""
  statusInfo: MerchantPaymentLinkStatusInfo!

  """The Merchant Profile to link this Payment Link to"""
  merchantProfile: MerchantProfile!

  """Amount to be paid to successfully complete the payment."""
  amount: Amount!

  """
  Merchant Website URL to redirect the user to when the payment is completed.
  """
  redirectUrl: String

  """URL to redirect the user to if they cancel their payment"""
  cancelRedirectUrl: String

  """
  Controls if the payment mandate created from this payment link is for one-time use or can be reused
  This is applicable for card and SEPA Direct Debit payment methods only.
  """
  sequence: PaymentMandateSequence!

  """
  The customer billing Address
  These fields should be completed also to pre-fill a SEPA direct debit mandate.
  
  We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes
  """
  billingAddress: Address

  """
    A date that reflects the time at which the user asked the transaction to be executed.
  For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
  For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
  
  Default value means that the execution will be as soon as possible
  """
  requestedExecutionAt: DateTime

  """
  Any string that you want to be attached to this payment link.
  Usually something to help you reference the link in an external system.
  """
  externalReference: String

  """
  Optional field intended to provide a way for you to include a reference number or code.
  The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different.
  """
  reference: String

  """
  The language used for the payment page.
  Default is the browser's language, or English if not available.
  """
  language: String

  """
  Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page.
  """
  label: String

  """
   We will use the information specified here to prefill the payment link fields
  depending on the payment method the end user chooses.
  Keep in mind that your end customer will be able to edit these fields.
  """
  customer: Customer

  """
  List of payment methods IDs enabled for this payment link.
  If the array is empty Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit)
  """
  paymentMethods: [MerchantPaymentMethod!]!
  createdAt: DateTime!
}

type MerchantPaymentLinkConnection implements Connection {
  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """Edge list"""
  edges: [MerchantPaymentLinkEdge!]!

  """Total number of element in the list"""
  totalCount: Int!
}

type MerchantPaymentLinkEdge implements Edge {
  node: MerchantPaymentLink!

  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

input MerchantPaymentLinkFiltersInput {
  """To filter on some Merchant Payment Link Status (all if empty)"""
  status: [MerchantPaymentLinkStatus!]

  """To filter after a createdAt value"""
  isAfterCreatedAt: DateTime

  """To filter before a createdAt value"""
  isBeforeCreatedAt: DateTime

  """To filter on some text occurrences (words or ids)"""
  search: String

  """
  To filter payment links having an amount smaller than the given criteria
  """
  amountSmallerThan: AmountValue

  """
  To filter payment links having an amount greater than the given criteria
  """
  amountGreaterThan: AmountValue
}

enum MerchantPaymentLinkOrderByFieldInput {
  createdAt
  label
  url
}

input MerchantPaymentLinkOrderByInput {
  field: MerchantPaymentLinkOrderByFieldInput
  direction: OrderByDirection
}

enum MerchantPaymentLinkStatus {
  """Customers can still use the merchant payment link to pay."""
  Active

  """The merchant payment link is expired."""
  Expired

  """The customer completed the payment."""
  Completed
}

interface MerchantPaymentLinkStatusInfo {
  status: MerchantPaymentLinkStatus!
}

"""Base object for the different Payment Methods available"""
interface MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve
}

"""The different rejection reasons for a CardMerchantPaymentMethod"""
enum MerchantPaymentMethodCardRejectReason {
  SwanRefused
  UnsupportedBusiness
  SwanTechnicalErrorOccurred
}

"""Rejection returned when the Merchant Payment Method is not active"""
type MerchantPaymentMethodNotActiveRejection implements Rejection {
  paymentMethodIds: [String!]
  message: String!
}

type MerchantPaymentMethodSepaDirectDebitInvalidRejection implements Rejection {
  message: String!
}

"""The different statuses a MerchantPaymentMethod can have"""
enum MerchantPaymentMethodStatus {
  PendingReview
  Enabled
  Rejected
  Disabled
  Suspended
}

"""The payment method status information"""
interface MerchantPaymentMethodStatusInfo {
  """Merchant Payment Method Status"""
  status: MerchantPaymentMethodStatus!
}

"""The different statuses a MerchantPaymentMethod can have"""
enum MerchantPaymentMethodType {
  InternalDirectDebitStandard
  InternalDirectDebitB2b
  SepaDirectDebitCore
  SepaDirectDebitB2b
  Check
  Card
}

interface MerchantPaymentMethodUpdateRequest {
  id: ID!
}

type MerchantPaymentMethodWrongStatusRejection implements Rejection {
  message: String!
}

enum MerchantPaymentOrderByFieldInput {
  label
  createdAt
  externalReference
  status
  amount
}

input MerchantPaymentOrderByInput {
  field: MerchantPaymentOrderByFieldInput
  direction: OrderByDirection
}

"""Merchant Payment status rejected"""
type MerchantPaymentRejected implements MerchantPaymentStatusInfo {
  """status of the merchant payment"""
  status: MerchantPaymentStatus!

  """rejected reason"""
  reason: String!
}

"""Merchant Payment status"""
enum MerchantPaymentStatus {
  Initiated
  Authorized
  Captured
  Rejected
}

"""Merchant Payment Status Information"""
interface MerchantPaymentStatusInfo {
  """status of the merchant payment"""
  status: MerchantPaymentStatus!
}

"""Merchant Profile"""
type MerchantProfile {
  """The Merchant Profile ID"""
  id: ID!

  """The Account ID this Merchant Profile is linked to"""
  accountId: ID!

  """
  Business name of the merchant, i.e. name that will be displayed on debtors' bank statements
  """
  merchantName: String!

  """Url of the merchant's website"""
  merchantWebsite: String

  """Url of the merchant's logo"""
  merchantLogoUrl: String

  """The status of the merchant profile"""
  statusInfo: MerchantProfileStatusInfo!

  """
  Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
  """
  productType: ProductType!

  """Expected annual activity volumes for all payment method"""
  expectedMonthlyPaymentVolume: Amount!

  """Payment Methods associated"""
  merchantPaymentMethods: [MerchantPaymentMethod!]

  """Updates Requested associated"""
  requestedMerchantProfileUpdates: [RequestMerchantProfileUpdate!] @deprecated

  """Update Requested associated"""
  requestMerchantProfileUpdate: RequestMerchantProfileUpdate

  """expected average basket value."""
  expectedAverageBasket: Amount!

  """
  Your accent color, used in white label interfaces.
  This color would also be inherited in the Swan Merchant Payment page.
  """
  accentColor: String

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!
  merchantPaymentLinks(first: Int! = 50, after: String, orderBy: MerchantPaymentLinkOrderByInput, filters: MerchantPaymentLinkFiltersInput): MerchantPaymentLinkConnection
  merchantPayments(first: Int! = 50, after: String, orderBy: MerchantPaymentOrderByInput, filters: MerchantPaymentFiltersInput): MerchantPaymentConnection
}

type MerchantProfileConnection implements Connection {
  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """Edge list"""
  edges: [MerchantProfileEdge!]!

  """Total number of element in the list"""
  totalCount: Int!
}

type MerchantProfileEdge implements Edge {
  node: MerchantProfile!

  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!
}

"""Filters that can be applied when listing Funding Sources"""
input MerchantProfileFiltersInput {
  status: [MerchantProfileStatus!]!
}

type MerchantProfileNotValidRejection implements Rejection {
  message: String!
}

enum MerchantProfileOrderByFieldInput {
  createdAt
  updatedAt
}

input MerchantProfileOrderByInput {
  field: MerchantProfileOrderByFieldInput
  direction: OrderByDirection
}

"""Merchant Profile Statuses"""
enum MerchantProfileStatus {
  """A Merchant Profile is created in the PendingReview status"""
  PendingReview

  """Enabled"""
  Enabled

  """Rejected"""
  Rejected

  """Suspended"""
  Suspended

  """Disabled"""
  Disabled
}

"""Merchant Profile Status Information"""
interface MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
}

"""
Rejection returned when the Merchant Profile is not in the expected status
"""
type MerchantProfileWrongStatusRejection implements Rejection {
  message: String!
  currentStatus: MerchantProfileStatus!
  expectedStatus: MerchantProfileStatus!
}

enum MerchantSubCategory {
  Education
  Museums
  CinemasAndShows
  GamblingAndBettingActivities
  OtherLeisureActivities
  StreamingPlatforms
  ThemeParks
  TicketsAndEvents
  VideoGames
  FinancialServices
  Insurance
  LiquorStore
  SupermarketsAndOtherGroceryStores
  FitnessAndSports
  Hairdressing
  Healthcare
  Pharmacies
  SpaAndBeautyTreatments
  ConstructionAndOddJobs
  EnergyProviders
  Gardening
  Laundries
  PhoneAndInternetServicesProviders
  RealEstate
  CharityAndNonProfitOrganizations
  ReligiousOrganizations
  AdvertisingAndMarketing
  BookkeepingAndConsultancy
  CourierAndLogistics
  IndustrialCleaning
  LegalActivities
  OtherProfessionalServices
  StationaryServices
  GovernmentAndCityCouncils
  BarsAndRestaurants
  CoffeeAndBakeries
  FoodDelivery
  PubsAndNightclubs
  BooksAndNewspapers
  CigarShops
  ClothingShoesAndAccessories
  ComputersAndElectronicDevices
  DepartmentStores
  Furniture
  GamesAndToys
  HardwareStores
  HouseholdItems
  Pets
  SoftwareServices
  CarRental
  MetroBusAndTrains
  MotorVehiclesRepairsAndAccessories
  OtherTransportProviders
  PrivateMobilityServices
  ServiceStations
  TollsAndParkings
  Airlines
  FerriesAndBoats
  HotelsAndAccommodation
  TravelAgents
  AtmWithdrawal
  OfficeRental
  HrAndRecruiting
  Flowers
  OtherStores
  PerfumesAndCosmetics
  Other
}

type MissingBirthDateRejection {
  message: String!
}

"""Rejection returned when mandatory fields are missing from the call."""
type MissingMandatoryFieldRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the phone number is missing and the account membership has advanced permissions
"""
type MissingPhoneNumberRestrictionRejection implements Rejection {
  message: String!
}

"""Monthly income."""
enum MonthlyIncome {
  """less than 500"""
  LessThan500

  """between 500 and 1500"""
  Between500And1500

  """between 1500 and 3000"""
  Between1500And3000

  """between 3000 and 4500"""
  Between3000And4500

  """more than 4500"""
  MoreThan4500
}

"""Monthly payment volume."""
enum MonthlyPaymentVolume {
  Between10000And50000
  Between50000And100000
  LessThan10000
  MoreThan100000
}

type Mutation {
  """
  Add a new account membership to an account.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
  
  *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.*
  """
  addAccountMembership(input: AddAccountMembershipInput!): AddAccountMembershipPayload!

  """
  Add multiple new account memberships to account
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
  
  *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.*
  """
  addAccountMemberships(input: AddAccountMembershipsInput!): AddAccountMembershipsPayload!

  """
  Add an external balance to an external account.
  
  This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  addExternalAccountBalance(input: AddExternalAccountBalanceInput!): AddExternalAccountBalancePayload! @deprecated(reason: "use `AddOrUpdateExternalAccountBalance` instead")

  """
  Add an external account to an account holder.
  
  This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  addExternalAccount(input: AddExternalAccountInput!): AddExternalAccountPayload!

  """
  Add a new request for funding limit settings change.
  
  This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  addFundingLimitSettingsChangeRequest(input: AddFundingLimitSettingsChangeRequestInput!): AddFundingLimitSettingsChangeRequestPayload!

  """
  Add an external balance to an external account.
  If a balance already exist for the day, the balance amount will be updated.
  
  This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  addOrUpdateExternalAccountBalance(input: AddOrUpdateExternalAccountBalanceInput!): AddOrUpdateExternalAccountBalancePayload!

  """Add a new Virtual IBAN."""
  addVirtualIbanEntry(input: AddVirtualIbanInput): AddVirtualIbanEntryPayload

  """Allows to receive Sepa Direct Debit on a Virtual IBAN."""
  allowSddVirtualIbanEntry(input: AllowSddVirtualIbanEntryInput!): AllowSddVirtualIbanEntryPayload!

  """Allows to receive Sepa Direct Debit on an account."""
  allowSdd(input: AllowSddInput!): AllowSddPayload!

  """
  Bind a user to an account membership
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
  """
  bindAccountMembership(input: BindAccountMembershipInput!): BindAccountMembershipPayload!

  """Cancels a Virtual IBAN."""
  cancelVirtualIbanEntry(input: CancelVirtualIbanEntryInput!): CancelVirtualIbanEntryPayload!

  """
  Closes an account.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
  
  *The user must have a legal representative account membership for this account.*
  """
  closeAccount(input: CloseAccountInput!): CloseAccountPayload!

  """Allows to refuse all Sepa Direct Debit received on a Virtual IBAN."""
  denySddVirtualIbanEntry(input: DenySddVirtualIbanEntryInput!): DenySddVirtualIbanEntryPayload!

  """Allows to refuse all Sepa Direct Debit received on an account."""
  denySdd(input: DenySddInput): DenySddPayload!

  """
  Disable an account membership
  
  This mutation is callable with a User access token and a Project access token ([Learn More](https://docs.swan.io/api/authentication))
  
  With a User access token, the user must have the permission to manage account membership of the account
  """
  disableAccountMembership(input: DisableAccountMembershipInput): DisableAccountMembershipPayload!

  """
  Finalize an onboarding led to the opening of a new account for your client, who thus become the account holder.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)).*
  """
  finalizeOnboarding(input: FinalizeOnboardingInput!): FinalizeOnboardingPayload!

  """
  Generate and return a presigned URL to upload a file to justify a transaction
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  generateTransactionSupportingDocumentUploadUrl(input: GenerateTransactionSupportingDocumentUploadUrlInput!): GenerateTransactionSupportingDocumentUploadUrlPayload!

  """
  Creates an onboarding for a new company account holder.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  onboardCompanyAccountHolder(input: OnboardCompanyAccountHolderInput): OnboardCompanyAccountHolderPayload!

  """
  Creates an onboarding for a new individual account holder.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  onboardIndividualAccountHolder(input: OnboardIndividualAccountHolderInput): OnboardIndividualAccountHolderPayload!

  """
  Resumes an account membership already suspended.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
  
  *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.*
  """
  resumeAccountMembership(input: ResumeAccountMembershipInput): ResumeAccountMembershipPayload!

  """
  Suspends an account membership.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)).
  
  *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.*
  """
  suspendAccountMembership(input: SuspendAccountMembershipInput!): SuspendAccountMembershipPayload!
  updateAccountHolder(input: UpdateAccountHolderInput!): UpdateAccountHolderPayload!

  """
  Updates an account membership.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
  
  *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.*
  """
  updateAccountMembership(input: UpdateAccountMembershipInput!): UpdateAccountMembershipPayload!

  """Update an account."""
  updateAccount(input: UpdateAccountInput!): UpdateAccountPayload!

  """
  Updates a company onboarding.
  
  If you aim to update Ultimate Beneficiary Owners, you need to provide all of them as they are going to be overridden by your update payload.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  updateCompanyOnboarding(input: UpdateCompanyOnboardingInput): UpdateCompanyOnboardingPayload!

  """
  Updates an individual onboarding.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  updateIndividualOnboarding(input: UpdateIndividualOnboardingInput!): UpdateIndividualOnboardingPayload!
  updateSupportingDocument(input: UpdateSupportingDocumentInput!): UpdateSupportingDocumentPayload!

  """
  Delete a supporting document, in case uploaded file is not what was wanted. This action can not be undone.
  
  This mutation can only be used on an "Uploaded" supporting document of a "WaitingForDocument" supporting document collection.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  deleteSupportingDocument(input: DeleteSupportingDocumentInput!): DeleteSupportingDocumentPayload!

  """
  Generate and return a presigned URL to upload a unique file for the supporting document collection
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  generateSupportingDocumentUploadUrl(input: GenerateSupportingDocumentUploadUrlInput!): GenerateSupportingDocumentUploadUrlPayload!

  """
  Ask for Swan's compliance team to review given supporting document collection.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  requestSupportingDocumentCollectionReview(input: RequestSupportingDocumentCollectionReviewInput): RequestSupportingDocumentCollectionReviewPayload!

  """Generate an account statement"""
  generateAccountStatement(input: GenerateAccountStatementInput!): Statement!

  """
  Generate a transaction statement for a booked incoming or outgoing Credit Transfer.
  """
  generateTransactionStatement(input: GenerateTransactionStatementInput!): GenerateTransactionStatementPayload!

  """
  Cancel a capital deposit case.
  
  This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  cancelCapitalDepositCase(input: CancelCapitalDepositCaseInput!): CancelCapitalDepositCasePayload!

  """
  Create a capital deposit case.
  
  This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  createCapitalDepositCase(input: CreateCapitalDepositCaseInput!): CreateCapitalDepositCasePayload!

  """
  Generate an url allowing the upload of a document which unique identifier is specified in parameters.
  
  This mutation is restricted to an Project access token ([Learn More](https://docs.swan.io/api/authentication)).
  """
  generateCapitalDepositDocumentUploadUrl(input: GenerateCapitalDepositDocumentUploadUrlInput!): GenerateCapitalDepositDocumentUploadUrlPayload!

  """Cancel a Card"""
  cancelCard(input: CancelCardInput): CancelCardPayload!

  """Cancel a physical card."""
  cancelPhysicalCard(input: CancelPhysicalCardInput): CancelPhysicalCardPayload!

  """
  Resume a Physical Card.
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have the account membership for this card
  """
  resumePhysicalCard(input: ResumePhysicalCardInput): ResumePhysicalCardPayload!

  """Suspend a Physical Card."""
  suspendPhysicalCard(input: SuspendPhysicalCardInput): SuspendPhysicalCardPayload!

  """
  Activate a Physical Card.
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have the account membership for this card
  """
  activatePhysicalCard(input: ActivatePhysicalCardInput!): ActivatePhysicalCardPayload!

  """
  Add a new card to an account membership.
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership for this account with the permission `canManageCards=true`.
  """
  addCard(input: AddCardInput!): AddCardPayload!

  """
  Add several cards with Group Delivery
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.
  """
  addCardsWithGroupDelivery(input: AddCardsWithGroupDeliveryInput!): AddCardsWithGroupDeliveryPayload!

  """
  Add several cards
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.
  """
  addCards(input: AddCardsInput!): AddCardsPayload!

  """
  Add a Digital Card to push to ApplePay or GooglePay
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must be the cardholder
  
  A digital card will only be valid for 1 hour after consent validation
  """
  addDigitalCard(input: AddDigitalCardInput): AddDigitalCardPayload!

  """Add a new Single Use Virtual Card to an account membership."""
  addSingleUseVirtualCard(input: AddSingleUseVirtualCardInput!): AddSingleUseVirtualCardPayload!

  """
  Add several single-use virtual cards
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.
  """
  addSingleUseVirtualCards(input: AddSingleUseVirtualCardsInput!): AddSingleUseVirtualCardsPayload!

  """Cancel a Digital Card"""
  cancelDigitalCard(input: CancelDigitalCardInput): CancelDigitalCardPayload!

  """Confirm Physical Card Renewal"""
  confirmPhysicalCardRenewal(input: ConfirmPhysicalCardRenewalInput!): ConfirmPhysicalCardRenewalPayload!

  """
  Print Physical Card.
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  """
  printPhysicalCard(input: PrintPhysicalCardInput!): PrintPhysicalCardPayload!

  """Update a Card."""
  updateCard(input: UpdateCardInput): UpdateCardPayload

  """
  Reveal the card numbers in the consent page once consent has been given by the cardholder
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have the account membership for this card
  """
  viewCardNumbers(input: ViewCardNumbersInput!): ViewCardNumbersPayload!

  """
  Obtain individual iframes containing sensitive card information from an accepted consent
  
  This mutation is restricted to user access token ([Learn More](https://docs.swan.io/developers/using-api/authentication/#tokens-user)).
  
  Conditions apply
  """
  viewCardNumbersWithConsent(input: ViewCardNumbersWithConsentInput!): ViewCardNumbersWithConsentPayload!

  """
  Reveal the physical card numbers in the consent page once consent has been given by the cardholder
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have the account membership for this card
  """
  viewPhysicalCardNumbers(input: ViewPhysicalCardNumbersInput!): ViewPhysicalCardNumbersPayload!

  """
  Reveal the PIN code on Swan app after his consent
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have the account membership for this card
  """
  viewPhysicalCardPin(input: ViewPhysicalCardPinInput!): ViewPhysicalCardPinPayload!

  """Create a temporary download link for a completed export."""
  generateExportDownloadLink(input: GenerateExportDownloadLinkInput!): GenerateExportDownloadLinkPayload

  """Delete file with exported data."""
  deleteExportFile(input: DeleteExportFileInput!): DeleteExportFilePayload

  """
  Export all onboardings of a project (`projectId` found in context).
  
  NB: This mutation only starts an asynchronous process and returns its identifier.
  """
  exportOnboardingData(input: ExportOnboardingDataInput!): ExportDataPayload

  """
  Export all users of a project (`projectId` found in context).
  
  NB: This mutation only starts an asynchronous process and returns its identifier.
  """
  exportUserData(input: ExportUserDataInput!): ExportDataPayload

  """Cancels a consent."""
  cancelConsent(input: CancelConsentInput!): CancelConsentPayload!

  """COMING SOON"""
  acceptConsent(input: AcceptConsentInput!): AcceptConsentPayload

  """COMING SOON : Complete User Creation"""
  completeUserCreation(input: CompleteUserCreationInput!): CompleteUserCreationPayload!

  """
  Create a multi consent, which represents a consent of several other consents,
  executed in parallel or sequentially depending on the `order` input value
  
  This mutation is restricted to a User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  """
  createMultiConsent(input: CreateMultiConsentInput!): CreateMultiConsentPayload

  """Deactivate an User"""
  deactivateUser(input: DeactivateUserInput!): DeactivateUserPayload!

  """Grant consent with a server signature"""
  grantConsentWithServerSignature(input: GrantConsentWithServerSignatureInput!): GrantConsentWithServerSignaturePayload!

  """COMING SOON"""
  startUserCreation(input: StartUserCreationInput!): StartUserCreationPayload!

  """
  Updates user preferred consent notification channel.
  
  *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  updateUserConsentSettings(input: UpdateUserConsentSettingsInput!): UpdateUserConsentSettingsPayload!

  """
  Allows to add a received internal direct debit mandate B2b.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
  
  *The user must be able to initiate payments for this account.*
  """
  addReceivedInternalDirectDebitB2bMandate(input: AddReceivedInternalDirectDebitB2bMandateInput!): AddReceivedInternalDirectDebitB2bMandatePayload!

  """
  Allows to add a received sepa direct debit mandate B2b.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
  
  *The user must be able to initiate payments for this account.*
  """
  addReceivedSepaDirectDebitB2bMandate(input: AddReceivedSepaDirectDebitB2bMandateInput!): AddReceivedSepaDirectDebitB2bMandatePayload!

  """
  Allows to enable a received mandate in the Suspended status.
  
  *For B2b received direct debit mandate, this mutation is restricted to an User access token([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
  
  *The user must be able to initiate payments for this account.*
  """
  enableReceivedDirectDebitMandate(input: EnableReceivedDirectDebitMandateInput!): EnableReceivedDirectDebitMandatePayload!

  """
  Allows to suspend a received direct debit mandate in the Enabled status.
  
  *The user must be able to initiate payments for this account.*
  """
  suspendReceivedDirectDebitMandate(input: SuspendReceivedDirectDebitMandateInput!): SuspendReceivedDirectDebitMandatePayload!

  """
  Allows to update a received sepa direct debit mandate B2b.
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
  
  *The user must be able to initiate payments for this account.*
  """
  updateReceivedSepaDirectDebitB2bMandate(input: UpdateReceivedSepaDirectDebitB2bMandateInput!): UpdateReceivedSepaDirectDebitB2bMandatePayload!

  """Allows to add an internal direct debit payment mandate."""
  addInternalDirectDebitPaymentMandate(input: AddInternalDirectDebitPaymentMandateInput!): AddInternalDirectDebitPaymentMandatePayload!

  """Add a merchant profile to a company account holder"""
  addMerchantProfile(input: AddMerchantProfileInput!): AddMerchantProfilePayload
  addSepaDirectDebitPaymentMandate(input: AddSepaDirectDebitPaymentMandateInput!): AddSepaDirectDebitPaymentMandatePayload

  """Cancel a MerchantPaymentMethod update request"""
  cancelMerchantPaymentMethodUpdateRequest(input: CancelMerchantPaymentMethodUpdateRequestInput!): CancelMerchantPaymentMethodUpdateRequestPayload

  """Cancel a MerchantProfile update request"""
  cancelMerchantProfileUpdateRequest(input: CancelMerchantProfileUpdateRequestInput!): CancelMerchantProfileUpdateRequestPayload
  initiateCheckMerchantPayment(input: InitiateCheckMerchantPaymentInput!): InitiateCheckMerchantPaymentPayload

  """Create a unique URL for a merchant to collect payment from a customer"""
  createMerchantPaymentLink(input: CreateMerchantPaymentLinkInput!): CreateMerchantPaymentLinkPayload!

  """Disable a merchant payment method"""
  disableMerchantPaymentMethod(input: DisableMerchantPaymentMethodInput!): DisableMerchantPaymentMethodPayload

  """Disable a merchant profile"""
  disableMerchantProfile(input: DisableMerchantProfileInput!): DisableMerchantProfilePayload
  initiateMerchantPaymentCollection(input: InitiateMerchantPaymentCollectionInput!): InitiateMerchantPaymentCollectionPayload
  requestMerchantPaymentMethodsUpdate(input: RequestMerchantPaymentMethodsUpdateInput!): RequestMerchantPaymentMethodsUpdatePayload

  """Request merchant payment methods for a merchant profile"""
  requestMerchantPaymentMethods(input: RequestMerchantPaymentMethodsInput!): RequestMerchantPaymentMethodsPayload

  """Request an update of a MerchantProfile"""
  requestMerchantProfileUpdate(input: RequestMerchantProfileUpdateInput!): RequestMerchantProfileUpdatePayload

  """
  Cancels an UPCOMING credit transfer
  
   *The user must have an account membership for this account with the attribute `canInitiatePayments=true`.*
  """
  cancelTransaction(input: CancelTransactionInput!): CancelTransactionPayload!

  """
  Initiates a credit transfer to an other Swan account or to an IBAN
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and if necessary ask the user to consent to this request.*
  
  *The user must have an account membership for this account with the attribute `canInitiatePayments=true`.*
  """
  initiateCreditTransfers(input: InitiateCreditTransfersInput!): InitiateCreditTransfersPayload!

  """
  initiates a refund for a list of booked transaction
  
  *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and if necessary ask the user to consent to this request.*
  
  *The user must have an account membership on the accounts that are beneficiary of the transaction with the attribute `canInitiatePayments=true`.*
  """
  refund(input: RefundInput!): RefundPayload!

  """
  Add a funding source to an account
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.
  """
  addDirectDebitFundingSource(input: AddDirectDebitFundingSourceInput!): AddDirectDebitFundingSourcePayload

  """
  Add an international trusted beneficiary to an account
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  """
  addTrustedInternationalBeneficiary(input: AddTrustedInternationalBeneficiaryInput!): AddTrustedInternationalBeneficiaryPayload

  """
  Add a trusted SEPA beneficiary to an account
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  """
  addTrustedSepaBeneficiary(input: AddTrustedSepaBeneficiaryInput!): AddTrustedSepaBeneficiaryPayload

  """Cancel a funding source"""
  cancelFundingSource(input: CancelFundingSourceInput!): CancelFundingSourcePayload

  """
  Cancel a standing Order
  
  The user must have an account membership to the account and the permission to initiate credit transfer
  """
  cancelStandingOrder(input: CancelStandingOrderInput!): CancelStandingOrderPayload!

  """
  Initiate a funding request.
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)).
  The user must have an account membership for this account with the attribute `canInitiateCreditTransfer=true`.
  """
  initiateFundingRequest(input: InitiateFundingRequestInput!): InitiateFundingRequestPayload

  """Create an international transfer"""
  initiateInternationalCreditTransfer(input: InitiateInternationalCreditTransferInput!): InitiateInternationalCreditTransferResponsePayload

  """
  COMING SOON
  
  Initiates a refund on a booked transaction.
  
  This mutation is restricted to a User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership for this account with the attribute `canInitiatePayments=true`.
  """
  returnTransaction(input: ReturnTransactionInput!): ReturnTransactionPayload!

  """
  Schedule a standing Order
  
  This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
  
  The user must have an account membership to the account and the permission to initiate credit transfer
  """
  scheduleStandingOrder(input: ScheduleStandingOrderInput!): ScheduleStandingOrderPayload!

  """
  Probe a Webhook callback endpoint
  It will send a test event with a random id and the test event type
  It will return the status code of the response
  if the endpoint responds and the generated event id
  """
  probeWebhookEndpoint(input: ProbeWebhookEndpointInput!): ProbeWebhookEndpointPayload!

  """Replays the endpoint call of a previous event"""
  replayWebhookEvent(input: ReplayWebhookEventInput!): ReplayWebhookEventPayload!

  """Add a webhook subscription"""
  addWebhookSubscription(input: AddWebhookSubscriptionInput!): WebhookSubscriptionPayload!

  """Update a Webhook Subscription"""
  updateWebhookSubscription(input: UpdateWebhookSubscriptionInput!): WebhookSubscriptionPayload!

  """Remove a webhook subscription"""
  removeWebhookSubscription(input: WebhookSubscriptionIdInput!): RemoveWebhookSubscriptionPayload!
}

input NestedWebhookEventLogFiltersInput {
  statusCode: Int
  statusText: StatusText
  startDate: DateTime
  endDate: DateTime
  eventType: String
  eventId: ID
  resourceId: ID
}

"""Rejection returned when the User status is not allowed"""
type NotAllowedUserStatusRejection implements Rejection {
  message: String!
}

"""
Rejection returned if the entity was not found or if the user does not have the rights to know that the account exists
"""
type NotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Rejection returned when consent status couldn't change"""
type NotReachableConsentStatusRejection implements Rejection {
  message: String!
  currentStatus: ConsentStatus
  unreachableStatus: ConsentStatus
}

"""
@deprecated Use 'StartedIdentificationLevelStatusInfo' instead. Deprecated to ensure consistency and clear identification status behavior
Describes an identification level that hasn't started for the process of the current identification
"""
type NotStartedIdentificationLevelStatusInfo {
  """Always set to `NotStarted`"""
  status: SwanIdentificationStatus! @deprecated(reason: "Use 'Started' instead. Deprecated to ensure consistency and clear identification status behavior.")
}

"""
Rejection returned if the queried service doesn't support the country code
"""
type NotSupportedCountryRejection implements Rejection {
  message: String!
}

"""
Describes an identification level that's not supported for the process of the current identification
"""
type NotSupportedIdentificationLevelStatusInfo {
  """Always set to `NotSupported`"""
  status: SwanIdentificationStatus!
}

"""Extra parameters provided by partner"""
type OAuthRedirectParameters {
  """
  Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity.
  """
  state: String

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  """
  redirectUrl: String
}

input OAuthRedirectParametersInput {
  """
  Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity. Length must be from 0 to 255 characters
  """
  state: String

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. Length must be from 0 to 255 characters
  """
  redirectUrl: String
}

"""Inputs to onboard a new company account holder"""
input OnboardCompanyAccountHolderInput {
  """
  Account name of the company account holder.
  - Length must be from 0 to 100 characters
  """
  accountName: String

  """
  Company name.
  - Length must be from 0 to 100 characters.
  - Valid format (regex):
    ```
    /^(?:(?<!http(s)*:\/\/|www\.|&lt;|&gt;)[!-.\/-;A-Z[-`a-zÀ-ÖÙ-öº-ƿǄ-ʯʹ-ʽΈ-ΊΎ-ΡΣ-ҁҊ-Ֆա-ևႠ-Ⴥა-ჺᄀ-፜፩-ᎏᵫ-ᶚḀ-῾ⴀ-ⴥ⺀-⿕ぁ-ゖゝ-ㇿ㋿-鿯鿿-ꒌꙀ-ꙮꚀ-ꚙꜦ-ꞇꞍ-ꞿꥠ-ꥼＡ-Ｚａ-ｚ/]|¿|¡| |'|-|Ά|Ό|=|\?|@|\[|]|\||‘|’)*$/
    ```
  """
  name: String

  """
  Registration number of the company (for example, Système d'Identification du Répertoire des ENtreprises [SIREN] in France, ...).
  - Length must be from 0 to 50 characters.
  """
  registrationNumber: String

  """Type of the company (Association ...)."""
  companyType: CompanyType

  """Business activity."""
  businessActivity: BusinessActivity

  """
  Description of the business activity.
  - Length must be from 0 to 1024 characters.
  """
  businessActivityDescription: String

  """Country of the account created at the end of onboarding."""
  accountCountry: AccountCountry

  """Estimated monthly payment volume (euro)."""
  monthlyPaymentVolume: MonthlyPaymentVolume

  """
  The ultimate beneficial owner is defined as the natural person (s) who own or control, directly and/or indirectly, the reporting company.
  
  The ultimate beneficial owner is :
  - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
  - either the natural person (s) who exercise, by other means, a power of control of the company;
  """
  individualUltimateBeneficialOwners: [IndividualUltimateBeneficialOwnerInput!]

  """
  Residency address of the head office.
  - Must be in a European country.
  """
  residencyAddress: ResidencyAddressInput

  """
  Email of the legal representative.
  - Length must be from 0 to 255 characters.
  - Valid format (regex):
    ```
    /^[A-Z0-9_+.-]*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9-]*\.)+[A-Z]{2,}$/i
    ```
  - Some email providers are not accepted by our system.
  """
  email: String

  """
  Language of the onboarding process.
  - Accepted languages: `["en", "fr", "nl", "de", "it", "es", "pt", "fi"]`
  """
  language: String

  """
  URL used to redirect the user at the end of the onboarding process.
  - If `null` the user is redirected to the white label web banking.
  - Length must be from 0 to 255 characters
  """
  redirectUrl: String

  """
  Is the company registered with their country's national register (for example, Registre du Commerce et des Sociétés [RCS] in France).
  """
  isRegistered: Boolean

  """Extra parameters provided by partner."""
  oAuthRedirectParameters: OAuthRedirectParametersInput

  """
  VAT number of the company.
  - (AT)?U[0-9]{8} |                              # Austria
  - (BE)?0[0-9]{9} |                              # Belgium
  - (BG)?[0-9]{9,10} |                            # Bulgaria
  - (CY)?[0-9]{8}L |                              # Cyprus
  - (CZ)?[0-9]{8,10} |                            # Czech Republic
  - (DE)?[0-9]{9} |                               # Germany
  - (DK)?[0-9]{8} |                               # Denmark
  - (EE)?[0-9]{9} |                               # Estonia
  - (EL|GR)?[0-9]{9} |                            # Greece
  - (ES)?[0-9A-Z][0-9]{7}[0-9A-Z] |               # Spain
  - (FI)?[0-9]{8} |                               # Finland
  - (FR)?[0-9A-Z]{2}[0-9]{9} |                    # France
  - (GB)?([0-9]{9}([0-9]{3})?|[A-Z]{2}[0-9]{3}) | # United Kingdom
  - (HU)?[0-9]{8} |                               # Hungary
  - (IE)?[0-9]S[0-9]{5}L |                        # Ireland
  - (IT)?[0-9]{11} |                              # Italy
  - (LT)?([0-9]{9}|[0-9]{12}) |                   # Lithuania
  - (LU)?[0-9]{8} |                               # Luxembourg
  - (LV)?[0-9]{11} |                              # Latvia
  - (MT)?[0-9]{8} |                               # Malta
  - (NL)?[0-9]{9}B[0-9]{2} |                      # Netherlands
  - (PL)?[0-9]{10} |                              # Poland
  - (PT)?[0-9]{9} |                               # Portugal
  - (RO)?[0-9]{2,10} |                            # Romania
  - (SE)?[0-9]{12} |                              # Sweden
  - (SI)?[0-9]{8} |                               # Slovenia
  - (SK)?[0-9]{10}                                # Slovakia
  """
  vatNumber: String

  """
    Tax Identification Number.
  - Must be from 0 to 16 characters.
  """
  taxIdentificationNumber: String

  """Legal representative personal address."""
  legalRepresentativePersonalAddress: AddressInformationInput

  """Type of representation (legal representative or power of attorney)."""
  typeOfRepresentation: TypeOfRepresentation
}

union OnboardCompanyAccountHolderPayload = OnboardCompanyAccountHolderSuccessPayload | BadRequestRejection | ForbiddenRejection | ValidationRejection

type OnboardCompanyAccountHolderSuccessPayload {
  onboarding: Onboarding!
}

"""Information on the shareholder."""
input OnboardCompanyShareholderInput {
  """Amount the shareholder has to deposit."""
  capitalDepositAmount: AmountInput!

  """Name ("Dénomination sociale") of the shareholder."""
  name: String!

  """Information required for the onboarding of a company shareholder."""
  onboardingInfo: OnboardCompanyAccountHolderInput!
}

"""Inputs to onboard a new individual account holder"""
input OnboardIndividualAccountHolderInput {
  """
  Account name of the individual account holder.
  - Length must be from 0 to 100 characters.
  """
  accountName: String

  """Country of the account created at the end of onboarding."""
  accountCountry: AccountCountry

  """Employment status of the individual account holder."""
  employmentStatus: EmploymentStatus

  """Monthly income of the individual account holder (euro)."""
  monthlyIncome: MonthlyIncome

  """
  Residency address of the individual account holder.
  - Must be in a European country.
  """
  residencyAddress: ResidencyAddressInput

  """
  Email of the legal representative.
  - Length must be from 0 to 255 characters.
  - Valid format (regex):
    ```
    /^[A-Z0-9_+.-]*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9-]*\.)+[A-Z]{2,}$/i
    ```
  - Some email providers are not accepted by our system.
  """
  email: String

  """
  Language of the onboarding process.
  - Accepted languages: `["en", "fr", "nl", "de", "it", "es", "pt", "fi"]`
  """
  language: String

  """
  URL used to redirect the user at the end of the onboarding process.
  - If `null` the user is redirected to the white label web banking.
  - Length must be from 0 to 255 characters
  """
  redirectUrl: String

  """Extra parameters provided by partner."""
  oAuthRedirectParameters: OAuthRedirectParametersInput

  """
  Tax Identification Number.
  - Must be from 0 to 16 characters.
  """
  taxIdentificationNumber: String
}

union OnboardIndividualAccountHolderPayload = OnboardIndividualAccountHolderSuccessPayload | ForbiddenRejection | ValidationRejection

type OnboardIndividualAccountHolderSuccessPayload {
  onboarding: Onboarding!
}

"""Information on the shareholder."""
input OnboardIndividualShareholderInput {
  """First name of the shareholder."""
  firstName: String!

  """Last name of the shareholder."""
  lastName: String!

  """Birthdate of the shareholder in the YYYY/MM/DD format."""
  birthDate: String!

  """CCA3 code for the country of nationality of the shareholder."""
  nationality: CCA3!

  """Amount the shareholder has to deposit."""
  capitalDepositAmount: AmountInput!

  """Information required for the onboarding of a individual shareholder."""
  onboardingInfo: OnboardIndividualAccountHolderInput!
}

"""
Information provided during the onboarding process of an individual or a company
"""
type Onboarding {
  """Unique identifier of an onboarding"""
  id: String!

  """Account name"""
  accountName: String

  """Account Country"""
  accountCountry: AccountCountry!

  """Creation date"""
  createdAt: DateTime!

  """Email"""
  email: String

  """Finalization date"""
  finalizedAt: DateTime

  """
  Language of the onboarding process.
  - Accepted languages: `["en", "fr", "nl", "de", "it", "es", "pt", "fi"]`
  """
  language: String

  """Information regarding the Individual or the company to onboard"""
  info: OnboardingAccountHolderInfo!

  """Account holder created at the end of the onboarding process"""
  accountHolder: AccountHolder

  """
  Redirect the legal representative of a new account holder to this URL to start the onboarding process
  """
  onboardingUrl: String

  """Current computed state of onboarding"""
  onboardingState: OnboardingState!

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  """
  redirectUrl: String! @deprecated(reason: "Use `redirectUrl` field on oauthRedirectParameters parameters instead.")

  """Extra parameters provided by partner"""
  oAuthRedirectParameters: OAuthRedirectParameters

  """Status (valid/invalid/finalized) and details of errors on fields"""
  statusInfo: OnboardingStatusInfo!

  """Swan TCU URL"""
  tcuUrl: String!

  """List of supporting document collection owned by the account holder."""
  supportingDocumentCollection: SupportingDocumentCollection!

  """Creation date"""
  updatedAt: DateTime!

  """Account opened after the onboarding finalization"""
  account: Account

  """List of accepted identification level for the legal representative"""
  legalRepresentativeAcceptedIdentificationLevels: [IdentificationLevel]!

  """Recommended identification level for the legal representative"""
  legalRepresentativeRecommendedIdentificationLevel: IdentificationLevel!
}

"""The onboarding could be for an Individual or a company"""
interface OnboardingAccountHolderInfo {
  """Account holder type"""
  type: AccountHolderType!
}

"""Company Account Holder Information"""
type OnboardingCompanyAccountHolderInfo implements OnboardingAccountHolderInfo {
  """
  Account holder type (always Company for type OnboardingCompanyAccountHolderInfo)
  """
  type: AccountHolderType!

  """Name of the company."""
  name: String

  """
  Registration number of the company (for example, Système d'Identification du Répertoire des ENtreprises [SIREN] in France, ...).
  - Length must be from 0 to 50 characters.
  """
  registrationNumber: String

  """legal form of the company (SAS, SCI, SASU, ...)"""
  companyType: CompanyType

  """business activity"""
  businessActivity: BusinessActivity

  """
  business activity description
  This must be 1024 characters long maximum.
  """
  businessActivityDescription: String

  """estimated monthly payment volume (euro)"""
  monthlyPaymentVolume: MonthlyPaymentVolume

  """
  The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
  
  The ultimate beneficiary is :
  - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
  - either the natural person (s) who exercise, by other means, a power of control of the company;
  """
  individualUltimateBeneficialOwners: [IndividualUltimateBeneficialOwner!]

  """residency address of the head office (Must be in a European country)"""
  residencyAddress: AddressInfo

  """Is company registered at RCS in its country"""
  isRegistered: Boolean

  """
  Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT
  """
  vatNumber: String

  """Tax Identification Number"""
  taxIdentificationNumber: String

  """Legal representative personal address"""
  legalRepresentativePersonalAddress: AddressInformation

  """Type of representation (legal representative or power of attorney)"""
  typeOfRepresentation: TypeOfRepresentation
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type OnboardingConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """OnboardingEdge list"""
  edges: [OnboardingEdge!]!
}

"""Implements the Relay Edge interface"""
type OnboardingEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The Onboarding"""
  node: Onboarding!
}

"""Filters that can be applied when listing onboardings"""
input OnboardingFiltersInput {
  """
  Search by email
  
  @deprecated(reason: "use `search` instead")
  """
  email: String

  """
  Search string to look for
  
  Search will be performed in following fields:
   - Account holder's first name
   - Account holder's last name
   - Account holder's company name
   - Account holder's ID
   - Email
   - ID
  """
  search: String

  """Filter by status"""
  status: [OnboardingStatus!]

  """Filter by type"""
  types: [AccountHolderType!]
}

"""StatusInfo when onboarding has been finalized"""
type OnboardingFinalizedStatusInfo implements OnboardingStatusInfo {
  status: OnboardingStatus!
}

"""Individual Account Holder Information"""
type OnboardingIndividualAccountHolderInfo implements OnboardingAccountHolderInfo {
  """
  Account holder type (always Individual for type OnboardingIndividualAccountHolderInfo)
  """
  type: AccountHolderType!

  """employment status of the individual account holder"""
  employmentStatus: EmploymentStatus

  """monthly income of the individual account holder"""
  monthlyIncome: MonthlyIncome

  """
  residency address of the individual account holder (must be in a European country)
  """
  residencyAddress: AddressInfo

  """Tax Identification Number"""
  taxIdentificationNumber: String
}

type OnboardingInfo {
  """Unique identifier of an onboarding"""
  id: String!

  """Account name"""
  accountName: String

  """
  Country of the account that will be created at the end of the onboarding process
  """
  accountCountry: AccountCountry

  """email"""
  email: String

  """
  Language of the onboarding process.
  - Accepted languages: `["en", "fr", "nl", "de", "it", "es", "pt", "fi"]`
  """
  language: String

  """Information regarding the Individual or the company to onboard"""
  info: OnboardingAccountHolderInfo!

  """
  Redirect the legal representative of a new account holder to this URL to start the onboarding process
  """
  onboardingUrl: String!

  """Current computed state of onboarding"""
  onboardingState: OnboardingState

  """
  URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
  """
  redirectUrl: String!

  """Project infos you set in the dashboard"""
  projectInfo: ProjectInfo

  """Verification Flow"""
  verificationFlow: VerificationFlow!

  """Extra parameters provided by partner"""
  oAuthRedirectParameters: OAuthRedirectParameters

  """Status (valid/invalid/finalized) and details of errors on fields"""
  statusInfo: OnboardingStatusInfo!

  """Supporting document collection related to onboarding."""
  supportingDocumentCollection: SupportingDocumentCollection!

  """List of accepted identification level for the legal representative"""
  legalRepresentativeAcceptedIdentificationLevels: [IdentificationLevel]!

  """Recommended identification level for the legal representative"""
  legalRepresentativeRecommendedIdentificationLevel: IdentificationLevel!

  """Swan TCU URL"""
  tcuUrl: String!
}

"""StatusInfo when onboarding has still at least one incorrect field"""
type OnboardingInvalidStatusInfo implements OnboardingStatusInfo {
  status: OnboardingStatus!
  errors: [ValidationError!]!
}

"""Rejection returned if an onboarding is not completed"""
type OnboardingNotCompletedRejection implements Rejection {
  message: String!
  onboardingId: String! @deprecated(reason: "use `onboarding.id` instead")
  onboarding: Onboarding!
}

"""
Field we can use when ordering that can be applied when listing onboardings
"""
enum OnboardingOrderByFieldInput {
  createdAt
  updatedAt
  finalizedAt
}

"""Order that can be applied when listing onboardings"""
input OnboardingOrderByInput {
  field: OnboardingOrderByFieldInput
  direction: OrderByDirection
}

"""Onboarding process state"""
enum OnboardingState {
  """When the onboarding is in progress"""
  Ongoing

  """When the onboarding is finalized and the account holder is created"""
  Completed
}

"""Possible values for onboarding status"""
enum OnboardingStatus {
  """When the onboarding is finalized"""
  Finalized

  """when the onboarding is invalid. Final status"""
  Invalid

  """When the onboarding is valid. Final status"""
  Valid
}

"""
Object containing details about onboarding status (valid/invalid and why it is invalid/already finalized)
"""
interface OnboardingStatusInfo {
  """
  Current onboarding status. Onboarding can only be finalized if status is "valid"
  """
  status: OnboardingStatus!
}

"""
StatusInfo when onboarding has all onboarding fields are correctly filled
"""
type OnboardingValidStatusInfo implements OnboardingStatusInfo {
  status: OnboardingStatus!
}

type OperationNotAllowedRejection implements Rejection {
  message: String!
}

enum OrderByDirection {
  Asc
  Desc
}

"""https://www.twilio.com/docs/verify/supported-languages"""
enum OtpLocale {
  af
  ar
  ca
  cs
  da
  de
  el
  en
  es
  et
  fi
  fr
  he
  hi
  hr
  hu
  id
  it
  ja
  kn
  ko
  lt
  mr
  ms
  nb
  nl
  pl
  pt
  ro
  ru
  sk
  sv
  te
  th
  tl
  tr
  uk
  vi
  zh
}

"""
Implements PageInfo from the Relay Connections Specification - information about a page in the pagination mechanism
"""
type PageInfo {
  """Indicates whether more edges exist following this page"""
  hasNextPage: Boolean

  """Indicates whether more edges exist preceding this page"""
  hasPreviousPage: Boolean

  """Opaque identifier pointing to the first node of the page"""
  startCursor: String

  """Opaque identifier pointing to the last node of the page"""
  endCursor: String
}

"""Input version"""
input PartnerCloseAccountReasonInput {
  type: PartnerCloseAccountReasonType!
  message: String
}

"""Specific type for closing account action"""
enum PartnerCloseAccountReasonType {
  """Simple closing request"""
  ClosingRequested
}

"""Partnership Status Accepted"""
type PartnershipAcceptedStatusInfo implements PartnershipStatusInfo {
  """
  Partnership status (always Accepted for type PartnershipAcceptedStatusInfo)
  """
  status: PartnershipStatus!

  """Accepted date of the partnership for this account"""
  acceptedDate: DateTime!
}

"""Partnership Status canceled"""
type PartnershipCanceledStatusInfo implements PartnershipStatusInfo {
  """
  Partnership status (always Canceled for type PartnershipCanceledStatusInfo)
  """
  status: PartnershipStatus!

  """Accepted date of the partnership for this account"""
  acceptedDate: DateTime!

  """Canceled date of the partnership for this account"""
  canceledDate: DateTime!

  """Reason of the cancelation"""
  reason: String!
}

"""Partnership Status currently cancelling"""
type PartnershipCancelingStatusInfo implements PartnershipStatusInfo {
  """
  Partnership status (always Canceling for type PartnershipCancelingStatusInfo)
  """
  status: PartnershipStatus!

  """Accepted date of the partnership for this account"""
  acceptedDate: DateTime!

  """Canceled date of the partnership for this account"""
  canceledAfter: DateTime!
}

enum PartnershipStatus {
  """
  When the partnership is accepted by the account holder for this account
  """
  Accepted

  """When you decide to stop the partnership, you have 2 months notice"""
  Canceling

  """When the partnership was canceled by you or the account holder"""
  Canceled
}

"""Partnership Status information"""
interface PartnershipStatusInfo {
  """Status of the partnership for this account"""
  status: PartnershipStatus!
}

"""The document corresponding to a passport"""
type PassportDocument {
  """Unique identifier of the passport document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """The date at which the passport was issued"""
  issueDate: Date

  """The date at which the passport expires"""
  expiryDate: Date

  """Machine-readable zone code of the passport"""
  mrz: String

  """Number of the passport"""
  number: String

  """List of the associated files"""
  files: [PassportDocumentFile!]!
}

"""The file associated to the passport document"""
type PassportDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!

  """From which side the passport's picture was taken"""
  side: DocumentFileSide!
}

"""
A Payment represents a set of transactions linked to the same payment act.

This payment act can be initiated:
- either from a user
- either from a merchant
- either from you
- either from Swan
"""
type Payment {
  """unique identifier of a payment"""
  id: ID!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """status information"""
  statusInfo: PaymentStatusInfo!

  """
  list of transactions associated to this payment
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  transactions(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: TransactionsOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """standing order that has initiated this payment"""
  standingOrder: StandingOrder
}

enum PaymentAccountType {
  """When the account holder if the account hasn't met KYC requirements"""
  EMoney

  """When all KYC requirements are met"""
  PaymentService
}

"""Please see the Connection interface"""
type PaymentConnection implements Connection {
  pageInfo: PageInfo!
  edges: [PaymentEdge!]!
  totalCount: Int!
}

"""Payment status consent pending"""
type PaymentConsentPending implements PaymentStatusInfo {
  """status of the payment"""
  status: PaymentStatus!

  """The consent required to initiate this payment"""
  consent: Consent!
}

interface PaymentDirectDebitMandate {
  """Unique identifier of the Direct Debit Payment Mandate"""
  id: ID!
}

"""Please see the Connection interface"""
type PaymentEdge implements Edge {
  node: Payment!
  cursor: String!
}

"""Filters that can be applied when listing payments"""
input PaymentFiltersInput {
  status: [PaymentStatus!]
}

"""Payment status initiated"""
type PaymentInitiated implements PaymentStatusInfo {
  """status of the payment"""
  status: PaymentStatus!
}

"""Payment Level of the account"""
enum PaymentLevel {
  """When the account is limited to 0€ within 30 days and with no IBAN"""
  Limited

  """
  When the account holder is fully verified and then the account is unlimited with an IBAN
  """
  Unlimited
}

interface PaymentMandate {
  """Unique identifier of the Payment Mandate"""
  id: ID!

  """List of transactions associated with the Payment Mandate."""
  transactions(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """Custom name of the mandate"""
  name: String

  """Account Holder information"""
  accountHolder: AccountHolder!

  """Creation date of the Payment Mandate"""
  createdAt: DateTime!

  """Last Update date of the Payment Mandate"""
  updatedAt: DateTime!

  """
  Date of the the last transaction executed for the concerned Payment Mandate
  """
  executedAt: DateTime

  """Expiry date of the Payment Mandate"""
  expiredAt: Date

  """Payment Mandate status information"""
  statusInfo: PaymentMandateStatusInfo!
}

enum PaymentMandateCanceledReason {
  """When the user requested to cancel the Payment Mandate"""
  RequestedByUser

  """When the Payment Mandate is expired"""
  MandateExpired
}

"""Payment Mandate Canceled status information"""
type PaymentMandateCanceledStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Canceled for type PaymentMandateCanceledStatusInfo).
  """
  status: PaymentMandateStatus!

  """Reason behind the Payment Mandate Canceled status"""
  reason: PaymentMandateCanceledReason!

  """Date of Cancellation of the mandate."""
  canceledAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type PaymentMandateConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """PaymentMandateEdge list"""
  edges: [PaymentMandateEdge!]!
}

"""Payment Mandate Consent Pending status information"""
type PaymentMandateConsentPendingStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Enabled for type PaymentMandateEnableedStatusInfo).
  """
  status: PaymentMandateStatus!

  """Consent information required to enable the concerned Payment Mandate"""
  consent: Consent!
}

interface PaymentMandateCreditor {
  """Creditor UUID"""
  id: ID!

  """Creditor name"""
  name: String!

  """Creditor address"""
  address: Address!
}

interface PaymentMandateDebtor {
  """Debtor name"""
  name: String!

  """Debtor e-mail"""
  email: String

  """Debtor country"""
  country: CCA3!
}

"""Implements the Relay Edge interface"""
type PaymentMandateEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The payment mandate"""
  node: PaymentMandate!
}

"""Payment Mandate Enabled status information"""
type PaymentMandateEnabledStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Enabled for type PaymentMandateEnabledStatusInfo).
  """
  status: PaymentMandateStatus!
}

"""
Filter that can be passed to get the payment mandate in a specific data range
"""
input PaymentMandateFiltersInput {
  """To filter on status values"""
  status: [PaymentMandateStatus!]

  """To filter on scheme values"""
  scheme: [PaymentMandateScheme!]
}

"""Error returned if the payment mandate was not found"""
type PaymentMandateMandateNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""
Field we can use when ordering that can be applied when listing payment mandate results
"""
enum PaymentMandateOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing payment mandate results"""
input PaymentMandateOrderByInput {
  field: PaymentMandateOrderByFieldInput
  direction: OrderByDirection
}

"""
Rejection returned if the payment mandate reference is already used for the same creditor
"""
type PaymentMandateReferenceAlreadyUsedRejection implements Rejection {
  message: String!
}

"""Payment Mandate Rejected status information"""
type PaymentMandateRejectedStatusInfo implements PaymentMandateStatusInfo {
  """
  Payment Mandate status (always Rejected for type PaymentMandateSuspendedStatusInfo).
  """
  status: PaymentMandateStatus!
}

enum PaymentMandateScheme {
  """SEPA Direct Debit Core"""
  SepaDirectDebitCore

  """SEPA Direct Debit B2B"""
  SepaDirectDebitB2b

  """Internal Direct Debit Standard"""
  InternalDirectDebitStandard

  """Internal Direct Debit B2B"""
  InternalDirectDebitB2b

  """Card Visa"""
  CardVisa

  """Card Mastercard"""
  CardMastercard

  """Card Cartes Bancaires"""
  CardCartesBancaires
}

"""Payment Mandate Sequence"""
enum PaymentMandateSequence {
  """The Payment Mandate can be used for recurrent collections"""
  Recurrent

  """The Payment Mandate can be used only once"""
  OneOff
}

"""Payment Mandate status"""
enum PaymentMandateStatus {
  ConsentPending
  Enabled
  Rejected
  Canceled
}

"""Payment Mandate status information"""
interface PaymentMandateStatusInfo {
  """Status of the payment mandate."""
  status: PaymentMandateStatus!
}

"""
Rejection returned when a payment method is not compatible for the requested mutation
"""
type PaymentMethodNotCompatibleRejection implements Rejection {
  message: String!
}

"""
Field we can use when ordering that can be applied when listing payment
"""
enum PaymentOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing payments"""
input PaymentOrderByInput {
  field: PaymentOrderByFieldInput
  direction: OrderByDirection
}

"""Payment product"""
enum PaymentProduct {
  """When the payment is an Internal Credit Transfer operation"""
  InternalCreditTransfer

  """When the payment is a Sepa Credit Transfer operation"""
  SEPACreditTransfer

  """When the payment is a Sepa Direct Debit operation"""
  SEPADirectDebit

  """When the payment is a Card operation"""
  Card

  """When the payment is a Fees operation"""
  Fees

  """When the payment is an Internal Direct Debit operation"""
  InternalDirectDebit

  """When the payment is a Check operation"""
  Check

  """When the payment is an International Credit Transfer operation"""
  InternationalCreditTransfer
}

"""Payment status rejected"""
type PaymentRejected implements PaymentStatusInfo {
  """status of the payment"""
  status: PaymentStatus!

  """rejected reason"""
  reason: String!
}

"""Payment status"""
enum PaymentStatus {
  """when a consent is pending before initiating the payment"""
  ConsentPending

  """when the payment has been initiated"""
  Initiated

  """when the payment has been rejected"""
  Rejected
}

"""Payment Status Information"""
interface PaymentStatusInfo {
  """status of the payment"""
  status: PaymentStatus!
}

"""Custom information for a PDF statement"""
type PdfStatement implements StatementInfo {
  """statement type"""
  type: StatementType

  """temporary public url on which the file can be accessed"""
  url: String

  """date at which the link will not be useable anymore"""
  expiresAt: DateTime
}

"""Pending Consent when the account membership will be updated"""
type PendingConsentAccountMembershipUpdate {
  """New account membership version waiting for consent"""
  accountMembershipId: AccountMembership!

  """The consent required to update the account membership"""
  consent: Consent!
}

"""Pending Digital Card used for ApplePay or GooglePay"""
type PendingDigitalCard implements DigitalCard {
  """Unique identifier of a digital card"""
  id: ID!

  """The type of digitalization that created this digital card."""
  type: DigitalizationType!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Wallet Provider (ApplePay, GooglePay ...)"""
  walletProvider: WalletProvider!

  """
  Digital Card status information
  
  In this type the status will be either ConsentPending or Pending
  """
  statusInfo: PendingDigitalCardStatusInfo!

  """
  Data to provide to the wallet during InApp Provisioning
  
  Signature Data is mandatory for ApplePay
  
  This data is only available for a digital card in
  - status: Pending
  - type: InApp
  """
  inAppProvisioningData(signatureData: SignatureData): InAppProvisioningData

  """The project ID"""
  projectId: ID!

  """The card contract ID"""
  cardContractId: ID!
}

"""Pending Digital Card Status"""
enum PendingDigitalCardStatus {
  """when the digital card is waiting for the user to finish his consent"""
  ConsentPending

  """when the digital card is pending the end of the digitalization process"""
  Pending

  """
  when the creation of a digital card is declined
  
  this is a final state
  """
  Declined
}

"""Pending Digital Card Status Information"""
interface PendingDigitalCardStatusInfo {
  """Status of the digital card."""
  status: PendingDigitalCardStatus!
}

"""Funding Source Pending status information"""
type PendingFundingSourceStatusInfo implements FundingSourceStatusInfo {
  """Funding Source Pending status"""
  status: FundingSourceStatus!
}

"""
Describes an identification level that is pending for the process of the current identification, requiring an operation not related to the end-user to progress
"""
type PendingIdentificationLevelStatusInfo {
  """Always set to `Pending`"""
  status: SwanIdentificationStatus!
}

"""PendingMerchantPaymentMethodStatusInfo"""
type PendingMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!
}

"""PendingReviewMerchantProfileStatusInfo"""
type PendingReviewMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
}

"""Pending Verification Information"""
type PendingReviewStatusInfo implements AccountVerificationStatusInfo {
  """Account verification status (PendingReview)"""
  status: AccountVerificationStatus!
}

type PendingTransactionStatementStatusInfo implements TransactionStatementStatusInfo {
  """status of the transaction statement"""
  status: TransactionStatementStatusEnum!
}

"""Pending transaction status information"""
type PendingTransactionStatusInfo implements TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!

  """
  The date when the pending amount of this transaction is released on the available balance of this account if not booked
  """
  pendingEndDate: DateTime
}

"""Pending Verification Information"""
type PendingVerificationStatusInfo implements AccountVerificationStatusInfo {
  """Account verification status (PendingVerification)"""
  status: AccountVerificationStatus!
}

type PermissionCannotBeGrantedRejection implements Rejection {
  message: String!
}

"""
E.164 standard format phone number

Examples
+551155256325
+44207183875
"""
scalar PhoneNumber

"""Physical Card"""
type PhysicalCard {
  """Physical Card status information"""
  statusInfo: PhysicalCardStatusInfo!

  """Physical Card expiration date  with MM/YY string format"""
  expiryDate: String

  """
  Unique identifier present on physical card, such identifier is null if the status is ToActivate or Canceled. This identifier is updated when a renewed card is activated
  """
  identifier: String

  """Offline Spending limit defined by Swan"""
  offlineSpendingLimit: Amount!

  """Masked Card Number"""
  cardMaskedNumber: String!

  """Custom Options"""
  customOptions: PhysicalCardCustomOptions!

  """every previous Physical Card information"""
  previousPhysicalCards: [BasicPhysicalCardInfo!]!
}

"""Physical Card Activated Status Information"""
type PhysicalCardActivatedStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Activated for type PhysicalCardEnabledStatusInfo).
  """
  status: PhysicalCardStatus!
}

"""Physical Card Canceled Status Information"""
type PhysicalCardCanceledStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Canceled for type PhysicalCardCanceledStatusInfo).
  """
  status: PhysicalCardStatus!

  """Reason why the card is canceled."""
  reason: String!
}

"""Physical Card Canceling Status Information"""
type PhysicalCardCancelingStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Canceling for type PhysicalCardCancelingStatusInfo).
  """
  status: PhysicalCardStatus!

  """Reason why the card is canceled."""
  reason: String!
}

input PhysicalCardConfigInput {
  """Address to deliver the physical card"""
  deliveryAddress: CompleteAddressInput!

  """Custom options to use for physical cards."""
  physicalCardCustomOptions: PhysicalCardCustomOptionsInput

  """`true` if the user must choose their PIN Code"""
  choosePin: Boolean
}

"""when the user has to authorize production of the physical card"""
type PhysicalCardConsentPendingStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always ConsentPending for type PhysicalCardConsentPendingStatusInfo)
  """
  status: PhysicalCardStatus!

  """The consent required to authorize production of the physical card"""
  consent: Consent!
}

"""Custom options for physical card."""
type PhysicalCardCustomOptions {
  """Additional line embossed on the card."""
  additionalPrintedLine: String

  """Custom Card Holder Name"""
  customCardHolderName: String
}

input PhysicalCardCustomOptionsForGroupDeliveryInput {
  """
  Additional line to be embossed on the card.
  
  This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
  
  Max length allowed: 26 characters.
  Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe
  """
  additionalPrintedLine: String

  """Alternative printed card owner."""
  customCardHolderName: String
}

input PhysicalCardCustomOptionsForPrintInput {
  """
  Additional line to be printed on the card.
  
  This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
  
  Max length allowed: 26 characters.
  Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe
  """
  additionalPrintedLine: String

  """Alternative printed card owner."""
  customCardHolderName: String
}

input PhysicalCardCustomOptionsInput {
  """
  Additional line to be embossed on the card.
  
  This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
  
  Max length allowed: 26 characters.
  Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe
  """
  additionalPrintedLine: String

  """Alternative printed card owner."""
  customCardHolderName: String
}

"""Rejection returned when the Physical Card does not exist"""
type PhysicalCardNotFoundRejection implements Rejection {
  message: String!
  identifier: String!
}

"""when the physical card is in the process of being ready to use"""
type PhysicalCardProcessingStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical card status (always Processing for type PhysicalCardProcessingStatusInfo)
  """
  status: PhysicalCardStatus!
}

"""Physical Card Renewed Status Information"""
type PhysicalCardRenewedStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Renewed for type PhysicalCardRenewedStatusInfo).
  """
  status: PhysicalCardStatus!

  """address to deliver the physical card"""
  address: Address!

  """Estimated delivery date"""
  estimatedDeliveryDate: DateTime

  """Shipping tracking number"""
  trackingNumber: String

  """Name of the shipping provider (Ex: LaPoste, DHL ...)"""
  shippingProvider: String

  """`true` if PIN Code is available."""
  isPINReady: Boolean!

  """New physical Card info"""
  newPhysicalCard: BasicPhysicalCardInfo!
}

"""Physical Card Status"""
enum PhysicalCardStatus {
  """Consent to authorize physical card production is pending"""
  ConsentPending

  """Physical card is in processing and can’t be used yet"""
  Processing

  """Physical card is activated and can be used"""
  Activated

  """Physical card is suspended and can’t be used"""
  Suspended

  """Physical card is canceled, can’t be used, and can’t be restored"""
  Canceled

  """
  Physical card is in the process of being canceled; card can’t be used or restored
  """
  Canceling

  """Physical card needs to be activated by cardholder"""
  ToActivate

  """Physical card is in the process of being renewed"""
  ToRenew

  """Physical card is renewed but hasn’t made a transaction since renewal"""
  Renewed
}

"""Physical Card Status Information"""
interface PhysicalCardStatusInfo {
  """Status of the physical card."""
  status: PhysicalCardStatus!
}

"""Physical Card Suspended Status Information"""
type PhysicalCardSuspendedStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always Suspended for type PhysicalCardSuspendedStatusInfo).
  """
  status: PhysicalCardStatus!

  """Reason why the card is suspended."""
  reason: String!
}

"""Physical Card To Activate Status Information"""
type PhysicalCardToActivateStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical Card status (always ToActivate for type PhysicalCardToActivateStatusInfo).
  """
  status: PhysicalCardStatus!

  """address to deliver the physical card"""
  address: Address!

  """Estimated delivery date"""
  estimatedDeliveryDate: DateTime

  """Shipping tracking number"""
  trackingNumber: String

  """Name of the shipping provider (Ex: LaPoste, DHL ...)"""
  shippingProvider: String

  """`true` if PIN Code is available."""
  isPINReady: Boolean!
}

"""when the physical card is in the process of being renewed"""
type PhysicalCardToRenewStatusInfo implements PhysicalCardStatusInfo {
  """
  Physical card status (always ToRenew for type PhysicalCardToRenewStatusInfo)
  """
  status: PhysicalCardStatus!

  """registered address to deliver the new physical card"""
  address: Address!
}

"""Rejection returned when the Physical Card is not the expected status"""
type PhysicalCardWrongStatusRejection implements Rejection {
  message: String!
  identifier: String!
  currentStatus: PhysicalCardStatus!
  expectedStatus: PhysicalCardStatus!
}

"""6 digits numeric passcode"""
scalar PIN

type PINNotReadyRejection implements Rejection {
  physicalCardIdentifier: String!
  message: String!
}

enum PreferredNotificationChannel {
  """Use Swan SMS"""
  Sms

  """Use In-App notification"""
  App
}

type PreProvisioningSUVCardSettings {
  preProvisioningSUVCards: Boolean!
  preProvisioningSUVNumberOfCards: Int!
  ownerProvisioningSUVCards: ID
  preProvisioningSUVCardsAvailablePercentage: Float!
}

"""Inputs to print a physical card"""
input PrintPhysicalCardInput {
  """Unique identifier of a card"""
  cardId: ID!

  """Address to deliver the physical card"""
  address: CompleteAddressInput!

  """`true` if the user must choose their PIN"""
  choosePin: Boolean

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Custom options to use for physical cards."""
  physicalCardCustomOptions: PhysicalCardCustomOptionsForPrintInput
}

union PrintPhysicalCardPayload = PrintPhysicalCardSuccessPayload | AccountMembershipNotAllowedRejection | AlreadyValidPhysicalCardRejection | BadAccountStatusRejection | BadRequestRejection | CardNotFoundRejection | CardProductNotApplicableToPhysicalCardsRejection | CardProductDisabledRejection | MissingMandatoryFieldRejection | ValidationRejection

type PrintPhysicalCardSuccessPayload {
  """The physicalCard created"""
  physicalCard: PhysicalCard!
}

"""Values to provide for probing a callback endpoint"""
input ProbeWebhookEndpointInput {
  """
  The endpoint URL the test event will be sent to
  (max 255 characters)
  """
  endpoint: String!

  """A shared secret as proof of identity"""
  secret: String
}

union ProbeWebhookEndpointPayload = ProbeWebhookEndpointSuccessPayload | InternalErrorRejection | InvalidArgumentRejection

type ProbeWebhookEndpointSuccessPayload {
  eventId: ID!
  responseStatus: Int
}

"""
Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
"""
enum ProductType {
  Goods
  Services
  VirtualGoods
  GiftsAndDonations
}

"""Thrown when a plan already has a subscription"""
type ProjectAlreadyHasSubscriptionRejection implements Rejection {
  message: String!
}

type ProjectCardDesigns {
  """Unique identifier of a project"""
  id: ID!

  """Visual Id from the issuing card processor (Monext)"""
  issuingProcessorVisualId: String

  """Specific card product for companies"""
  specificCardProductCodeForCompanies: String

  """Project name"""
  name: String

  """Project card product designs"""
  cardDesigns: [CardProductDesign!]!

  """Project's pre provisioning suv card settings"""
  preProvisioningSUVCardSettings: PreProvisioningSUVCardSettings
}

type ProjectCardSettings {
  """Unique identifier of a project"""
  id: ID!

  """Project name"""
  name: String

  """Visual Id from the issuing card processor (Monext)"""
  issuingProcessorVisualId: String

  """Specific card product for companies"""
  specificCardProductCodeForCompanies: String

  """Project's card settings"""
  cardSettings: [CardSettings!]!

  """Project's pre provisioning suv card settings"""
  preProvisioningSUVCardSettings: PreProvisioningSUVCardSettings
}

"""Project Card Settings Background Type"""
enum ProjectCardSettingsBackgroundType {
  """when Card setting background is black"""
  Black

  """when Card setting background is light"""
  Silver

  """when Card setting background is customized"""
  Custom
}

"""Card Status"""
enum ProjectCardStatus {
  """when project's card settings are Initiated"""
  Initiated

  """when project's card settings are Enabled"""
  Enabled

  """when project's card settings are Disabled"""
  Disabled

  """when project's card settings are ToReview"""
  ToReview

  """when project's card settings are Suspended"""
  Suspended

  """when project's card settings are Rejected"""
  Rejected
}

type ProjectForbiddenRejection implements Rejection {
  message: String!
}

"""Rejection returned when the Project Funding has been exceeded"""
type ProjectFundingLimitExceededRejection implements Rejection {
  message: String!
}

"""Public information of a `Project`"""
type ProjectInfo {
  """The card products associated with this project."""
  cardProducts: [CardProduct!]

  """the currently active card settings"""
  activeCardSettings: CardSettings @deprecated(reason: "Use cardProduct.cardDesigns instead")

  """Unique identifier of the project"""
  id: ID!
  B2BMembershipIDVerification: Boolean
  supportingDocumentSettings: SupportingDocumentSettings

  """
  Your project name displayed in white label interfaces and in the terms and conditions
  """
  name: String!

  """The type of your project"""
  type: ProjectType!

  """URL of your logo"""
  logoUri: String

  """
  Your accent color, used in white label interfaces. Most of the time for call to actions
  """
  accentColor: String

  """Your custom subdomain used in consents"""
  customConsentSubdomain: String

  """Your OAuth client id"""
  oAuthClientId: String

  """
  URL to your Terms and Conditions of Use document depending on the provided language
  """
  tcuDocumentUri(
    """
    this consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)
    """
    language: String!
  ): String!

  """Unique id of your current Terms and Conditions of Use"""
  tcuDocumentId: String!

  """Web banking settings"""
  webBankingSettings: WebBankingSettings

  """Project status"""
  status: ProjectStatus!

  """
  Flag that determines if desktop authentication is enabled for this project
  """
  allowsDesktopAuthentication: Boolean!

  """The related project settings"""
  projectSettingsId: ID!
}

"""
Rejection returned when the Project Instant Funding limit has been exceeded
"""
type ProjectInstantFundingLimitExceededRejection implements Rejection {
  message: String!
}

type ProjectInvalidStatusRejection implements Rejection {
  message: String!
}

type ProjectNotFound implements Rejection {
  message: String!
}

"""Rejection returned when the project is not found"""
type ProjectNotFoundRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the project settings of a project are not found
"""
type ProjectSettingsByProjectIdNotFoundRejection implements Rejection {
  message: String!
}

type ProjectSettingsForbiddenError implements Rejection {
  message: String!
}

type ProjectSettingsNotFound implements Rejection {
  message: String!
}

type ProjectSettingsStatusNotReachable implements Rejection {
  message: String!
}

enum ProjectStatus {
  Initiated
  MeetingScheduled
  ToReview @deprecated(reason: "replaced by `PendingCompliance`")
  PendingCompliance
  LimitedLiveAccess
  BetaLiveAccess
  Enabled @deprecated(reason: "replaced by `LimitedLiveAccess`")
  FullLiveAccess
  Disabled
  Suspended
  Rejected
  PendingLiveReview
}

enum ProjectType {
  INDIVIDUAL @deprecated(reason: "replaced by `Individual`")
  COMPANY @deprecated(reason: "replaced by `Company`")
  COMPANY_AND_CUSTOMERS @deprecated(reason: "replaced by `CompanyAndCustomers`")
  Individual
  Company
  CompanyAndCustomers
}

"""Rejection returned when the public onboarding is disabled"""
type PublicOnboardingDisabledRejection implements Rejection {
  message: String!
}

type Query {
  """Returns a request for funding limit settings change from its id."""
  fundingLimitSettingsChangeRequest(fundingLimitSettingsChangeRequestId: ID!): FundingLimitSettingsChangeRequest

  """
  Allows to check iban validation. It also returns its bank and reachability information
  """
  ibanValidation(input: IbanValidationInput): IbanValidationResult

  """Returns an account holder from its id."""
  accountHolder(id: ID!): AccountHolder

  """
  Returns the list of account holders.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  
  *For a Project access token, this is all the account holders of the project and for an User access token, these are the holders of the accounts of which the user has an account membership.*
  """
  accountHolders(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: AccountHolderFilterInput

    """an order you can apply to your list of connections"""
    orderBy: AccountHolderOrderByInput
  ): AccountHolderConnection!

  """Returns an account membership from its id."""
  accountMembership(id: ID!): AccountMembership

  """
  The list of account memberships
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  accountMemberships(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: AccountMembershipsFilterInput

    """an order you can apply to your list of connections"""
    orderBy: AccountMembershipOrderByInput
  ): AccountMembershipConnection!

  """Returns an account from its id."""
  account(accountId: ID!): Account

  """
  Returns the list of accounts.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  
  *For a Project access token, this is all the accounts of the project and for an User access token, these are the accounts of which the user has an account membership.*
  """
  accounts(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: AccountFilterInput

    """an order you can apply to your list of connections"""
    orderBy: AccountOrderByInput
  ): AccountConnection!

  """
  Allows to verify the consistency between a beneficiary name and an IBAN.
  """
  beneficiaryVerification(input: BeneficiaryVerificationInput): BeneficiaryVerificationResult

  """
  Returns an onboarding from its id.
  
  *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  onboarding(id: ID!): Onboarding!

  """
  Returns the list of onboardings.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  
  *This query is restricted to data export or to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  onboardings(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: OnboardingFiltersInput

    """an order you can apply to your list of connections"""
    orderBy: OnboardingOrderByInput
  ): OnboardingConnection!

  """
  Returns the list of supporting document collections.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  supportingDocumentCollections(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: SupportingDocumentCollectionFilterInput

    """an order you can apply to your list of connections"""
    orderBy: SupportingDocumentCollectionOrderByInput
  ): SupportingDocumentCollectionConnection!

  """Returns a supporting document collection from its id."""
  supportingDocumentCollection(id: ID!): SupportingDocumentCollection

  """Returns an account statement by id"""
  accountStatement(id: ID!): Statement!

  """Returns a payment from its id."""
  payment(id: ID!): Payment!

  """
  List of payments.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  *For a Project access token, this is all the payments of the project and for an User access token, these are the payments initiated by the user*
  """
  payments(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: PaymentOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: PaymentFiltersInput
  ): PaymentConnection!

  """Returns a transaction statement in PDF for the provided Id"""
  transactionStatement(id: ID!): TransactionStatement!

  """
  Returns a transaction from its id.
  
  *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  transaction(id: ID!): Transaction!

  """
  List of transactions of a project.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  *For a Project access token, this is all the transactions of the project (only available with project access token)*
  """
  transactions(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: TransactionsOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: TransactionsFiltersInput
  ): TransactionConnection!
  accountInvoice(invoiceId: ID!): Invoice

  """Return the capital deposit case for the provided id."""
  capitalDepositCase(id: ID!): CapitalDepositCase

  """
  Returns the list of capital deposit cases.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  
  *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  capitalDepositCases(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: CapitalDepositCaseFiltersInput

    """an order you can apply to your list of connections"""
    orderBy: CapitalDepositCaseOrderByInput
  ): CapitalDepositCaseConnection!

  """Return the CapitalDepositDocument for the provided id."""
  capitalDepositDocument(id: ID!): CapitalDepositDocument

  """Return the Shareholder for the provided id."""
  shareholder(id: ID!): Shareholder

  """Returns a card from its id."""
  card(cardId: ID!): Card
  cardProductById(id: ID): CardProductByIdResultPayload

  """
  Returns the list of cards.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  
  *For a Project access token, this is all the cards of the project and for an User access token, these are the cards owned by the user whom have an account membership.*
  """
  cards(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """an order you can apply to your list of connections"""
    orderBy: CardOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: CardFiltersInput
  ): CardConnection!
  exports(after: String, before: String, filters: ExportFilterInput, first: Int! = 50): ExportConnection!

  """Returns the project infos you set in the dashboard."""
  projectInfo: ProjectInfo!

  """Returns a consent by its id."""
  consent(id: ID!): Consent!

  """
  Return the list of consents
  
  For a User access token : return the list of consents for the signed-in user
  For a Project access token : return the list of consents for the project. This list can be filtered by userId
  
  *([Learn more on authentication](https://docs.swan.io/api/authentication))*
  """
  consents(first: Int! = 50, after: String, filters: ConsentsFiltersInput): ConsentConnection!

  """
  Returns a User
  
  For a Project access token : it requires a user id and returns the user for the given id
  For a User access token : returns the signed-in user and all of their data at Swan
  
  *([Learn more on authentication](https://docs.swan.io/api/authentication))*
  """
  user(id: String): User

  """
  Returns the list of user that joined the project
  The search field allows to search in : id, phonNumber, firstName, allFirstNames, lastName
  
  *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))*
  """
  users(
    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """a filtering table you can apply to your list of connections"""
    filters: UserFilterInput

    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """@deprecated(reason: "use the `search` field in `UserFilterInput`")"""
    search: String
  ): UserConnection!

  """Returns a payment mandate from its id."""
  paymentMandate(id: ID!): PaymentMandate

  """Returns a received direct debit mandate from its id."""
  receivedDirectDebitMandate(receivedDirectDebitMandateId: ID!): ReceivedDirectDebitMandate

  """Return a merchant payment link by id"""
  merchantPaymentLink(id: ID!): MerchantPaymentLink

  """Returns a merchant payment method update request by id."""
  merchantPaymentMethodUpdateRequest(id: ID!): MerchantPaymentMethodUpdateRequest

  """Returns a merchant payment method by id."""
  merchantPaymentMethod(id: ID!): MerchantPaymentMethod

  """Return a merchant payment by id"""
  merchantPayment(id: ID!): MerchantPayment

  """Returns a merchant profile update request by id."""
  merchantProfileUpdateRequest(id: ID!): RequestMerchantProfileUpdate

  """Returns a merchant profile by id."""
  merchantProfile(id: ID!): MerchantProfile

  """Returns merchant profiles."""
  merchantProfiles(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: MerchantProfileOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: MerchantProfileFiltersInput
  ): MerchantProfileConnection!

  """Returns funding source by id."""
  fundingSource(id: ID!): FundingSource

  """Returns an international beneficiary dynamic forms."""
  internationalBeneficiaryDynamicForms(amount: AmountInput!, language: InternationalCreditTransferDisplayLanguage, dynamicFields: [InternationalBeneficiaryDetailsInput!]): InternationalBeneficiaryDynamicForms

  """Returns an international credit transfer dynamic form."""
  internationalCreditTransferTransactionDetailsDynamicForm(targetAmount: AmountInput!, language: InternationalCreditTransferDisplayLanguage, internationalBeneficiary: InternationalBeneficiaryInput!, refreshableFields: [InternationalCreditTransferDetailsInput!]): InternationalCreditTransferDynamicForm

  """Request an international credit transfer quote."""
  internationalCreditTransferQuote(accountId: ID!, route: InternationalCreditTransferRouteInput, targetAmount: AmountInput!, language: InternationalCreditTransferDisplayLanguage): InternationalCreditTransferQuote

  """Returns standing order from its id."""
  standingOrder(standingOrderId: ID!): StandingOrder

  """Returns a trusted beneficiary from its ID."""
  trustedBeneficiary(id: String!): TrustedBeneficiary

  """
  The list of supported event types
  Event types are just IDs (i.e. "account.created")
  """
  webhookEventTypes: [String!]!

  """A single webhook eventLog, queried by its id"""
  webhookEventLog(id: ID!): WebhookEventLog

  """
  Get all webhook event logs.
  
  implements forward paging (Relay)
  """
  webhookEventLogs(first: Int! = 50, after: String, filters: WebhookEventLogFiltersInput): WebhookEventLogsConnection

  """A webhook subscription, queried by its id"""
  webhookSubscription(id: ID!): WebhookSubscription

  """
  Get all webhook subscriptions
  
  implements forward paging (Relay)
  """
  webhookSubscriptions(first: Int! = 50, after: String): WebhookSubscriptionsConnection!
}

type RadioField implements Field {
  key: String!
  name: String!
  refreshDynamicFieldsOnChange: Boolean!
  required: Boolean!
  allowedValues: [AllowedValue!]!
}

"""Information that can be used to determine where the iban can be used"""
type Reachability {
  """Can be used for instant transfer over SEPA"""
  sepaCreditTransferInst: Boolean!

  """Can be used for direct debit over SEPA"""
  sepaDirectDebitCore: Boolean!

  """Can be used for B2B direct debit over SEPA"""
  sepaDirectDebitB2b: Boolean!

  """
  Can be used for transfer over SEPA (can be used in initiateCreditTransfer mutation)
  """
  sepaCreditTransfer: Boolean!
}

"""Define a reason with a message"""
interface Reason {
  message: String
}

"""Input version"""
input ReasonInput {
  message: String
}

"""Interface for Received Direct Debit Mandate"""
interface ReceivedDirectDebitMandate {
  """
  Unique identifier of the received direct debit mandate, generated by Swan
  """
  id: ID!

  """Version of the received direct debit mandate"""
  version: String!

  """Creation date of the received direct debit mandate"""
  createdAt: DateTime!

  """Last Update date of the received direct debit mandate"""
  updatedAt: DateTime!

  """Date of signature of the received direct debit mandate"""
  signatureDate: Date

  """
  Date of the last direct debit transaction executed for the concerned received direct debit mandate
  """
  executedAt: DateTime

  """Expiry date of the received direct debit mandate"""
  expiredAt: Date

  """Mandate status information of the received direct debit mandate"""
  statusInfo: ReceivedDirectDebitMandateStatusInfo!

  """Mandate name"""
  name: String
}

"""Rejection returned if the received direct debit mandate already exist"""
type ReceivedDirectDebitMandateAlreadyExistRejection implements Rejection {
  id: String!
  message: String!
}

"""
Received direct debit mandate is canceled and therefore can't be enabled/suspended or updated
"""
type ReceivedDirectDebitMandateCanceledRejection implements Rejection {
  id: String!
  message: String!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type ReceivedDirectDebitMandateConnection implements Connection {
  """Total number of elements in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """ReceivedDirectDebitMandateEdge list"""
  edges: [ReceivedDirectDebitMandateEdge!]!
}

"""Implements the Relay Edge interface"""
type ReceivedDirectDebitMandateEdge implements Edge {
  """
  Opaque identifier pointing to this onboarding node in the pagination mechanism
  """
  cursor: String!

  """The received direct debit mandate"""
  node: ReceivedDirectDebitMandate!
}

"""
Rejection returned if the received direct debit mandate is not a B2b mandate
"""
type ReceivedDirectDebitMandateNotB2bRejection implements Rejection {
  id: String!
  message: String!
}

"""
Error returned if the received direct debit mandate was not found or if the user does not have the rights to receive information abo
ut the existence of the received direct debit mandate
"""
type ReceivedDirectDebitMandateNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Received Direct Debit Mandate Scheme"""
enum ReceivedDirectDebitMandateScheme {
  """
  When the received direct debit mandate can only be used for SEPA B2B direct debit transactions
  """
  SepaDirectDebitB2b

  """
  When the received direct debit mandate can only be used for SEPA Core direct debit transactions
  """
  SepaDirectDebitCore
}

"""Received Direct Debit Mandate Statuses"""
enum ReceivedDirectDebitMandateStatus {
  """When the received direct debit mandate is enabled"""
  Enabled

  """When the received direct debit mandate is suspended"""
  Suspended

  """When the received direct debit mandate is canceled"""
  Canceled

  """
  When the received direct debit mandate requires the initiation of a consent process
  """
  ConsentInitiationPending

  """When the received direct debit mandate is pending consent completion"""
  ConsentPending
}

"""Received Direct Debit Mandate status information"""
interface ReceivedDirectDebitMandateStatusInfo {
  """Received Direct Debit Mandate status"""
  status: ReceivedDirectDebitMandateStatus!
}

"""Received Direct Debit Mandate Canceled status information"""
type ReceivedDirectDebitMandateStatusInfoCanceled implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always Canceled for type ReceivedDirectDebitMandateStatusInfoCanceled)
  """
  status: ReceivedDirectDebitMandateStatus!

  """Date of cancellation"""
  canceledAt: DateTime!
}

"""
Received Direct Debit Mandate ConsentInitiationPending status information
"""
type ReceivedDirectDebitMandateStatusInfoConsentInitiationPending implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentInitiationPending)
  """
  status: ReceivedDirectDebitMandateStatus!
}

"""Received Direct Debit Mandate ConsentPending status information"""
type ReceivedDirectDebitMandateStatusInfoConsentPending implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentPending)
  """
  status: ReceivedDirectDebitMandateStatus!

  """The consent required to consent to a received direct debit mandate"""
  consent: Consent!
}

"""Received Direct Debit Mandate Enabled status information"""
type ReceivedDirectDebitMandateStatusInfoEnabled implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always Enabled for type ReceivedDirectDebitMandateStatusInfoEnabled)
  """
  status: ReceivedDirectDebitMandateStatus!

  """
  Date at which the received direct debit mandate has been moved to the enabled status
  """
  enabledAt: DateTime!
}

"""Received Direct Debit Mandate Suspended status information"""
type ReceivedDirectDebitMandateStatusInfoSuspended implements ReceivedDirectDebitMandateStatusInfo {
  """
  Received Direct Debit Mandate status (always Suspended for type ReceivedDirectDebitMandateStatusInfoSuspended)
  """
  status: ReceivedDirectDebitMandateStatus!

  """
  Date of the last time the received direct debit mandate has been moved to the suspended status
  """
  suspendedAt: DateTime!
}

"""Input to select the beneficiary and the originator to perform a refund"""
input RefundInput {
  """transactions to refund"""
  refundTransactions: [RefundTransaction!]!

  """url the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

"""The respond body to a refund mutation"""
union RefundPayload = RefundSuccessPayload | RefundRejection

"""
Rejection returned if the transaction status is not correct for the desired action
"""
type RefundRejection implements Rejection {
  message: String!
  code: RefundRejectionCode!
}

"""Reason code that explains why we can't refund the transactions"""
enum RefundRejectionCode {
  """
  The transaction couldn't be found or the user doesn't have the 'canInitiatePayment' rights on the account
  """
  TransactionNotFound

  """The transaction status is not Booked"""
  TransactionNonRefundable

  """Error server"""
  ServerError
}

"""Consent generated by the refund mutation"""
type RefundSuccessPayload {
  """
  optional consent that need to be validated for the refund to go through
  """
  consent: Consent
}

"""Information about the transaction to refund"""
input RefundTransaction {
  """id of the transaction to refund"""
  originTransactionId: String!

  """amount to refund in the same currency as the account"""
  amount: AmountInput!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction.
  This reference is passed on, unchanged, throughout the entire end-to-end chain for credit transfers. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35})
  """
  reference: String

  """label for the refund transaction (max 140 characters)"""
  label: String

  """
  only used when the transaction was a credit transfer
  
  date when the credit transfer will be executed, if `null` the credit transfer is executed today
  """
  executionDate: DateTime
}

"""Funding Source Rejected Reason"""
enum RejectedFundingSourceReason {
  AccountVerificationRejected
}

"""Funding Source Rejected status information"""
type RejectedFundingSourceStatusInfo implements FundingSourceStatusInfo {
  """Funding Source Rejected status"""
  status: FundingSourceStatus!

  """Date at which the funding source was rejected"""
  rejectedAt: Date!

  """Reason code of the rejection"""
  reasonCode: RejectedFundingSourceReason!
}

"""RejectedMerchantPaymentMethodStatusInfo"""
type RejectedMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method rejected date"""
  rejectedAt: Date!
}

"""RejectedMerchantProfileStatusInfo"""
type RejectedMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  rejectedAt: Date!
}

"""The following reason code for a rejected transaction are defined:"""
enum RejectedReasonCode {
  """The account linked to this card is closed."""
  AccountClosed

  """The card isn't activated."""
  CardNotActivated

  """The card is expired."""
  CardExpired

  """The card is permanently blocked."""
  CardPermanentlyBlocked

  """The card is suspended."""
  CardSuspended

  """The card is temporarily or permanently blocked, or it's expired."""
  CardOutOfOrder

  """The card is unknown."""
  CardUnknown

  """The card holder canceled the transaction."""
  CanceledByCardHolder

  """The digital card is deactivated."""
  DigitalCardDeactivated

  """There was a problem when enrolling the digital card."""
  DigitalCardEnrollmentInvalid

  """The digital card issuer rejected the transaction."""
  DigitalCardRefusal

  """The digital card is suspended."""
  DigitalCardSuspended

  """The digital card either is inactive, is expired, or doesn't exist."""
  DigitalCardTokenInvalid

  """This request can't be honored. Contact Support with any questions."""
  DoNotHonor

  """
  The expiration date provided doesn't match the expiration date on the card.
  """
  InvalidExpirationDate

  """The card holder entered the incorrect PIN too many times."""
  InvalidPinAttemptsExceeded

  """This card can't be used for in-person transactions."""
  InPersonTransactionsNotAuthorized

  """Paying with the card's magstripe isn't supported by this merchant."""
  MagstripeNotSupported

  """The merchant couldn't be found or doesn't exist."""
  MerchantNotFound

  """The merchant didn't use 3-D Secure (3DS)."""
  MerchantShouldResubmitAuthorization

  """The PIN entered by the card holder is incorrect."""
  PinInvalid

  """The card holder didn't enter their PIN."""
  PinRequired

  """
  The card holder must enter their PIN while completing a transaction to reactivate their card.
  """
  PinRequiredForFurtherTransaction

  """
  The maximum number of transactions allowed during the given period is exceeded.
  """
  PeriodTransactionNumberLimitExceeded

  """A technical error occurred."""
  SwanTechnicalErrorOccurred

  """The maximum spending limit for the given period is exceeded."""
  TransactionAmountLimitExceeded

  """The account doesn't allowed this transaction type."""
  TransactionTypeNotAllowed

  """There was an error with 3-D Secure (3DS)."""
  ThreeDsError

  """The transaction isn't in a supported currency."""
  TransactionCurrencyIncorrect

  """Rejected because the account holder is deceased"""
  AccountHolderDeceased

  """Rejected by the account membership"""
  AccountMembershipRefused

  """Rejected because the account is suspended"""
  AccountSuspended

  """Rejected because the account is unknown"""
  AccountUnknown

  """
  Rejected because the declared amount does not match the amount on the check
  """
  AmountMismatch

  """Rejected by the bank"""
  BankRefused

  """Rejected because the creditor bank is not reachable"""
  BeneficiaryBankNotReachable

  """
  Rejected because the amount beneficiary name the check and the name declared through the API don't match
  """
  BeneficiaryMismatch

  """Rejected because the beneficiary is missing or incorrect"""
  BeneficiaryMissingOrIncorrect

  """
  Rejected because the check was received more than 30 days after it was declared to Swan
  """
  CheckReceivedLate

  """Rejected because the check was not received"""
  CheckNotReceived

  """Rejected because the creditor bank is offline"""
  CreditorBankOffline

  """Rejected following an error from the creditor bank"""
  CreditorBankTechnicalErrorOccurred

  """Rejected following a timeout from the creditor bank"""
  CreditorBankTimeout

  """Rejected because the date is missing on the check"""
  DateMissing

  """
  Rejected because the date on the check is invalid (unreadable or in the future for example)
  """
  DateInvalid

  """Rejected because the debtor account is closed"""
  DebtorAccountClosed

  """
  Rejected because the debtor is a non business account and the transaction is a B2B SEPA Direct Debit transaction
  """
  DebtorAccountConsumer

  """Rejected because the debtor account is unknown"""
  DebtorAccountUnknown

  """Rejected because the debtor bank is offline"""
  DebtorBankOffline

  """Rejected following an error from the debtor bank"""
  DebtorBankTechnicalErrorOccurred

  """Rejected following a timeout from the debtor bank"""
  DebtorBankTimeout

  """Rejected because the debtor account holder is dead"""
  DebtorDeceased

  """Rejected because the name of the payer is missing on the check"""
  DebtorNameMissing

  """Rejected because the check has not been signed."""
  EndorsementMissing

  """Rejected because of a fraud suspicion"""
  FraudSuspected

  """Rejected because the beneficiary IBAN is invalid"""
  IbanInvalid

  """Rejected because the beneficiary IBAN is suspended"""
  IbanSuspended

  """Rejected because of insufficient funds on the account"""
  InsufficientFunds

  """Rejected because of invalid transfer date"""
  InvalidTransferDate

  """
  Rejected because the digital amount on the check is missing or unreadable
  """
  InvalidOrMissingAmount

  """
  Rejected because the security number entered does not match the one on the card
  """
  InvalidSecurityNumber

  """Rejected by debtor because the mandate is invalid"""
  MandateInvalid

  """Rejected because the mandate has been revoked or does not exist"""
  NoMandate

  """Rejected by the partner (you)"""
  PartnerRefused

  """Rejected following an error or a timeout from the partner"""
  PartnerTechnicalErrorOccurred

  """
  Rejected because the maximum amount allowed on the given period has been exceeded
  """
  PeriodAmountLimitExceeded

  """
  Rejected because the maximum number of transactions on the given period has been exceeded
  """
  PeriodNbTransactionLimitExceeded

  """Rejected by bank with no specified reason"""
  ReasonNotSpecifiedByBank

  """Rejected by debtor with no specified reason"""
  ReasonNotSpecifiedByDebtor

  """Rejected by bank for regulatory reason"""
  RegulatoryReason

  """Rejected because the signature is missing on the check"""
  SignatureMissing

  """Rejected because the check is suspicious"""
  SuspiciousCheck

  """Rejected because the debtor or the creditor bank is offline"""
  SwanOffline

  """Rejected by Swan"""
  SwanRefused

  """Rejected because of a Swan timeout"""
  SwanTimeout

  """Rejected because the terms and conditions limit has been exceeded"""
  TermsAndConditionsLimitExceeded @deprecated

  """Rejected by bank because this transaction is duplicated"""
  TransactionDuplicated

  """Rejected because the transaction is forbidden on this type of account"""
  TransactionOnAccountTypeNotAllowed

  """Rejected because the PIN is invalid"""
  InvalidPin @deprecated

  """
  Rejected because the Swipe method is not supported, a retry using the Chip and PIN method is necessary
  """
  RetryWithChipAndPin @deprecated

  """Rejected because the given amount is invalid"""
  InvalidAmount @deprecated

  """Rejected because the card holder asked for the cancellation"""
  CardholderCancellation @deprecated

  """Rejected because the given card number is invalid"""
  CardNumberInvalid @deprecated

  """
  Rejected because of a problem encountered during the enrolment request (for example, a token error)
  """
  DigitalWalletEnrolmentInvalid @deprecated

  """
  Rejected because the digital wallet's does not exist, is not active or has an expired date
  """
  DigitalWalletTokenInvalid @deprecated

  """Rejected because the digital wallet's issuer refused the transaction"""
  DigitalWalletRefusal @deprecated

  """
  Rejected because purchase made by chip but without any Pin code entered
  """
  MissingPin @deprecated

  """
  Rejected because the expiration date is not available in the transaction
  """
  MissingExpirationDate @deprecated

  """Rejected because the digital wallet's token is deactivated"""
  DigitalWalletDeactivated @deprecated

  """Rejected because the digital wallet's token is suspended"""
  DigitalWalletSuspended @deprecated
}

"""Rejected transaction status information"""
type RejectedTransactionStatusInfo implements TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!

  """reason code"""
  reason: RejectedReasonCode!

  """`true` if the transaction had a fallback"""
  hasFallback: Boolean!
}

"""Rejected Verification Reason"""
enum RejectedVerificationReason {
  HolderDidNotMatch
}

"""Rejected Information"""
type RejectedVerificationStatusInfo implements AccountVerificationStatusInfo {
  """Rejected Reason"""
  reason: RejectedVerificationReason!

  """Date at which the verification was rejected"""
  rejectedAt: DateTime!

  """Account verification status (Rejected)"""
  status: AccountVerificationStatus!
}

interface Rejection {
  message: String!
}

enum ReleasedReason {
  """Authorization fully captured by one or more debits"""
  Captured

  """Authorization expired"""
  Expired

  """Authorization has been superseded by an advice"""
  AdviceReceived

  """Authorization released by the merchant"""
  MerchantReleased

  """Authorization manually released by Swan"""
  ManuallyReleased

  """Authorization released for other/undefined reasons"""
  Other
}

"""Released card transaction status information"""
type ReleasedTransactionStatusInfo implements TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!

  """The date when the transaction was released"""
  releaseDate: DateTime!

  """reason of the released transaction"""
  reason: ReleasedReason!
}

union RemoveWebhookSubscriptionPayload = RemoveWebhookSubscriptionSuccessPayload | WebhookSubscriptionNotFoundRejection | InternalErrorRejection | InvalidArgumentRejection

type RemoveWebhookSubscriptionSuccessPayload {
  subscriptionRemovedSuccessfully: Boolean!
}

"""Input to replay a Webhook event"""
input ReplayWebhookEventInput {
  """The ID of a webhook Event"""
  webhookEventId: ID!
}

"""Invoke Webhook Endpoint Payload"""
union ReplayWebhookEventPayload = ReplayWebhookEventSuccessPayload | WebhookEventLogNotFoundRejection | WebhookSubscriptionNotFoundRejection | InternalErrorRejection | InvalidArgumentRejection

"""Invoke Webhook Endpoint Success Payload"""
type ReplayWebhookEventSuccessPayload {
  webhookEventLogEntryId: ID!
  endpointStatus: Int
}

"""The document corresponding to a identification report"""
type ReportDocument {
  """Unique identifier of the report document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """List of the associated files"""
  files: [ReportDocumentFile!]!
}

"""The file associated to the report document"""
type ReportDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!
}

"""here is the exchange rate detail"""
type ReportExchangeRate {
  sourceCurrency: Currency!
  exchangeRate: Float!
  unitCurrency: Currency!
  targetCurrency: Currency!
  quotationDate: Date!
  contractIdentification: String
}

input RequestMerchantPaymentMethodsInput {
  """ID of the Merchant Profile"""
  merchantProfileId: ID!

  """Input for the Internal Direct Debit Standard payment method"""
  internalDirectDebitStandard: InternalDirectDebitStandardPaymentMethodInput

  """Input for the Internal Direct Debit B2B payment method"""
  internalDirectDebitB2B: InternalDirectDebitB2BPaymentMethodInput

  """Input for the Sepa Direct Debit Core payment method"""
  sepaDirectDebitCore: SepaDirectDebitCorePaymentMethodInput

  """Input for the Sepa Direct Debit B2B payment method"""
  sepaDirectDebitB2B: SepaDirectDebitB2BPaymentMethodInput

  """Input for Check payment method"""
  check: CheckPaymentMethodInput

  """Input for Card payment method"""
  card: CardPaymentMethodInput
}

union RequestMerchantPaymentMethodsPayload = RequestMerchantPaymentMethodsSuccessPayload | ForbiddenRejection | NotFoundRejection | InternalErrorRejection | ValidationRejection | InvalidPaymentMethodRequestRejection

type RequestMerchantPaymentMethodsSuccessPayload {
  merchantProfile: MerchantProfile
}

input RequestMerchantPaymentMethodsUpdateInput {
  """ID of the merchant payment method"""
  paymentMethodId: ID!

  """Input for the Sepa Direct Debit payment method"""
  sepaDirectDebit: SepaDirectDebitPaymentMethodInput!
}

union RequestMerchantPaymentMethodsUpdatePayload = RequestMerchantPaymentMethodsUpdateSuccessPayload | ForbiddenRejection | NotFoundRejection | InternalErrorRejection | MerchantPaymentMethodSepaDirectDebitInvalidRejection | MerchantPaymentMethodWrongStatusRejection

type RequestMerchantPaymentMethodsUpdateSuccessPayload {
  paymentMethodId: String!
  requestId: String!
}

"""Request Update Merchant Profile"""
type RequestMerchantProfileUpdate {
  """The Request ID"""
  id: ID!

  """The Merchant Profile ID to update"""
  merchantProfileId: ID!

  """
  Business name of the merchant, i.e. name that will be displayed on debtors' bank statements
  """
  merchantName: String!

  """Url of the merchant's website"""
  merchantWebsite: String

  """Url of the merchant's logo"""
  merchantLogoUrl: String

  """The status of the request"""
  status: RequestMerchantProfileUpdateStatus!

  """
  Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
  """
  productType: ProductType!

  """Expected annual activity volumes for all payment method"""
  expectedMonthlyPaymentVolume: Amount!

  """expected average basket value."""
  expectedAverageBasket: Amount!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!
}

"""Input to update a Merchant Profile"""
input RequestMerchantProfileUpdateInput {
  """ID of the MerchantProfile to update"""
  merchantProfileId: ID!

  """
  Business name of the merchant, i.e. name that will be displayed on debtors' bank statements
  """
  merchantName: String!

  """
  Url of the merchant's website.
  Use '' to delete the field. Don't add the field to the mutation if you want to keep the existing value.
  """
  merchantWebsite: String

  """
  Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities
  """
  productType: ProductType!

  """Expected annual activity volumes for all payment methods."""
  expectedMonthlyPaymentVolume: AmountInput!

  """expected average basket value."""
  expectedAverageBasket: AmountInput!

  """
  base64 encoded merchant's logo.
  Use '' to delete the field. Don't add the field to the mutation if you want to keep the existing value.
  """
  merchantLogo: String

  """
  Your accent color, used in white label interfaces.
  This color would also be inherited in the Swan Merchant Payment page.
  Unlike the other fields in this mutation, the value specified here updates the merchant profile's accent color immediately.
  """
  accentColor: String
}

"""Add Merchant Profile Payload"""
union RequestMerchantProfileUpdatePayload = RequestMerchantProfileUpdateSuccessPayload | ForbiddenRejection | AccountNotFoundRejection | InternalErrorRejection | ValidationRejection

"""Request Merchant Profile Update Statuses"""
enum RequestMerchantProfileUpdateStatus {
  """A Request is created in the PendingReview status"""
  PendingReview

  """A Request that has already been approved"""
  Enabled

  """A Request that has already been rejected"""
  Rejected

  """A Request that has been canceled by the user"""
  Canceled
}

"""Add Merchant Profile Success Payload"""
type RequestMerchantProfileUpdateSuccessPayload {
  """Request Update Merchant Profile"""
  requestMerchantProfileUpdate: RequestMerchantProfileUpdate!
}

input RequestSupportingDocumentCollectionReviewInput {
  """Id of the supporting document collection to review."""
  supportingDocumentCollectionId: ID!
}

union RequestSupportingDocumentCollectionReviewPayload = RequestSupportingDocumentCollectionReviewSuccessPayload | ForbiddenRejection | SupportingDocumentCollectionNotFoundRejection | SupportingDocumentCollectionStatusNotAllowedRejection | ValidationRejection

type RequestSupportingDocumentCollectionReviewSuccessPayload {
  supportingDocumentCollection: SupportingDocumentCollection!
}

"""The document corresponding to a residence permit"""
type ResidencePermitDocument {
  """Unique identifier of the residence permit document"""
  id: String!

  """The type of the document"""
  type: DocumentType!

  """The date at which the residence permit was issued"""
  issueDate: Date

  """The date at which the residence permit expires"""
  expiryDate: Date

  """Machine-readable zone code of the residence permit"""
  mrz: String

  """Number of the residence permit"""
  number: String

  """List of the associated files"""
  files: [ResidencePermitDocumentFile!]!
}

"""The file associated to the resident permit document"""
type ResidencePermitDocumentFile implements DocumentFile {
  """The file's temporary download url"""
  downloadUrl: String!

  """From which side the residence permit's picture was taken"""
  side: DocumentFileSide!
}

input ResidencyAddressInput {
  """Address line 1. Length must be from 0 to 255 characters"""
  addressLine1: String

  """AddressLine2. Length must be from 0 to 255 characters"""
  addressLine2: String

  """City. Length must be from 0 to 100 characters"""
  city: String

  """Postal code. Length must be from 0 to 50 characters"""
  postalCode: String

  """State of residency. Length must be from 0 to 100 characters"""
  state: String

  """Country"""
  country: CCA3
}

"""Account membership restricted to"""
type RestrictedTo {
  """first name"""
  firstName: String!

  """last name"""
  lastName: String!

  """birth date"""
  birthDate: Date

  """
  phone number
  We're introducing more flexibility in the process to invite & bind new account members (cf [public roadmap](https://swanio.notion.site/Swan-Public-Roadmap-385e4b2e91b3409786a6c8e885654a22?p=a59db00a478e4faaaefbd901e1ed7ed3&pm=s) on notion).
  For some use cases, it would be possible to invite an account member without their mobile phone number.
  Please note that the phone number will remain mandatory at the invitation (despite being optional in the Graph) until the new flow is delivered. It is hidden behind a feature toggle
  """
  phoneNumber: String
}

"""Input when the account membership is restricted to a verified user"""
input RestrictedToInput {
  """Account member first name"""
  firstName: String!

  """Account member last name"""
  lastName: String!

  """Account member birth date"""
  birthDate: Date

  """
  Account member phone number
  We're introducing more flexibility in the process to invite & bind new account members (cf [public roadmap](https://swanio.notion.site/Swan-Public-Roadmap-385e4b2e91b3409786a6c8e885654a22?p=a59db00a478e4faaaefbd901e1ed7ed3&pm=s) on notion).
  For some use cases, it would be possible to invite an account member without their mobile phone number.
  Please note that the phone number will remain mandatory at the invitation (despite being optional in the Graph) until the new flow is delivered. It is hidden behind a feature toggle
  """
  phoneNumber: PhoneNumber
}

"""
Rejection returned if the mutation cannot be executed in another context than user
"""
type RestrictedToUserRejection implements Rejection {
  message: String!
}

input ResumeAccountMembershipInput {
  """Unique identifier of a given account membership to resume"""
  accountMembershipId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ResumeAccountMembershipPayload = ResumeAccountMembershipSuccessPayload | ForbiddenRejection | UserNotAllowedToManageAccountMembershipRejection | ValidationRejection

type ResumeAccountMembershipSuccessPayload {
  consent: Consent!
}

"""Inputs to resume a physical card"""
input ResumePhysicalCardInput {
  """Unique identifier of a card"""
  cardId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ResumePhysicalCardPayload = ResumePhysicalCardSuccessPayload | ForbiddenRejection | CardNotFoundRejection | UserNotCardHolderRejection | PhysicalCardNotFoundRejection | PhysicalCardWrongStatusRejection | ValidationRejection

type ResumePhysicalCardSuccessPayload {
  """The physicalCard to resume"""
  physicalCard: PhysicalCard!

  """The consent required to resume a physical card"""
  consent: Consent!
}

input ReturnTransactionInput {
  """The id of the transaction to return"""
  transactionId: String!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ReturnTransactionPayload = ReturnTransactionSuccessPayload | ReturnTransactionRejection | TransactionNotFoundRejection | ForbiddenRejection

"""
Rejection returned if the refund is not applicable for this transaction
"""
type ReturnTransactionRejection implements Rejection {
  message: String!
}

"""
Return type in case of a successful response of the RefundTransaction mutation
"""
type ReturnTransactionSuccessPayload {
  consent: Consent!
}

"""
Percentage over a number of business days, that is applied to all funds collected to compute a Reserved amount
This amount cannot be used over the corresponding business days
"""
type RollingReserve {
  """Percentage of the funding amount to be reserved"""
  percentage: Int!

  """Number of business days the computed amount is reserved"""
  rollingDays: Int!
}

input ScheduleStandingOrderInput {
  """
  Fix Amount that will be periodically transferred
  *the value must be empty when `targetAvailableBalance` is defined*
  """
  amount: AmountInput

  """
  Target available balance that will be used for periodically clipping the account
  *the value must be empty when `amount` is defined*
  """
  targetAvailableBalance: AmountInput

  """Scheduled period of Standing Order"""
  period: StandingOrderPeriod!

  """Earlier date the Standing Order will be executed"""
  firstExecutionDate: DateTime

  """Latest date the Standing Order will be executed"""
  lastExecutionDate: DateTime

  """SEPA beneficiary of the Standing ORder"""
  sepaBeneficiary: SepaBeneficiaryInput

  """Account the Standing Order will be attached to"""
  accountId: String!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35})
  """
  reference: String

  """label (max 140 characters)"""
  label: String

  """Transfer mode of the Standing Order"""
  creditTransferMode: CreditTransferMode = Regular
}

union ScheduleStandingOrderPayload = ScheduleStandingOrderSuccessPayload | ForbiddenRejection | InternalErrorRejection | InvalidArgumentRejection

type ScheduleStandingOrderSuccessPayload {
  standingOrder: StandingOrder!
}

type Scheme {
  fields: [Field!]!
  title: String!
  type: InternationalCreditTransferRouteInput!
  remainingFieldsToRefreshCount: Int!
}

"""Rejection returned when adding a B2B mandate with an Individual debtor"""
type SchemeWrongRejection implements Rejection {
  message: String!
}

type SelectField implements Field {
  key: String!
  name: String!
  refreshDynamicFieldsOnChange: Boolean!
  required: Boolean!
  allowedValues: [AllowedValue!]!
}

"""External Beneficiary type SEPA"""
type SEPABeneficiary {
  """
  unique identifier of a beneficiary
  *SOON TO BE DEPRECATED*
  Always empty, It will be removed soon.
  """
  id: ID @deprecated(reason: "this field is never filled. It will be removed soon.")

  """full name of the beneficiary"""
  name: String!

  """
  `true` if this new beneficiary is the account holder himself in an other financial institution.
  *SOON TO BE DEPRECATED*
  Not used. It will be removed soon.
  """
  isMyOwnIban: Boolean! @deprecated(reason: "this field is never filled. It will be removed soon.")

  """beneficiary address"""
  address: Address

  """
  maskedIBAN if the beneficiary is a an account in an other financial institution
  """
  maskedIBAN: String
}

"""Sepa beneficiary account"""
input SepaBeneficiaryInput {
  """International Bank Account Number"""
  iban: IBAN!

  """
  Full name of the beneficiary (min 2 characters, max 70 characters). The name should not include any special characters.
  """
  name: String!

  """beneficiary address"""
  address: AddressInput

  """
  `true` if this new beneficiary is the account holder himself in another financial institution.
  """
  isMyOwnIban: Boolean!

  """
  `true` if this new beneficiary will be saved to the beneficiary list of the debited account.
  """
  save: Boolean!
}

"""
SEPA Creditor Identifier
format :
    1 – 2: ISO Country Code
    3 – 4: Check Digit
    5 – 7: Creditor Business Code – you (Creditor) choose this. The default is ZZZ
    8 - 35: Creditor National Identifier – a consecutive number that will be assigned by country
example:
    FR11ABC123456
"""
scalar SepaCreditorIdentifier

"""Sepa Credit Transfer Creditor"""
interface SEPACreditTransferCreditor {
  """full name of the creditor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String
}

"""Sepa Credit Transfer Debtor"""
interface SEPACreditTransferDebtor {
  """full name of the debtor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String
}

"""Sepa Credit Transfer Creditor for Incoming transaction"""
type SEPACreditTransferInCreditor implements SEPACreditTransferCreditor {
  """full name of the creditor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """account number"""
  accountNumber: AccountNumber! @deprecated(reason: "because it is not already implemented (a default value is set).")
}

"""Sepa Credit Transfer Debtor for Incoming transaction"""
type SEPACreditTransferInDebtor implements SEPACreditTransferDebtor {
  """full name of the debtor (max 70 characters)"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID
}

"""
*SOON TO BE DEPRECATED*
Sepa Credit Transfer Debtor for Incoming transaction
"""
type SEPACreditTransferInternalInDebtor implements SEPACreditTransferDebtor {
  """full name of the debtor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """account number"""
  accountNumber: AccountNumber! @deprecated(reason: "because it is not already implemented (a default value is set).")
}

"""
*SOON TO BE DEPRECATED*
Sepa Credit Transfer Creditor for internal transaction
"""
type SEPACreditTransferInternalOutCreditor implements SEPACreditTransferCreditor {
  """full name of the creditor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """account number"""
  accountNumber: AccountNumber!

  """
  beneficiary if the beneficiary is already saved
  *SOON TO BE DEPRECATED*
  Always empty, It will be removed soon.
  """
  beneficiary: InternalBeneficiary @deprecated(reason: "this field is always empty. It will be removed soon.")
}

"""Sepa Credit Transfer Creditor for Outgoing transaction"""
type SEPACreditTransferOutCreditor implements SEPACreditTransferCreditor {
  """full name of the creditor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """
  beneficiary if the beneficiary is already saved
  *SOON TO BE DEPRECATED*
  Always empty, It will be removed soon.
  """
  beneficiary: SEPABeneficiary @deprecated(reason: "this field is always empty. It will be removed soon.")
}

"""Sepa Credit Transfer Debtor for internal transaction"""
type SEPACreditTransferOutDebtor implements SEPACreditTransferDebtor {
  """full name of the debtor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """account number"""
  accountNumber: AccountNumber! @deprecated(reason: "because it is not already implemented (a default value is set).")
}

"""Sepa Credit Transfer transaction"""
type SEPACreditTransferTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!
  supportingDocumentCollections(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: SupportingDocumentCollectionFilterInput
  ): SupportingDocumentCollectionConnection!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain.
  """
  reference: String!

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """creditor information"""
  creditor: SEPACreditTransferCreditor!

  """debtor information"""
  debtor: SEPACreditTransferDebtor!

  """matching account for the transaction"""
  account: Account

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """r-transaction reason"""
  returnReason: TransactionReasonCode

  """true if a transaction statement can be generated for this transaction"""
  statementCanBeGenerated: Boolean

  """project id of the transaction"""
  projectId: ID!

  """SEPA beneficiary linked to the transaction"""
  beneficiary: Beneficiary
}

"""SepaDirectDebitB2BMerchantPaymentMethod"""
type SepaDirectDebitB2BMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve

  """Whether this payment method uses the Swan Sepa Creditor Identifier"""
  useSwanSepaCreditorIdentifier: Boolean!

  """
  When the above is false, the value of the Sepa Creditor Identifier used
  """
  sepaCreditorIdentifier: String
  updateRequest: SepaDirectDebitPaymentMethodUpdateRequest
}

input SepaDirectDebitB2BPaymentMethodInput {
  """If `true`, the Payment Method will be Enabled"""
  activate: Boolean = false

  """
  If `true`, the transaction will be created with the Swan Creditor Identifier
  """
  useSwanSepaCreditorIdentifier: Boolean! = true

  """
  Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false, otherwise Swan does not take this input into account (even if not empty)
  """
  sepaCreditorIdentifier: String
}

"""SepaDirectDebitCoreMerchantPaymentMethod"""
type SepaDirectDebitCoreMerchantPaymentMethod implements MerchantPaymentMethod {
  """
  Unique identifier tied to every version of a given Merchant Payment Method
  """
  id: ID!

  """The Merchant Payment Method Type"""
  type: MerchantPaymentMethodType!

  """
  Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type
  """
  methodId: ID!

  """Status of the Merchant Payment Method"""
  statusInfo: MerchantPaymentMethodStatusInfo!

  """Version of the Merchant Payment Method"""
  version: Int!

  """Date at which the Merchant Payment Method was last updated"""
  updatedAt: Date!

  """Rolling Reserve applied to the Merchant Payment Method"""
  rollingReserve: RollingReserve

  """Whether this payment method uses the Swan Sepa Creditor Identifier"""
  useSwanSepaCreditorIdentifier: Boolean!

  """
  When the above is false, the value of the Sepa Creditor Identifier used
  """
  sepaCreditorIdentifier: String
  updateRequest: SepaDirectDebitPaymentMethodUpdateRequest
}

input SepaDirectDebitCorePaymentMethodInput {
  """If `true`, the Payment Method will be Pending Review"""
  activate: Boolean = false

  """
  If `true`, the transaction will be created with the Swan Creditor Identifier
  """
  useSwanSepaCreditorIdentifier: Boolean! = true

  """
  Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false, otherwise Swan does not take this input into account (even if not empty)
  """
  sepaCreditorIdentifier: String
}

"""Sepa Direct Debit Creditor"""
interface SEPADirectDebitCreditor {
  """full name of the creditor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String
}

"""Sepa Direct Debit Debtor"""
interface SEPADirectDebitDebtor {
  """full name of the debtor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String
}

"""Sepa Direct Debit Creditor for Input transaction"""
type SEPADirectDebitInCreditor implements SEPADirectDebitCreditor {
  """full name of the creditor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """account number"""
  accountNumber: AccountNumber!
}

"""Sepa Direct Debtor for Input transaction"""
type SEPADirectDebitInDebtor implements SEPADirectDebitDebtor {
  """full name of the debtor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """
  beneficiary if the beneficiary is already saved
  *SOON TO BE DEPRECATED*
  Always empty, It will be removed soon.
  """
  beneficiary: SEPABeneficiary @deprecated(reason: "this field is always empty. It will be removed soon.")
}

interface SEPADirectDebitMandate {
  """
  Unique identifier of the received direct debit mandate, generated by Swan
  """
  id: ID!
}

"""Sepa Direct Debit Creditor for Outgoing transaction"""
type SEPADirectDebitOutCreditor implements SEPADirectDebitCreditor {
  """full name of the creditor (max 70 characters)"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """
  beneficiary if the beneficiary is already saved
  *SOON TO BE DEPRECATED*
  Always empty, It will be removed soon.
  """
  beneficiary: SEPABeneficiary @deprecated(reason: "this field is always empty. It will be removed soon.")

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID
}

"""Sepa Direct Debtor for Outgoing transaction"""
type SEPADirectDebitOutDebtor implements SEPADirectDebitDebtor {
  """full name of the debtor"""
  name: String!

  """maskedIBAN"""
  maskedIBAN: String!

  """IBAN"""
  IBAN: String

  """BIC"""
  BIC: String

  """identifier of a Virtual IBAN"""
  virtualIBANEntryId: ID

  """account number"""
  accountNumber: AccountNumber! @deprecated(reason: "because it is not already implemented (a default value is set).")
}

input SepaDirectDebitPaymentCollectionInput {
  """Payment Mandate ID generated by Swan"""
  mandateId: ID!

  """Date at which the Swan merchant wishes the payment to be executed"""
  requestedExecutionAt: DateTime
}

input SepaDirectDebitPaymentMethodInput {
  """
  If `true`, the transaction will be created with the Swan Creditor Identifier
  """
  useSwanSepaCreditorIdentifier: Boolean! = true

  """
  Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false
  """
  sepaCreditorIdentifier: String
}

type SepaDirectDebitPaymentMethodUpdateRequest implements MerchantPaymentMethodUpdateRequest {
  id: ID!

  """
  If `true`, the transaction will be created with the Swan Creditor Identifier
  """
  useSwanSepaCreditorIdentifier: Boolean!

  """
  Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false
  """
  sepaCreditorIdentifier: String
}

"""
Scheme that will be used to create the underlying payment mandate for this funding source
"""
enum SEPADirectDebitScheme {
  """Sepa Direct Debit Core Scheme"""
  SepaDirectDebitCore

  """Sepa Direct Debit B2B Scheme"""
  SepaDirectDebitB2b
}

"""Sepa Direct Debit transaction"""
type SEPADirectDebitTransaction implements Transaction {
  """unique identifier of the transaction"""
  id: ID!
  supportingDocumentCollections(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: SupportingDocumentCollectionFilterInput
  ): SupportingDocumentCollectionConnection!

  """
  reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain.
  """
  reference: String!

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """creditor information"""
  creditor: SEPADirectDebitCreditor!

  """debtor information"""
  debtor: SEPADirectDebitDebtor!

  """matching account for the transaction"""
  account: Account

  """matching SEPA mandate for the transaction"""
  mandate: SEPADirectDebitMandate

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """reserved amount of the transaction computed with the rolling reserve."""
  reservedAmount: Amount

  """date on which reserved funds become available."""
  reservedAmountReleasedAt: DateTime

  """r-transaction reason"""
  returnReason: TransactionReasonCode

  """true if a transaction statement can be generated for this transaction"""
  statementCanBeGenerated: Boolean

  """project id of the transaction"""
  projectId: ID!

  """merchant profile associated"""
  merchant: MerchantProfile
}

"""Payment direct debit mandate for SEPA"""
type SEPAPaymentDirectDebitMandate implements SEPADirectDebitMandate & PaymentDirectDebitMandate & PaymentMandate {
  """Unique identifier of the SEPA Direct Debit Payment Mandate"""
  id: ID!

  """
  List of transactions associated with the SEPA Payment Direct Debit Mandate.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  transactions(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: TransactionsOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """Unique reference of the SEPA Direct Debit Payment Mandate"""
  reference: String!

  """SEPA Direct Debit Payment Mandate scheme"""
  scheme: SEPAPaymentMandateScheme!

  """SEPA Direct Debit Payment Mandate status information"""
  statusInfo: PaymentMandateStatusInfo!

  """SEPA Direct Debit Payment Mandate sequence"""
  sequence: PaymentMandateSequence!

  """SEPA Direct Debit Payment Mandate PDF document URL"""
  mandateDocumentUrl: String!

  """SEPA Direct Debit Payment Mandate debtor information"""
  debtor: SEPAPaymentMandateDebtor!

  """SEPA direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """SEPA Direct Debit Payment Mandate creditor information"""
  creditor: SEPAPaymentMandateCreditor!

  """Signature date of the SEPA Direct Debit Payment Mandate"""
  signatureDate: Date

  """Creation date of the SEPA Direct Debit Payment Mandate"""
  createdAt: DateTime!

  """Last Update date of the SEPA Direct Debit Payment Mandate"""
  updatedAt: DateTime!

  """
  Date of the the last transaction executed for the concerned SEPA Direct Debit Payment Mandate
  """
  executedAt: DateTime

  """Expiry date of the SEPA Direct Debit Payment Mandate"""
  expiredAt: Date

  """Account Holder information"""
  accountHolder: AccountHolder!

  """Custom name of the mandate"""
  name: String
}

type SEPAPaymentMandateCreditor implements PaymentMandateCreditor {
  """SEPA Direct Debit Payment Mandate creditor UUID"""
  id: ID!

  """SEPA Direct Debit Payment Mandate Sepa Creditor Idenfier (SCI)"""
  identifier: SepaCreditorIdentifier!

  """SEPA Direct Debit Payment Mandate creditor name"""
  name: String!

  """SEPA Direct Debit Payment Mandate creditor address"""
  address: Address!
}

type SEPAPaymentMandateDebtor implements PaymentMandateDebtor {
  """SEPA Direct Debit Payment Mandate debtor name"""
  name: String!

  """SEPA Direct Debit Payment Mandate debtor IBAN"""
  iban: IBAN!

  """SEPA Direct Debit Payment Mandate debtor e-mail"""
  email: String

  """SEPA Direct Debit Payment Mandate debtor country"""
  country: CCA3!

  """
  SEPA Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries
  """
  address: Address
}

input SepaPaymentMandateDebtorInput {
  """SEPA Direct Debit Payment Mandate debtor name"""
  name: String!

  """SEPA Direct Debit Payment Mandate debtor IBAN"""
  IBAN: String!
  address: AddressInput!
}

enum SEPAPaymentMandateScheme {
  """SEPA Direct Debit Core"""
  SepaDirectDebitCore

  """SEPA Direct Debit B2B"""
  SepaDirectDebitB2b
}

"""Received direct debit mandate for SEPA"""
type SEPAReceivedDirectDebitMandate implements SEPADirectDebitMandate & ReceivedDirectDebitMandate {
  """
  Unique identifier of the received SEPA direct debit mandate, generated by Swan
  """
  id: ID!

  """
  List of transactions associated with the SEPA Receive Direct Debit Mandate.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  transactions(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: TransactionsOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """Version of the received SEPA direct debit mandate"""
  version: String!

  """Creation date of the received SEPA direct debit mandate"""
  createdAt: DateTime!

  """Last Update date of the received SEPA direct debit mandate"""
  updatedAt: DateTime!

  """Received SEPA direct debit Unique Mandate Reference (UMR)"""
  reference: String!

  """Received SEPA direct debit mandate scheme"""
  scheme: SEPAReceivedDirectDebitMandateScheme!

  """Received SEPA direct debit mandate sequence"""
  sequence: SEPAReceivedDirectDebitMandateSequence!

  """Received SEPA direct debit creditor"""
  creditor: SEPAReceivedDirectDebitMandateCreditor!

  """Received SEPA direct debit ultimate creditor name"""
  ultimateCreditorName: String

  """
  Date of the last SEPA direct debit transaction executed for the concerned received SEPA direct debit mandate
  """
  executedAt: DateTime

  """Date of signature of the received SEPA direct debit mandate"""
  signatureDate: Date

  """
  Expiry date of the received SEPA direct debit mandate, computed automatically (36 months from the executedAt date)
  """
  expiredAt: Date

  """Mandate status information of the received SEPA direct debit mandate"""
  statusInfo: ReceivedDirectDebitMandateStatusInfo!

  """Account of the received SEPA direct debit mandate debtor"""
  account: Account

  """Iban of the received SEPA direct debit mandate debtor"""
  iban: IBAN!

  """Mandate name"""
  name: String
}

"""SEPA received direct debit mandate creditor"""
type SEPAReceivedDirectDebitMandateCreditor {
  """SEPA Creditor identifier (SCI)"""
  identifier: String!

  """Name of the SEPA creditor"""
  name: String!

  """Address of the SEPA creditor"""
  address: Address!
}

"""Received SEPA direct debit mandate scheme"""
enum SEPAReceivedDirectDebitMandateScheme {
  """
  When the received SEPA direct debit mandate can only be used for SEPA B2B direct debit transactions
  """
  SepaDirectDebitB2b

  """
  When the received SEPA direct debit mandate can only be used for SEPA Core direct debit transactions
  """
  SepaDirectDebitCore
}

"""SEPA received direct debit mandate sequence"""
enum SEPAReceivedDirectDebitMandateSequence {
  """
  When the authorisation is given once by the SEPA Debtor to collect only one single SEPA direct debit
  """
  OneOff

  """
  When the authorisation by the Debtor can be used for regular SEPA direct debits initiated by the Creditor
  """
  Recurrent
}

"""
SEPA Identifier
max 35 Latin characters as follow :
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    0 1 2 3 4 5 6 7 8 9
    / - ? : ( ) . , '  +
with some follow extra rules :
    Content must not start or end with a ‘/’
    Content must not contain ‘//’s
"""
scalar SepaReference

"""
Rejection returned when signature is not valid or remote IP address is not allowed
"""
type ServerConsentCredentialsNotValidOrOutdatedRejection implements Rejection {
  message: String!
}

"""Rejection returned when server consent is not allowed on the consent"""
type ServerConsentNotAllowedForConsentOperationRejection implements Rejection {
  message: String!
}

"""
Rejection returned when server consent is not allowed for the project associated with the consent
"""
type ServerConsentNotAllowedForProjectRejection implements Rejection {
  message: String!
}

"""
Rejection returned when there are no server consent credentials for the project
"""
type ServerConsentProjectCredentialMissingRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the server consent project credentials are not found
"""
type ServerConsentProjectCredentialNotFoundRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the server consent project settings are not found
"""
type ServerConsentProjectSettingsNotFoundRejection implements Rejection {
  message: String!
}

"""
Rejection returned when the signature is not valid
@Deprecated
"""
type ServerConsentSignatureNotValidRejection implements Rejection {
  message: String!
}

"""Shareholder of a company creating a Capital Deposit Case"""
type Shareholder {
  """Unique identifier of a shareholder."""
  id: ID!

  """Amount the shareholder has to deposit."""
  capitalDepositAmount: Amount!

  """Onboarding information of the shareholder."""
  onboarding: Onboarding

  """Unique identifier of the shareholder account."""
  accountId: String

  """Status of the shareholder during the process with Swan."""
  status: ShareholderStatus!

  """Extra information about the shareholder"""
  info: ShareholderInfo!

  """Shareholder documents for the capital deposit case"""
  documents: [CapitalDepositDocument!]!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """Information about capital deposit case."""
  relatedCapitalDepositCase: CapitalDepositCase!
}

"""Shareholder information."""
union ShareholderInfo = IndividualShareholder | CompanyShareholder

"""Status of the shareholder during the process with Swan."""
enum ShareholderStatus {
  """Waiting for the shareholder to finalize their onboarding."""
  PendingOnboarding

  """Waiting for Swan compliance team to verify the shareholder."""
  WaitingForVerification

  """
  Waiting for the shareholder to wire their share of the capital on their temporary Swan account.
  """
  WaitingForTransfer

  """When the shareholder has wired their share of the capital."""
  CapitalTransferred

  """When the shareholder's capital is wired to the notary."""
  CapitalFundsWiredToNotary

  """When the capital deposit of the shareholder is canceled."""
  CapitalDepositCanceled
}

"""Shareholder type to identify individuals and companies."""
enum ShareholderType {
  """Individual shareholder type."""
  Individual

  """Company shareholder type."""
  Company
}

"""Signature data used during apple pay inApp provisioning"""
input SignatureData {
  """nonce"""
  nonce: String!

  """nonce signed by the secure element"""
  nonceSignature: String!

  """list of apple generated certificates"""
  certificates: [Certificate!]!
}

enum SimulationCardType {
  Physical
  Virtual
}

input SingleUseVirtualCardConfigInput {
  """Unique identifier of a given account membership"""
  accountMembershipId: ID!

  """Card name"""
  name: String

  """Spending limit"""
  spendingLimit: SpendingLimitInput!
}

type SmsProviderRejection implements Rejection {
  message: String!
}

"""Spending"""
type Spending {
  """period concerned"""
  period: SpendingLimitPeriod!

  """amount spent during the period"""
  amount: Amount
}

"""Spending limits"""
type SpendingLimit {
  """type of limit (defined by the Partner, defined by Swan, etc.)"""
  type: SpendingLimitType!

  """period concerned"""
  period: SpendingLimitPeriod!

  """sum of amount of spending authorized during the period"""
  amount: Amount!
}

"""Inputs when editing spending limit configuration"""
input SpendingLimitInput {
  """period concerned"""
  period: SpendingLimitPeriodInput!

  """sum of amount of spending authorized during the period"""
  amount: AmountInput!
}

"""Available period to compute spending limits"""
enum SpendingLimitPeriod {
  Monthly
  Weekly
  Daily
  Always
}

"""Available period to compute spending limits"""
enum SpendingLimitPeriodInput {
  Monthly
  Weekly
  Daily
  Always
}

"""Available type of spending limits"""
enum SpendingLimitType {
  """for the account holder - defined by the partner"""
  AccountHolder

  """for the partner - defined by Swan"""
  Partner
}

type StandingOrder {
  """Standing Order unique identifier"""
  id: ID!

  """
  List of payments of an standing order.
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  payments(
    """the number of elements to load (default value 50, maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    offset: Int

    """
    an order you can apply to your list of connections (default value UpdatedAt desc)
    """
    orderBy: PaymentOrderByInput

    """a filtering table you can apply to your list of connections"""
    filters: PaymentFiltersInput
  ): PaymentConnection!

  """
  reference that will be transferred to the beneficiary throughout the entire end-to-end chain
  """
  reference: String

  """label that will be transferred to the beneficiary"""
  label: String

  """Fixed Amount that will be regularly transferred"""
  amount: Amount

  """
  Target available balance value that will be used for periodically clipping the account
  """
  targetAvailableBalance: Amount

  """Scheduled period of Standing Order"""
  period: StandingOrderPeriod!

  """Earlier date the Standing Order will be executed"""
  firstExecutionDate: DateTime

  """Latest date the Standing Order will be executed"""
  lastExecutionDate: DateTime

  """
  *SOON TO BE DEPRECATED*
  SEPA beneficiary of the Standing Order
  """
  sepaBeneficiary: SEPABeneficiary!

  """Status of the Standing Order"""
  statusInfo: StandingOrderStatusInfo!

  """Date the Standing Order has been created"""
  createdAt: Date!

  """Last date the Standing Order has been updated"""
  updatedAt: Date!

  """Account of the Standing Order"""
  account: Account!

  """Identity that scheduled the Standing Order"""
  createdBy: User!

  """Next execution date of the Standing Order, if any"""
  nextExecutionDate: Date

  """Transfer mode of the Standing Order"""
  creditTransferMode: CreditTransferMode
}

type StandingOrderCanceledStatusInfo implements StandingOrderStatusInfo {
  canceledAt: Date!
  status: StandingOrderStatus!
}

"""Please see the Connection interface"""
type StandingOrderConnection implements Connection {
  pageInfo: PageInfo!
  edges: [StandingOrderEdge!]!
  totalCount: Int!
}

type StandingOrderConsentPendingStatusInfo implements StandingOrderStatusInfo {
  status: StandingOrderStatus!
  consent: Consent!
}

"""Please see the Connection interface"""
type StandingOrderEdge implements Edge {
  node: StandingOrder!
  cursor: String!
}

type StandingOrderEnabledStatusInfo implements StandingOrderStatusInfo {
  status: StandingOrderStatus!
}

"""Rejection returned when Standing Order is not found"""
type StandingOrderNotFoundRejection implements Rejection {
  message: String!
}

enum StandingOrderPeriod {
  Daily
  Weekly
  Monthly
}

enum StandingOrderStatus {
  ConsentPending
  Enabled
  Canceled
}

interface StandingOrderStatusInfo {
  status: StandingOrderStatus!
}

"""
Describes an identification level that has started for the process of the current identification
"""
type StartedIdentificationLevelStatusInfo {
  """Always set to `Started`"""
  status: SwanIdentificationStatus!
}

input StartUserCreationInput {
  mobilePhoneNumber: PhoneNumber!
  locale: OtpLocale
}

union StartUserCreationPayload = StartUserCreationSuccess | BlacklistedPhoneNumberRejection | CalledByABotRejection | OperationNotAllowedRejection

type StartUserCreationSuccess {
  requestId: String!
}

"""
A statement represent metadata around a banking document that list all of the BOOKED banking transactions that have happened between startDate and endDate
"""
type Statement {
  """unique identifier of the statement"""
  id: ID!

  """account of the statement"""
  account: Account!

  """booked balance at the start of the window"""
  openingBalance: Amount!

  """booked balance at the end of the window"""
  closingBalance: Amount!

  """starting date of the date window"""
  openingDate: DateTime!

  """ending date of the date window"""
  closingDate: DateTime!

  """status of the statement"""
  status: StatementStatus!

  """period of statement (either custom or monthly)"""
  period: StatementPeriod

  """the sum of credit transactions during the window"""
  totalCredits: Amount!

  """the sum of debit transactions during the window"""
  totalDebits: Amount!

  """the sum of fee transactions during the window"""
  fees: Amount!

  """type of statements (ex: PDF)"""
  type: [StatementInfo]!

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)).
"""
type StatementConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Int!
  edges: [StatementEdge!]!
}

"""Implements the Relay Edge interface."""
type StatementEdge implements Edge {
  node: Statement!
  cursor: String!
}

"""
Filter that can be given to give the statement in a specific data range
"""
input StatementFiltersInput {
  """To filter after an updatedAt value"""
  isAfterUpdatedAt: DateTime

  """To filter before an updatedAt value"""
  isBeforeUpdatedAt: DateTime

  """To filter on a specific period of statement (either custom or monthly)"""
  period: StatementPeriod
}

"""Custom information for a certain type of statement"""
interface StatementInfo {
  type: StatementType
}

"""The different periods of statement"""
enum StatementPeriod {
  Monthly
  Custom
}

"""The different statuses of statement"""
enum StatementStatus {
  Available
  Failed
  Pending
}

"""
The different type of statement actually available
- PDF will be a PDF file with the statement information
"""
enum StatementType {
  PDF
  CSV
}

enum StatusText {
  Success
  Failure
}

"""Rejection returned when the corresponding export is still ongoing"""
type StillExportingRejection implements Rejection {
  message: String!
}

"""
Rejection returned when subscription limit has been reached for specific eventTypes
"""
type SubscriptionLimitsRejection implements Rejection {
  message: String!
  subscriptionLimits: [EventTypeHavingReachedSubscriptionLimits]!
}

type SuccessfulThreeDs {
  status: ThreeDsStatus!
}

"""Supporting document used for compliance"""
type SupportingDocument {
  """Unique identifier of the document"""
  id: String!

  """Supporting document status information"""
  statusInfo: SupportingDocumentStatusInfo!

  """Type of supporting Document"""
  supportingDocumentType: SupportingDocumentType

  """Purpose of supporting document"""
  supportingDocumentPurpose: SupportingDocumentPurposeEnum!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!
}

type SupportingDocumentAccountHolder {
  id: ID
  name: String
}

"""
Collection of supporting documents used for compliance

Fetching SupportingDocument is restricted to Project access token
"""
type SupportingDocumentCollection {
  """Unique identifier of the supporting document collection"""
  id: String!

  """Status of the supporting document collection"""
  statusInfo: SupportingDocumentCollectionStatusInfo!

  """Created date"""
  createdAt: DateTime!

  """Updated date"""
  updatedAt: DateTime!

  """
  List of supported documents contained in the supporting document collection
  """
  supportingDocuments: [SupportingDocument]!

  """
  List of required supporting document purposes for this supporting document collection
  """
  requiredSupportingDocumentPurposes: [SupportingDocumentPurpose!]!
  accountHolder: SupportingDocumentAccountHolder!
  onboarding: SupportingDocumentOnboarding!
  projectInfo: ProjectInfo!

  """SupportingDocumentCollection URL to Swan portal"""
  supportingDocumentCollectionUrl: String!
  type: SupportingDocumentCollectionType!
  transaction: SupportingDocumentTransaction!
  relatedInfo: SupportingDocumentCollectionRelatedInfo!
}

"""Onboarding supporting document collection"""
type SupportingDocumentCollectionAccountHolderVerificationRenewalRelatedInfo implements SupportingDocumentCollectionRelatedInfo {
  type: SupportingDocumentCollectionType!
}

"""Supporting document collection with Approved status"""
type SupportingDocumentCollectionApprovedStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the supporting document collection is approved"""
  status: SupportingDocumentCollectionStatus!

  """Date on which the supporting document collection has been approved"""
  approvedAt: DateTime!
}

"""Supporting document collection with Canceled status"""
type SupportingDocumentCollectionCanceledStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the supporting document collection is canceled"""
  status: SupportingDocumentCollectionStatus!

  """Date on which the supporting document collection has been canceled"""
  canceledAt: DateTime!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type SupportingDocumentCollectionConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """SupportingDocumentCollectionEdge list"""
  edges: [SupportingDocumentCollectionEdge!]!
}

"""Implements the Relay Edge interface"""
type SupportingDocumentCollectionEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The supporting document collection"""
  node: SupportingDocumentCollection!
}

"""
Filters that can be applied when listing supporting document collections
"""
input SupportingDocumentCollectionFilterInput {
  """Supporting document collection type/types we're looking for"""
  type: [SupportingDocumentCollectionType!]

  """Supporting document collection status we're looking for"""
  status: [SupportingDocumentCollectionStatus!]
}

"""Rejection returned if the supporting document collection was not found"""
type SupportingDocumentCollectionNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Onboarding supporting document collection"""
type SupportingDocumentCollectionOnboardingRelatedInfo implements SupportingDocumentCollectionRelatedInfo {
  type: SupportingDocumentCollectionType!
}

"""
Field we can use when ordering that can be applied when listing onboardings
"""
enum SupportingDocumentCollectionOrderByFieldInput {
  createdAt
  id
}

"""Order that can be applied when listing onboardings"""
input SupportingDocumentCollectionOrderByInput {
  field: SupportingDocumentCollectionOrderByFieldInput!
  direction: OrderByDirection!
}

"""Supporting document collection with PendingReview status"""
type SupportingDocumentCollectionPendingReviewStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """
  When the supporting document collection is completed and in compliance review
  """
  status: SupportingDocumentCollectionStatus!
}

"""Supporting document collection with Rejected status"""
type SupportingDocumentCollectionRejectedStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the supporting document collection is rejected"""
  status: SupportingDocumentCollectionStatus!

  """Date on which the supporting document collection has been rejected"""
  rejectedAt: DateTime!
}

interface SupportingDocumentCollectionRelatedInfo {
  """
  Type of the supporting document collection
  - Onboarding is the one created along with an onboarding
  - AccountHolderVerificationRenewal is created for verification renewal
  - Transaction is related to a transaction
  """
  type: SupportingDocumentCollectionType!
}

"""Verification status of a supporting document collection"""
enum SupportingDocumentCollectionStatus {
  """When the supporting document collection is created and on going"""
  WaitingForDocument

  """
  When the supporting document collection is completed and in compliance review
  """
  PendingReview

  """When the supporting document collection is approved. Final status"""
  Approved

  """When the supporting document collection is canceled. Final status"""
  Canceled

  """When the supporting document collection is rejected. Final status"""
  Rejected
}

"""
Rejection returned if supporting document cannot be deleted because its supporting document collection status is not WaitingForDocument
"""
type SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection implements Rejection {
  message: String!
  supportingDocumentCollectionStatus: SupportingDocumentCollectionStatus!
  supportingDocumentCollection: SupportingDocumentCollection!
}

"""
Rejection returned if supporting document cannot be updated because its supporting document collection status is not WaitingForDocument
"""
type SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection implements Rejection {
  message: String!
  supportingDocumentCollectionStatus: SupportingDocumentCollectionStatus!
  supportingDocumentCollection: SupportingDocumentCollection!
}

interface SupportingDocumentCollectionStatusInfo {
  """Status of the supporting document collection"""
  status: SupportingDocumentCollectionStatus!
}

"""Rejection returned if the status transition is not allowed"""
type SupportingDocumentCollectionStatusNotAllowedRejection implements Rejection {
  oldStatus: SupportingDocumentCollectionStatus!
  newStatus: SupportingDocumentCollectionStatus!
  message: String!
}

"""Transaction supporting document collection: related to a transaction"""
type SupportingDocumentCollectionTransactionRelatedInfo implements SupportingDocumentCollectionRelatedInfo {
  type: SupportingDocumentCollectionType!
}

enum SupportingDocumentCollectionType {
  Onboarding
  AccountHolderVerificationRenewal
  Transaction
}

"""Supporting document collection with WaitingForUpload status"""
type SupportingDocumentCollectionWaitingForDocumentStatusInfo implements SupportingDocumentCollectionStatusInfo {
  """When the Supporting Document Collection is created"""
  status: SupportingDocumentCollectionStatus!
}

enum SupportingDocumentCollectMode {
  API
  EndCustomer
  EndCustomerCcPartner
  Partner
}

enum SupportingDocumentCommunicationLanguageSettings {
  en
  fr
}

"""Rejection returned if the supporting document was not found"""
type SupportingDocumentNotFoundRejection implements Rejection {
  id: String!
  message: String!
}

"""Supporting document with NotUploaded status."""
type SupportingDocumentNotUploadedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has not been updated on time."""
  status: SupportingDocumentStatus!
}

type SupportingDocumentOnboarding {
  id: ID
}

type SupportingDocumentPostField {
  key: String!
  value: String!
}

"""Details of a supporting document purpose"""
type SupportingDocumentPurpose {
  """Technical name of the purpose"""
  name: SupportingDocumentPurposeEnum!

  """
  Corresponding supporting document types accepted for this supporting document purpose
  """
  acceptableSupportingDocumentTypes: [SupportingDocumentType!]!

  """
  Corresponding Supporting Document Purpose Title translation according to accept-language header
  """
  label: String!

  """
  Corresponding Supporting Document Purpose Description translation according to accept-language header
  """
  description: String!
}

"""Supporting document purpose"""
enum SupportingDocumentPurposeEnum {
  """Proof of association registration"""
  AssociationRegistration

  """Banking"""
  Banking

  """Proof of company registration"""
  CompanyRegistration

  """Minutes Of The General Assembly"""
  GeneralAssemblyMinutes

  """Other"""
  Other

  """Signed power of attorney document to give the power to act on behalf."""
  PowerOfAttorney

  """Proof of company address"""
  ProofOfCompanyAddress

  """Proof of company income"""
  ProofOfCompanyIncome

  """Proof of identity"""
  ProofOfIdentity

  """Proof of individual address"""
  ProofOfIndividualAddress

  """Proof of individual income"""
  ProofOfIndividualIncome

  """Proof of origin of funds"""
  ProofOfOriginOfFunds

  """Signed status"""
  SignedStatus

  """UBO Declaration"""
  UBODeclaration

  """Sworn statement"""
  SwornStatement

  """Proof of identity of the legal representative"""
  LegalRepresentativeProofOfIdentity

  """Proof of identity of the Ultimate Beneficial Owner"""
  UltimateBeneficialOwnerProofOfIdentity

  """NIF Accreditation Card"""
  NIFAccreditationCard

  """Decision of appointment of the President"""
  PresidentDecisionOfAppointment

  """Decision of appointment of Administrator"""
  AdministratorDecisionOfAppointment

  """Financial Statements"""
  FinancialStatements

  """Proof of address of the Ultimate Beneficial Owner"""
  UltimateBeneficialOwnerProofOfAddress

  """Personal Income"""
  PersonalIncome

  """Personal Savings"""
  PersonalSavings

  """Investment"""
  Investment

  """Donation"""
  Donation

  """Inheritance"""
  Inheritance

  """Real Estate Income"""
  RealEstateIncome

  """Gambling Prize Winnings"""
  GamblingPrizeWinnings

  """Trade"""
  Trade

  """Company Treasury"""
  CompanyTreasury

  """Company Obligations"""
  CompanyObligations

  """Politically exposed person declaration"""
  PepDeclaration

  """Proof of the company creation process"""
  CompanyFormationRegistration
}

"""Refused supporting document reason code"""
enum SupportingDocumentReasonCode {
  """The company name in document doesn’t match our records."""
  CompanyNameMismatch

  """The document must be dated less than 3 months ago."""
  ExpiredDocument

  """The address in document doesn’t match our records."""
  InvalidAddress

  """The document is not valid."""
  InvalidDocument

  """
  The name of shareholder is not clearly visible or some fields are not duely completed.
  """
  InvalidOrMissingData

  """Document cannot be accepted for the requested document type."""
  UnacceptableDocument

  """The document must be in color."""
  ProviderColorIdDocumentRequired

  """Documents are not signed or dated."""
  MissingSignature

  """The quality of the document is really low."""
  BadDocumentQuality

  """Full Document required."""
  FullDocumentRequired

  """
  The document provided is missing essential details required to comprehend the transaction's nature. Please submit an additional supporting document to supplement the initial one.
  """
  MissingDescription

  """
  The document appears to be inconsistent with the specified transaction.
  """
  InvalidTransaction

  """
  The issuer or beneficiary name on the document we received does not match the information requested for the transaction.
  """
  TransactionNameMismatch

  """
  The date on the document we received does not match the information requested for the transaction.
  """
  TransactionDateMismatch

  """
  The amount on the document we received does not match the information requested for the transaction.
  """
  TransactionAmountMismatch

  """
  The beneficiary IBAN on the document we received does not match the information requested for the transaction.
  """
  IbanMismatch

  """Other"""
  Other
}

"""Supporting document with Refused status"""
type SupportingDocumentRefusedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has been refused by Swan"""
  status: SupportingDocumentStatus!

  """Date on which the supporting document collection has been refused"""
  refusedAt: DateTime!

  """Reason why the supporting document has been refused"""
  reason: String!

  """Reason code why the supporting document has been refused"""
  reasonCode: SupportingDocumentReasonCode!

  """Original file name"""
  filename: String!
}

type SupportingDocumentSettings {
  collectMode: SupportingDocumentCollectMode!
  communicationLanguage: SupportingDocumentCommunicationLanguageSettings
  emailContact: String
}

"""Verification status of a document"""
enum SupportingDocumentStatus {
  """Document is not uploaded yet."""
  WaitingForUpload

  """Document has been uploaded but not verified by Swan yet."""
  Uploaded

  """Document has been uploaded and verified by Swan."""
  Validated

  """Document has been refused by Swan."""
  Refused

  """Document has not been uploaded on time."""
  NotUploaded
}

"""
Rejection returned if supporting document cannot be deleted because of its status
"""
type SupportingDocumentStatusDoesNotAllowDeletionRejection implements Rejection {
  supportingDocument: SupportingDocument!
  status: SupportingDocumentStatus!
  message: String!
}

"""
Rejection returned if supporting document cannot be updated because of its status
"""
type SupportingDocumentStatusDoesNotAllowUpdateRejection implements Rejection {
  supportingDocument: SupportingDocument!
  status: SupportingDocumentStatus!
  message: String!
}

interface SupportingDocumentStatusInfo {
  """Status of the supporting document"""
  status: SupportingDocumentStatus!
}

"""Rejection returned if the status transition is not allowed"""
type SupportingDocumentStatusNotAllowedRejection implements Rejection {
  oldStatus: SupportingDocumentStatus!
  newStatus: SupportingDocumentStatus!
  message: String!
}

type SupportingDocumentTransaction {
  id: ID
}

"""Specific type for document"""
enum SupportingDocumentType {
  """Selfie"""
  Selfie

  """Passport"""
  Passport

  """NationalIdCard"""
  NationalIdCard

  """Resident permit"""
  ResidentPermit

  """Driving license"""
  DrivingLicense

  """Water, Electricity or Gas Bill issued within the last 3 months"""
  UtilityBill

  """Telephone Bill issued within the last 3 months"""
  PhoneBill

  """Rental Receipt issued within the last 3 months"""
  RentReceipt

  """Home Insurance contract"""
  HomeInsurance

  """
  Income Tax return or tax-exemption certificate dating less than 2 years
  """
  IncomeTaxReturn

  """A pay slip dating less than 3 months"""
  PaySlip

  """Commercial registry extract issued within the last 3 months"""
  RegisterExtract

  """Legal document required for company’s formation"""
  ArticlesOfIncorporation

  """Share Deposit Certificate"""
  CapitalShareDepositCertificate

  """Ultimate Beneficial Owner Declaration"""
  UBODeclaration

  """Association registration proof for french association"""
  JOAFFEExtract

  """
  Lease agreement in the name of the business or Proof of Individual Address if the company is hosted by one of the legal representative
  """
  CompanyLeaseAgreement

  """Bank Statement"""
  BankStatement

  """
  Document with details such as bank name, address, account number and account holder
  """
  BankAccountDetails

  """Signed power of attorney document to give the power to act on behalf"""
  PowerOfAttorney

  """
  Document submitted to your tax bureau at the end of the last business period
  """
  CorporateIncomeTaxReturn

  """Other"""
  Other

  """By Laws"""
  ByLaws

  """Account statement"""
  AccountStatement

  """Deed of donation"""
  DeedOfDonation

  """Deed of sale"""
  DeedOfSale

  """Deed of succession"""
  DeedOfSuccession

  """Loan contract"""
  LoanContract

  """Notarial deed"""
  NotarialDeed

  """Sworn statement"""
  SwornStatement

  """Meeting's minutes"""
  MeetingMinutes

  """NIF Accreditation Card"""
  NIFAccreditationCard

  """Decision of appointment"""
  DecisionOfAppointment

  """Financial Statements"""
  FinancialStatements

  """Winnings Certificate"""
  WinningsCertificate

  """Invoice"""
  Invoice

  """Politically exposed person declaration"""
  PepDeclaration
}

"""Supporting document with Uploaded status"""
type SupportingDocumentUploadedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has been uploaded but not verified by Swan yet"""
  status: SupportingDocumentStatus!

  """Original file name"""
  filename: String!
}

type SupportingDocumentUploadInfo {
  url: String!
  fields: [SupportingDocumentPostField!]!
}

"""
Rejection returned if the supporting document collection cannot receive supporting documents anymore
"""
type SupportingDocumentUploadNotAllowedRejection implements Rejection {
  supportingDocumentCollectionStatus: SupportingDocumentCollectionStatus!
  message: String!
}

"""Supporting document with Validated status"""
type SupportingDocumentValidatedStatusInfo implements SupportingDocumentStatusInfo {
  """When the document has been uploaded and verified by Swan"""
  status: SupportingDocumentStatus!

  """Date on which the supporting document has been validated"""
  validatedAt: DateTime!

  """Original file name"""
  filename: String!

  """Reason why the supporting document has been validated"""
  reason: String!
}

"""Supporting document with WaitingForUpload status"""
type SupportingDocumentWaitingForUploadStatusInfo implements SupportingDocumentStatusInfo {
  """When the document is not uploaded yet"""
  status: SupportingDocumentStatus!

  """
  Info to upload the document : url and fields to add along file in form (POST)
  """
  upload: SupportingDocumentUploadInfo!
}

input SuspendAccountMembershipInput {
  accountMembershipId: ID!
}

union SuspendAccountMembershipPayload = SuspendAccountMembershipSuccessPayload | InternalErrorRejection | LegalRepresentativeAccountMembershipCannotBeSuspendedRejection | UserNotAllowedToManageAccountMembershipRejection | UserNotAllowedToSuspendItsOwnAccountMembershipRejection | ValidationRejection

type SuspendAccountMembershipSuccessPayload {
  accountMembership: AccountMembership!
}

"""
Define a reason with a message and a specific type for suspend account action
"""
type SuspendAccountReason implements Reason {
  type: SuspendAccountReasonType!
  message: String
}

"""Input version"""
input SuspendAccountReasonInput {
  type: SuspendAccountReasonType!
  message: String
}

"""Specific type for suspend account action"""
enum SuspendAccountReasonType {
  """Simple suspend request"""
  SuspendRequested
}

"""SuspendAccountStatusReason"""
union SuspendAccountStatusReason = SuspendAccountReason

"""StatusInfo when funding limit settings has been suspended"""
type SuspendedFundingLimitSettingsStatusInfo implements FundingLimitSettingsStatusInfo {
  status: FundingLimitSettingsStatus!
  reason: String!
}

"""Funding Source Suspended status information"""
type SuspendedFundingSourceStatusInfo implements FundingSourceStatusInfo {
  """Funding Source Suspended status"""
  status: FundingSourceStatus!

  """Date at which the funding source was suspended"""
  suspendedAt: Date!
}

"""SuspendedMerchantPaymentMethodStatusInfo"""
type SuspendedMerchantPaymentMethodStatusInfo implements MerchantPaymentMethodStatusInfo {
  status: MerchantPaymentMethodStatus!

  """Merchant Payment Method suspended date"""
  suspendedAt: Date!
}

"""SuspendedMerchantProfileStatusInfo"""
type SuspendedMerchantProfileStatusInfo implements MerchantProfileStatusInfo {
  status: MerchantProfileStatus!
  suspendedAt: Date!
}

"""Inputs to suspend a physical card"""
input SuspendPhysicalCardInput {
  """Unique identifier of a card"""
  cardId: ID!
}

union SuspendPhysicalCardPayload = SuspendPhysicalCardSuccessPayload | AccountMembershipNotAllowedRejection | CardNotFoundRejection | ForbiddenRejection | PhysicalCardNotFoundRejection | ValidationRejection

type SuspendPhysicalCardSuccessPayload {
  """The physicalCard suspended"""
  physicalCard: PhysicalCard!
}

"""
Rejection returned if the SuspendReceivedDirectDebitMandatedRejection mutation is rejected
"""
type SuspendReceivedDirectDebitMandatedRejection implements Rejection {
  message: String!
  reason: SuspendReceivedDirectDebitMandatedRejectionReason!
}

"""
Enum of reasons of rejection for suspendReceivedDirectDebitMandate mutation
"""
enum SuspendReceivedDirectDebitMandatedRejectionReason {
  """
  Received direct debit mandate is canceled and therefore can't be suspend
  """
  ReceivedDirectDebitMandateCanceled
}

"""Inputs to suspend a received direct debit mandate"""
input SuspendReceivedDirectDebitMandateInput {
  receivedDirectDebitMandateId: ID!
}

"""Union type returned by the suspendReceivedDirectDebitMandate mutation"""
union SuspendReceivedDirectDebitMandatePayload = SuspendReceivedDirectDebitMandateSuccessPayload | SuspendReceivedDirectDebitMandatedRejection | ReceivedDirectDebitMandateNotFoundRejection | ReceivedDirectDebitMandateCanceledRejection | ForbiddenRejection

"""
Return type in case of a successful response of the suspendReceivedDirectDebitMandate mutation
"""
type SuspendReceivedDirectDebitMandateSuccessPayload {
  """the received direct debit mandate is suspended"""
  receivedDirectDebitMandate: ReceivedDirectDebitMandate!
}

"""Swan account beneficiary"""
input SwanAccountBeneficiaryInput {
  """account number to be credited"""
  accountNumber: AccountNumber!

  """full name of the beneficiary  (max 70 characters)"""
  name: String!

  """
  `true` if this new beneficiary will be saved to the beneficiary list of the debited account.
  """
  save: Boolean!
}

"""Status values of an identification"""
enum SwanIdentificationStatus {
  """
  When the identification process is currently being treated by a manual or automatic process
  """
  Pending

  """When the identification is valid"""
  Valid

  """When the identification is invalid"""
  Invalid

  """
  When the user canceled the identification process or the identification service was unavailable
  """
  Canceled

  """When the identification is no longer valid"""
  Expired

  """When the identification does not support an identification level"""
  NotSupported

  """When the identification hasn't been started yet"""
  NotStarted @deprecated(reason: "Use 'Started' instead. Deprecated to ensure consistency and clear identification status behavior.")

  """When the identification has been started"""
  Started
}

type SwanTCUDocumentEffectiveDateNotAllowedRejection implements Rejection {
  message: String!
}

type SwanTCUDocumentNotFoundRejection implements Rejection {
  message: String!
}

type SwanTCUDocumentStatusNotAllowedRejection implements Rejection {
  message: String!
}

type TextField implements Field {
  displayFormat: String
  example: String
  key: String!
  maxLength: Int
  minLength: Int
  name: String!
  refreshDynamicFieldsOnChange: Boolean!
  required: Boolean!
  validationRegex: String
}

"""The details of the 3DS challenge associated to the payment."""
type ThreeDS {
  """`true` if a 3DS challenge has been requested from the card holder"""
  requested: Boolean!

  """The status of the 3DS challenge"""
  statusInfo: ThreeDsStatusInfo!
}

enum ThreeDsStatus {
  Successful
  Failed
}

interface ThreeDsStatusInfo {
  status: ThreeDsStatus!
}

"""Individual ultimate beneficial owner title (Mr/Ms)"""
enum TitleEnum {
  """Identified as a man"""
  Mr

  """Identified as a woman"""
  Ms
}

scalar TokenRequestorId

"""
Rejection returned when trying to create a multi consent with too many child consents
"""
type TooManyChildConsentsRejection implements Rejection {
  message: String!
}

"""Rejection returned if too many items are given"""
type TooManyItemsRejection implements Rejection {
  message: String!
}

"""Transaction"""
interface Transaction {
  """unique identifier of the transaction"""
  id: ID!

  """external identifier of the transaction"""
  reference: String!

  """
  payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber
  """
  paymentMethodIdentifier: String!

  """side (Credit or Debit)"""
  side: TransactionSide!

  """type"""
  type: TransactionTypeEnum!

  """amount"""
  amount: Amount!

  """label"""
  label: String!

  """status information"""
  statusInfo: TransactionStatusInfo!

  """ID of the payment associated to this transaction"""
  paymentId: String

  """payment associated to this transaction"""
  payment: Payment

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """
  name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ...
  """
  counterparty: String!

  """booked balance after this transaction"""
  bookedBalanceAfter: Amount

  """payment product used for this transaction"""
  paymentProduct: PaymentProduct!

  """matching account for this transaction"""
  account: Account

  """
  an arbitrary identifier that was defined by you when you created this transaction.
  
  For example, you can define it in the CreditTransferInput mutation.
  """
  externalReference: String

  """
  a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions.
  """
  executionDate: DateTime!

  """
  a date that reflects the time at which the user asked the transaction to be executed
  """
  requestedExecutionAt: DateTime

  """ID of the origin transaction associated to this transaction"""
  originTransactionId: String

  """origin transaction associated to this transaction"""
  originTransaction: Transaction

  """true if a transaction statement can be generated for this transaction"""
  statementCanBeGenerated: Boolean

  """project id of the transaction"""
  projectId: ID!
}

"""Please see the Connection interface"""
type TransactionConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Int!
  edges: [TransactionEdge!]!
}

"""Please see the Edge interface"""
type TransactionEdge implements Edge {
  node: Transaction!
  cursor: String!
}

"""Rejection returned if the transaction was not found"""
type TransactionNotFoundRejection implements Rejection {
  transactionId: ID!
  message: String!
}

"""The following reason codes for a r-transaction are defined:"""
enum TransactionReasonCode {
  """Rejected because the account is closed"""
  AccountClosed

  """Rejected because the account holder is deceased"""
  AccountHolderDeceased

  """
  Rejected because the beneficiary account has a limit that can be unblocked
  """
  AccountLimited

  """Rejected because the account is suspended"""
  AccountSuspended

  """Rejected because the account is unknown"""
  AccountUnknown

  """Rejected by the bank"""
  BankRefused

  """Creditor account is blocked"""
  BeneficiaryAccountBlocked

  """Creditor account is closed"""
  BeneficiaryAccountClosed

  """Creditor account number is incorrect"""
  BeneficiaryAccountIncorrect

  """Creditor account number does not exist"""
  BeneficiaryAccountUnknown

  """The account number matches, but the creditor’s name does not"""
  BeneficiaryBankBicInvalid

  """The account number matches, but the creditor's name does not"""
  BeneficiaryBranchCodeInvalid

  """Recipient phone number is incorrect"""
  BeneficiaryPhoneNumberInvalid

  """The recipient's ID document number is invalid"""
  BeneficiaryIdNumberInvalid

  """
  The recipient’s account currency is different than the transfer currency
  """
  BeneficiaryRutNumberInvalid

  """Tax ID doesn't match recipient's name"""
  BeneficiaryTaxIdInvalid

  """Tax ID is suspended"""
  BeneficiaryTaxIdSuspended

  """
  The recipient’s account currency is different than the transfer currency
  """
  BeneficiaryCurrencyInvalid

  """Rejected because the creditor bank is not reachable"""
  BeneficiaryBankNotReachable

  """Customer is deceased"""
  BeneficiaryDeceased

  """Rejected because the card is expired"""
  CardExpired

  """Rejected because the card is not activated yet"""
  CardNotActivated

  """Rejected because the card has been permanently blocked"""
  CardPermanentlyBlocked

  """Rejected because the card is suspended"""
  CardSuspended

  """The payer has blocked the check payment"""
  CheckBlocked

  """Invalid check"""
  CheckInvalid

  """The check payment can’t be fulfilled because it’s too old"""
  CheckOutdated

  """Invalid check number"""
  CheckNumberInvalid

  """Rejected because the creditor bank is offline"""
  CreditorBankOffline

  """Rejected following an error from the creditor bank"""
  CreditorBankTechnicalErrorOccurred

  """Rejected following a timeout from the creditor bank"""
  CreditorBankTimeout

  """Debtor Account Blocked"""
  DebtorAccountBlocked

  """Rejected because the debtor account is closed"""
  DebtorAccountClosed

  """
  Rejected because the debtor is a non business account and the transaction is a B2B SEPA Direct Debit transaction
  """
  DebtorAccountConsumer

  """Rejected because the debtor account is unknown"""
  DebtorAccountUnknown

  """Rejected because the debtor bank is offline"""
  DebtorBankOffline

  """Rejected following an error from the debtor bank"""
  DebtorBankTechnicalErrorOccurred

  """Rejected following a timeout from the debtor bank"""
  DebtorBankTimeout

  """Rejected because the debtor account holder is dead"""
  DebtorDeceased

  """
  The check payment can’t be fulfilled because the signature is missing or invalid
  """
  EndorsementMissingOrInvalid

  """The check payment can’t be fulfilled because of a fraud"""
  Fraudulent

  """Funds already transferred back to the originator"""
  FundsAlreadyTransferredBack

  """Rejected because of insufficient funds on the account"""
  InsufficientFunds

  """The account number matches, but the creditor’s name does not"""
  InvalidCreditorName

  """
  Rejected because the expiration date entered does not match the one on the card
  """
  InvalidExpirationDate

  """Rejected because the PIN is invalid"""
  InvalidPin

  """
  Rejected because there were too many invalid tries on the PIN validation
  """
  InvalidPinAttemptsExceeded

  """
  Rejected because the security number entered does not match the one on the card
  """
  InvalidSecurityNumber

  """Funds cannot be reimbursed by beneficiary bank/legal decision"""
  LegalOrBankDecision

  """Rejected by debtor because the mandate is invalid"""
  MandateInvalid

  """
  The check payment can’t be fulfilled because a mandatory piece of information is missing on the check
  """
  MandatoryReferenceMissingOnCheck

  """
  Rejected because the merchant must request a new transaction with authorisation
  """
  MerchantShouldResubmitAuthorization

  """No answer from customer"""
  NoAnswerFromBeneficiary

  """No original transaction received"""
  NoOriginalTransactionReceived

  """Rejected by the partner (you)"""
  PartnerRefused

  """Rejected following an error or a timeout from the partner"""
  PartnerTechnicalErrorOccurred

  """
  Rejected because the maximum amount allowed on the given period has been exceeded
  """
  PeriodAmountLimitExceeded

  """
  Rejected because the maximum number of transactions on the given period has been exceeded
  """
  PeriodNbTransactionLimitExceeded

  """
  Rejected because a transaction with PIN code is required to continue to using the card
  """
  PinRequiredForFurtherTransaction

  """Rejected by bank with no specified reason"""
  ReasonNotSpecifiedByBank

  """Reason unspecified"""
  ReasonNotSpecifiedByBeneficiary

  """Rejected by debtor with no specified reason"""
  ReasonNotSpecifiedByDebtor

  """Customer request"""
  ReasonNotSpecifiedByOriginator

  """Recall request accepted by beneficiary bank or beneficiary"""
  RecallAccepted

  """Refund requested by end customer"""
  RefundRequestedByDebtor

  """The creditor requested the transaction to be refunded"""
  RefundRequestedByCreditor

  """Rejected by bank for regulatory reason"""
  RegulatoryReason

  """Invalid RLMC key, please control the key and the check number"""
  RlmcKeyInvalid

  """The check payment can’t be fulfilled because the signature is invalid"""
  SignatureInvalid

  """Rejected because the debtor or the creditor bank is offline"""
  SwanOffline

  """Rejected by Swan"""
  SwanRefused

  """Rejected because of a Swan technical error"""
  SwanTechnicalErrorOccurred

  """Rejected because of a Swan timeout"""
  SwanTimeout

  """Technical issue resulting in incorrect transactions sent out"""
  TechnicalIssue

  """Rejected because the terms and conditions limit has been exceeded"""
  TermsAndConditionsLimitExceeded

  """Wrong transaction amount"""
  TransactionAmountIncorrect

  """
  Rejected because the maximum amount for a transaction has been exceeded
  """
  TransactionAmountLimitExceeded

  """Recipient bank can't accept the payments from 3rd party"""
  TargetCurrencyNotAvailable

  """Rejected by bank because this transaction is duplicated"""
  TransactionDuplicated

  """Rejected because the transaction is forbidden on this type of account"""
  TransactionOnAccountTypeNotAllowed

  """Recipient account doesn't support payments to this card type"""
  TransactionOnCardTypeNotAllowed

  """
  The recipient’s account currency is different than the transfer currency
  """
  TransactionPurposeInvalid

  """Invalid payment reference"""
  TransactionReferenceInvalid

  """Rejected because the type of transaction is forbidden on the account"""
  TransactionTypeNotAllowed
}

"""the criteria to filter transactions"""
input TransactionsFiltersInput {
  """To filter on some Transaction Status (all if empty)"""
  status: [TransactionStatus!]

  """To filter on some Payment Products (all if empty)"""
  paymentProduct: [PaymentProduct!]

  """To filter after an updatedAt value"""
  isAfterUpdatedAt: DateTime

  """To filter before an updatedAt value"""
  isBeforeUpdatedAt: DateTime

  """To filter on some text occurrences (words or ids)"""
  search: String

  """To filter on some transaction types"""
  type: [TransactionTypeEnum!]

  """
  To filter so it includes rejected transactions that had a fallback (`true` by default)
  """
  includeRejectedWithFallback: Boolean
}

"""Transaction side"""
enum TransactionSide {
  """when the transaction debit the account"""
  Debit

  """when the transaction credit the account"""
  Credit
}

enum TransactionsOrderByField {
  id
  createdAt
  updatedAt
  executionDate
}

"""the criteria to sort transactions"""
input TransactionsOrderByInput {
  field: TransactionsOrderByField
  direction: OrderByDirection
}

"""A transaction statement represent metadata around a BOOKED transaction"""
type TransactionStatement {
  """unique identifier of the transaction statement"""
  id: ID!

  """matching account for this transaction statement"""
  account: Account!

  """transaction for which the statement is generated"""
  transaction: Transaction

  """status information of the transaction statement"""
  statusInfo: TransactionStatementStatusInfo!

  """date at which the statement generation has been requested"""
  createdAt: DateTime!

  """date at which the statement generation status has been updated"""
  updatedAt: DateTime!

  """projectId of this transaction"""
  projectId: ID!
}

"""Language: ISO 639-1 language code"""
enum TransactionStatementLanguage {
  de
  en
  fr
  it
  nl
  es
  pt
  fi
}

"""The different statuses of transaction statement"""
enum TransactionStatementStatusEnum {
  Pending
  Generated
  Failed
  Expired
}

interface TransactionStatementStatusInfo {
  """status of the transaction statement"""
  status: TransactionStatementStatusEnum!
}

"""Transaction status"""
enum TransactionStatus {
  """
  when the transaction is posted to the Swan book and impact the booked balance
  """
  Booked

  """when the transaction is rejected"""
  Rejected

  """
  when the transaction is pending and the amount impact the available balance
  """
  Pending

  """
  when a pending transaction is canceled and the amount is released on the available balance
  """
  Canceled

  """
  when the transaction is upcoming (scheduled credit transfer, direct debit ...)
  """
  Upcoming

  """
  when a card authorization is released after X days or fully consumed by X debits
  """
  Released
}

"""Transaction Status information"""
interface TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!
}

"""Indicator of the transit type used"""
enum TransactionTransportType {
  Prefunded
  RealTimeAuthorized
  PostAuthorizedAggregated
  PostAuthorizedAggregatedMaestro
  AuthorizedAggregatedSplitClearing
  Other
  DebtRecovery
}

"""Transaction Type"""
enum TransactionTypeEnum {
  """When an internal Credit Transfer debited a Swan account."""
  InternalCreditTransferOut

  """
  When an internal Credit Transfer debited a Swan account and Swan or the Swan creditor returned the funds.
  """
  InternalCreditTransferOutReturn

  """
  When an internal Credit Transfer debited a Swan account, Swan or the Swan debtor asked for a recall of the transaction, and Swan or the Swan creditor accepted the recall request.
  """
  InternalCreditTransferOutRecall

  """When an internal Credit Transfer credited a Swan account."""
  InternalCreditTransferIn

  """
  When an internal Credit Transfer credited a Swan account and Swan or the Swan debtor returned the funds.
  """
  InternalCreditTransferInReturn

  """
  When an internal Credit Transfer credited a Swan account, Swan or the Swan creditor asked for a recall of the transaction, and Swan or the Swan debtor accepted the recall request.
  """
  InternalCreditTransferInRecall

  """When a Sepa Credit Transfer debited a Swan account."""
  SepaCreditTransferOut

  """When an instant Sepa Credit Transfer debited a Swan account."""
  SepaInstantCreditTransferOut

  """When an instant Sepa Credit Transfer credited a Swan account."""
  SepaInstantCreditTransferIn

  """
  When a Sepa Credit Transfer debited a Swan account and the creditor bank or the creditor returned the funds.
  """
  SepaCreditTransferOutReturn

  """
  When a Sepa Instant Credit Transfer debited a Swan account, Swan or the Swan debtor asked for a recall of the transaction, and the creditor bank or the creditor accepted the recall request.
  """
  SepaInstantCreditTransferOutRecall

  """
  When a Sepa Instant Credit Transfer credited a Swan account, Swan or the Swan creditor asked for a recall of the transaction, and the debtor bank or the debtor accepted the recall request.
  """
  SepaInstantCreditTransferInRecall

  """
  When a Sepa Credit Transfer debited a Swan account, Swan or the Swan debtor asked for a recall of the transaction, and the creditor bank or the creditor accepted the recall request.
  """
  SepaCreditTransferOutRecall

  """When a Sepa Credit Transfer credited a Swan account."""
  SepaCreditTransferIn

  """
  When a Sepa Credit Transfer credited a Swan account and Swan or the Swan debtor returned the funds.
  """
  SepaCreditTransferInReturn

  """
  When a Sepa Credit Transfer credited a Swan account, Swan or the Swan creditor asked for a recall of the transaction, and the debtor bank or the debtor accepted the recall request.
  """
  SepaCreditTransferInRecall

  """When a fee is debited from a Swan account."""
  FeesOut

  """When a fee is credited to a Swan account."""
  FeesIn

  """When a Sepa Direct Debit credited a Swan account."""
  SepaDirectDebitIn

  """
  When a Sepa Direct Debit credited a Swan account and the debtor bank or the debtor returned it.
  """
  SepaDirectDebitInReturn

  """
  *COMING SOON*
  When a Sepa Direct Debit credited a Swan account and Swan or the Swan creditor reversed it.
  """
  SepaDirectDebitInReversal

  """When a Sepa Direct Debit debited a Swan account."""
  SepaDirectDebitOut

  """
  When a Sepa Direct Debit debited a Swan account and Swan or the Swan debtor returned it.
  """
  SepaDirectDebitOutReturn

  """
  When a Sepa Direct Debit debited a Swan account and the creditor bank or the creditor reversed it.
  """
  SepaDirectDebitOutReversal

  """A card issued from a Swan account received an authorization or advice."""
  CardOutAuthorization

  """A card issued from a Swan account received a debit."""
  CardOutDebit

  """
  A debit received by card issued from a Swan account was reversed. The amount is credited to the Swan account.
  """
  CardOutDebitReversal

  """A card issued from a Swan account received a credit."""
  CardOutCredit

  """
  A credit received by a card issued from a Swan account was reversed. The amount is debited from the Swan account.
  """
  CardOutCreditReversal

  """
  A credit received by a card issued from a Swan account was reversed. The amount is debited from the Swan account.
  """
  InternalDirectDebitIn

  """
  When an Internal Direct Debit credited a Swan account and Swan or the debtor returned the funds.
  """
  InternalDirectDebitInReturn

  """When an Internal Direct Debit debited a Swan account."""
  InternalDirectDebitOut

  """
  When an Internal Direct Debit debited a Swan account and Swan or the debtor returned the funds.
  """
  InternalDirectDebitOutReturn

  """When a Check credited a Swan account."""
  CheckIn

  """
  When a Check credited a Swan account and Swan or the debtor returned the funds.
  """
  CheckInReturn

  """When an International Credit Transfer credited a Swan account."""
  InternationalCreditTransferIn

  """When an International Credit Transfer debited a Swan account."""
  InternationalCreditTransferOut

  """
  When an International Credit Transfer credited a Swan account and Swan or the Swan debtor returned the funds.
  """
  InternationalCreditTransferInReturn

  """
  When an International Credit Transfer debited a Swan account and Swan or the Swan debtor returned it.
  """
  InternationalCreditTransferOutReturn

  """When a card credit credited a Swan account."""
  CardInCredit
}

"""TrustedBeneficiary"""
interface TrustedBeneficiary {
  """unique identifier of a trusted beneficiary"""
  id: ID!

  """List of transactions associated with the Trusted Beneficiary."""
  transactions(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """full name of the beneficiary"""
  name: String!

  """label of the beneficiary"""
  label: String!

  """status information"""
  statusInfo: TrustedBeneficiaryStatusInfo!

  """type of the beneficiary"""
  type: BeneficiaryType!
}

"""TrustedBeneficiary status canceled"""
type TrustedBeneficiaryCanceledStatusInfo implements TrustedBeneficiaryStatusInfo {
  """status of the beneficiary (set to `Canceled`)"""
  status: TrustedBeneficiaryStatus!

  """canceled Date"""
  canceledAt: DateTime!
}

"""Please see the Connection interface"""
type TrustedBeneficiaryConnection implements Connection {
  pageInfo: PageInfo!
  edges: [TrustedBeneficiaryEdge!]!
  totalCount: Int!
}

"""TrustedBeneficiary status consent pending"""
type TrustedBeneficiaryConsentPendingStatusInfo implements TrustedBeneficiaryStatusInfo {
  """status of the beneficiary  (set to `ConsentPending`)"""
  status: TrustedBeneficiaryStatus!

  """The consent required to initiate this beneficiary"""
  consent: Consent!
}

"""Please see the Edge interface"""
type TrustedBeneficiaryEdge implements Edge {
  node: TrustedBeneficiary!
  cursor: String!
}

"""TrustedBeneficiary status enabled"""
type TrustedBeneficiaryEnabledStatusInfo implements TrustedBeneficiaryStatusInfo {
  """status of the beneficiary (set to `Enabled`)"""
  status: TrustedBeneficiaryStatus!

  """enabled Date"""
  enabledAt: DateTime!
}

"""Filters that can be applied when listing trusted beneficiaries"""
input TrustedBeneficiaryFiltersInput {
  status: [TrustedBeneficiaryStatus!]
  type: [BeneficiaryType!]
  label: String
  currency: Currency
}

"""
Field we can use when ordering that can be applied when listing trusted beneficiaries
"""
enum TrustedBeneficiaryOrderByFieldInput {
  createdAt
  label
  updatedAt
}

"""Order that can be applied when listing trusted beneficiaries"""
input TrustedBeneficiaryOrderByInput {
  field: TrustedBeneficiaryOrderByFieldInput
  direction: OrderByDirection
}

"""TrustedBeneficiary status"""
enum TrustedBeneficiaryStatus {
  """when the beneficiary has been canceled"""
  Canceled

  """when a consent is pending before initiating"""
  ConsentPending

  """when the beneficiary has been enabled"""
  Enabled
}

"""TrustedBeneficiary status information"""
interface TrustedBeneficiaryStatusInfo {
  """status of the beneficiary"""
  status: TrustedBeneficiaryStatus!
}

"""Trusted Internal Beneficiary"""
type TrustedInternalBeneficiary implements TrustedBeneficiary {
  """unique identifier of a trusted beneficiary"""
  id: ID!

  """List of transactions associated with the Trusted Beneficiary."""
  transactions(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """full name of the beneficiary"""
  name: String!

  """label of the beneficiary"""
  label: String!

  """status information"""
  statusInfo: TrustedBeneficiaryStatusInfo!

  """type of the beneficiary"""
  type: BeneficiaryType!

  """beneficiary account Id"""
  accountId: ID!
}

"""Trusted International Beneficiary"""
type TrustedInternationalBeneficiary implements InternationalBeneficiary & TrustedBeneficiary {
  """unique identifier of a trusted beneficiary"""
  id: ID!

  """Currency of the international beneficiary"""
  currency: Currency!

  """Route that Swan will use to transfer the funds"""
  route: InternationalCreditTransferRoute!

  """Currency-specific details of the beneficiary"""
  details: [InternationalCreditTransferDetails!]!

  """name of the beneficiary"""
  name: String!

  """List of transactions associated with the Trusted Beneficiary."""
  transactions(
    """number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput
  ): TransactionConnection

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """label of the beneficiary"""
  label: String!

  """status information"""
  statusInfo: TrustedBeneficiaryStatusInfo!

  """type of the beneficiary"""
  type: BeneficiaryType!
}

"""Trusted SEPA Beneficiary type SEPA"""
type TrustedSepaBeneficiary implements TrustedBeneficiary {
  """unique identifier of a trusted beneficiary"""
  id: ID!

  """List of transactions associated with the Trusted Beneficiary."""
  transactions(
    """When the list of elements needs to start after a element"""
    after: String

    """When the list of elements needs to be filtered"""
    filters: TransactionsFiltersInput

    """number of elements in the list (default value 50)"""
    first: Int! = 50
  ): TransactionConnection

  """created date"""
  createdAt: DateTime!

  """updated date"""
  updatedAt: DateTime!

  """full name of the beneficiary"""
  name: String!

  """label of the beneficiary"""
  label: String!

  """status information"""
  statusInfo: TrustedBeneficiaryStatusInfo!

  """type of the beneficiary"""
  type: BeneficiaryType!

  """
  IBAN if the beneficiary is a an account in an other financial institution
  """
  iban: IBAN!

  """beneficiary address"""
  address: Address
}

"""Quality of the account holder doing the onboarding"""
enum TypeOfRepresentation {
  """The account holder is the legal representative"""
  LegalRepresentative

  """The account holder has a power of attorney"""
  PowerOfAttorney
}

type UBOIdentityDocumentDetails {
  """Type of identity document"""
  type: UBOIdentityDocumentType

  """Issue date of the identity document"""
  issueDate: String

  """Expiry date of the identity document"""
  expiryDate: String

  """Number of the identity document"""
  number: String

  """Issuing authority of the identity document"""
  issuingAuthority: String
}

input UBOIdentityDocumentDetailsInput {
  """Type of identity document"""
  type: UBOIdentityDocumentType

  """Issue date of the identity document"""
  issueDate: String

  """Expiry date of the identity document"""
  expiryDate: String

  """Number of the identity document"""
  number: String

  """Issuing authority of the identity document"""
  issuingAuthority: String
}

enum UBOIdentityDocumentType {
  Passport
  IdCard
}

"""Ultimate beneficial Direct Owner company info."""
type UltimateBeneficialDirectOwnerCompanyInfo implements UltimateBeneficialOwnerInfo {
  """Ultimate Beneficial Owner Unique Identifier ."""
  id: ID!

  """Ultimate beneficial Direct Owner Company type."""
  type: UltimateBeneficialOwnerType!

  """
  Shares ratio of the parent company. Example: 50 if the share ratio is 50%.
  """
  parentCompanyShareRatio: Float!

  """Name of the company."""
  name: String!

  """
  Registration number of the company (for example, Système d'Identification du Répertoire des ENtreprises [SIREN] in France, ...).
  - Length must be from 0 to 50 characters.
  """
  registrationNumber: String!
}

"""Ultimate beneficial Direct Owner individual info."""
type UltimateBeneficialDirectOwnerIndividualInfo implements UltimateBeneficialOwnerInfo {
  """Ultimate Beneficial Owner Unique Identifier ."""
  id: ID!

  """Ultimate beneficial Direct owner Individual type ."""
  type: UltimateBeneficialOwnerType!

  """
  Shares ratio of the parent company. Example: 50 if the share ratio is 50%.
  """
  parentCompanyShareRatio: Float!

  """First name."""
  firstName: String!

  """Last name."""
  lastName: String!

  """Birth date."""
  birthDate: Date!
}

"""Ultimate beneficial owner company info."""
type UltimateBeneficialIndirectOwnerCompanyInfo implements UltimateBeneficialOwnerInfo {
  """Ultimate Beneficial Owner Unique Identifier ."""
  id: ID!

  """Ultimate beneficial Indirect Owner Company type."""
  type: UltimateBeneficialOwnerType!

  """Unique Reference of the Parent Company."""
  parentCompanyReference: String!

  """
  Shares ratio of the parent company. Example: 50 if the share ratio is 50%.
  """
  parentCompanyShareRatio: Float!

  """Name of the company."""
  name: String!

  """
  Registration number of the company (for example, Système d'Identification du Répertoire des ENtreprises [SIREN] in France, ...).
  - Length must be from 0 to 50 characters.
  """
  registrationNumber: String!
}

"""Ultimate beneficial Indirect Owner individual info."""
type UltimateBeneficialIndirectOwnerIndividualInfo implements UltimateBeneficialOwnerInfo {
  """Ultimate Beneficial Owner Unique Identifier."""
  id: ID!

  """Ultimate beneficial Indirect Owner Individual type ."""
  type: UltimateBeneficialOwnerType!

  """Unique Reference of the Parent Company."""
  parentCompanyReference: String!

  """
  Shares ratio of the parent company. Example: 50 if the share ratio is 50%.
  """
  parentCompanyShareRatio: Float!

  """First name."""
  firstName: String!

  """Last name."""
  lastName: String!

  """Birth date."""
  birthDate: Date!
}

"""
The Ultimate Beneficial Owner could be for an Individual or a Company and these can Direct or Indirect
"""
interface UltimateBeneficialOwnerInfo {
  """Ultimate Beneficial Owner Unique Identifier ."""
  id: ID!

  """Ultimate beneficial owner type."""
  type: UltimateBeneficialOwnerType!

  """
  Shares ratio of the parent company. Example: 50 if the share ratio is 50%.
  """
  parentCompanyShareRatio: Float!
}

"""Ultimate Beneficial Owner type."""
enum UltimateBeneficialOwnerType {
  """Direct Individual Owner (Natural person) ."""
  DirectIndividual

  """Direct Company Owner (Legal person)."""
  DirectCompany

  """Indirect Individual Owner (Natural person)."""
  IndirectIndividual

  """Indirect Company Owner (Legal person)."""
  IndirectCompany
}

"""Rejection returned when the provided `exportId` is not found"""
type UnknownExportRejection implements Rejection {
  message: String!
}

type UnsavedInternationalBeneficiary implements InternationalBeneficiary {
  """Currency of the international beneficiary"""
  currency: Currency!

  """Route that Swan will use to transfer the funds"""
  route: InternationalCreditTransferRoute!

  """Currency-specific details of the beneficiary"""
  details: [InternationalCreditTransferDetails!]!

  """name of the beneficiary"""
  name: String!
}

type UnsavedSepaBeneficiary {
  """IBAN of the beneficiary"""
  iban: IBAN!

  """name of the beneficiary"""
  name: String!

  """address of the beneficiary"""
  address: Address
}

"""Upcoming transaction status information"""
type UpcomingTransactionStatusInfo implements TransactionStatusInfo {
  """status of the transaction"""
  status: TransactionStatus!

  """The date when the transaction will be executed"""
  executionDate: DateTime!
}

input UpdateAccountHolderInput {
  accountHolderId: ID!
  vatNumber: String
  taxIdentificationNumber: String
}

union UpdateAccountHolderPayload = UpdateAccountHolderSuccessPayload | AccountHolderNotFoundRejection | ValidationRejection

type UpdateAccountHolderSuccessPayload {
  accountHolder: AccountHolder!
}

"""Inputs to update an account"""
input UpdateAccountInput {
  """Unique identifier of an account"""
  accountId: ID!

  """Name"""
  name: String

  """Language"""
  language: AccountLanguage
}

"""Inputs to update an account membership"""
input UpdateAccountMembershipInput {
  """Unique identifier of an account membership"""
  accountMembershipId: ID!

  """Email address"""
  email: String

  """Restricted to a user if necessary"""
  restrictedTo: UpdatedRestrictedToInput

  """
  `true` if this account membership can view account balances and transactions history
  """
  canViewAccount: Boolean

  """`true` if this account membership can add or canceled beneficiaries"""
  canManageBeneficiaries: Boolean

  """`true` if this account membership can initiate credit transfers"""
  canInitiatePayments: Boolean

  """
  `true` if this account membership can invite, update, suspend or resume memberships
  """
  canManageAccountMembership: Boolean

  """
  `true` if this account membership can manage cards for himself or to the memberships he manages
  """
  canManageCards: Boolean

  """Periodic Spending limit"""
  spendingLimit: SpendingLimitInput

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Residency address of the member to be added"""
  residencyAddress: ResidencyAddressInput

  """Language of the account membership"""
  language: AccountLanguage

  """Tax Identification Number of the user added"""
  taxIdentificationNumber: String
}

union UpdateAccountMembershipPayload = AccountMembershipCannotBeUpdatedRejection | AccountMembershipNotFoundRejection | AccountMembershipNotReadyToBeUpdatedRejection | AccountNotFoundRejection | ForbiddenRejection | InternalErrorRejection | InvalidPhoneNumberRejection | LegalRepresentativeEmailCannotBeUpdatedRejection | LegalRepresentativePermissionsCannotBeUpdatedRejection | MissingBirthDateRejection | MissingPhoneNumberRestrictionRejection | PermissionCannotBeGrantedRejection | UpdateAccountMembershipSuccessPayload | UserNotAllowedToManageAccountMembershipRejection | ValidationRejection

type UpdateAccountMembershipSuccessPayload {
  consent: Consent!
}

union UpdateAccountPayload = UpdateAccountSuccessPayload | AccountNotFoundRejection | BadAccountStatusRejection | ForbiddenRejection | InternalErrorRejection | ValidationRejection

type UpdateAccountSuccessPayload {
  account: Account!
}

"""Input to Update Card"""
input UpdateCardInput {
  """Unique identifier of the card to update"""
  cardId: ID!

  """Card expiration date  if `null` it does not have an expiration date"""
  cardContractExpiryDate: DateTime

  """`true` if this card allows cash withdrawals"""
  withdrawal: Boolean!

  """`true` if this card allows payments outside of the country"""
  international: Boolean!

  """
  `true` if this card allows transactions outside of the card's main currency
  """
  nonMainCurrencyTransactions: Boolean!

  """`true` if this card allows transactions at eCommerce sites"""
  eCommerce: Boolean!

  """Periodic Spending limit"""
  spendingLimit: SpendingLimitInput

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!

  """Card name"""
  name: String
}

union UpdateCardPayload = UpdateCardSuccessPayload | AccountNotFoundRejection | CardNotFoundRejection | AccountMembershipNotAllowedRejection | ValidationRejection

type UpdateCardSuccessPayload {
  consent: Consent!
}

input UpdateCompanyOnboardingInput {
  """
  Account name of the company account holder.
  - Length must be from 0 to 100 characters
  """
  accountName: String

  """Country of the account created at the end of onboarding."""
  accountCountry: AccountCountry

  """
  Company name.
  - Length must be from 0 to 100 characters.
  - Valid format (regex):
    ```
    /^(?:(?<!http(s)*:\/\/|www\.|&lt;|&gt;)[!-.\/-;A-Z[-`a-zÀ-ÖÙ-öº-ƿǄ-ʯʹ-ʽΈ-ΊΎ-ΡΣ-ҁҊ-Ֆա-ևႠ-Ⴥა-ჺᄀ-፜፩-ᎏᵫ-ᶚḀ-῾ⴀ-ⴥ⺀-⿕ぁ-ゖゝ-ㇿ㋿-鿯鿿-ꒌꙀ-ꙮꚀ-ꚙꜦ-ꞇꞍ-ꞿꥠ-ꥼＡ-Ｚａ-ｚ/]|¿|¡| |'|-|Ά|Ό|=|\?|@|\[|]|\||‘|’)*$/
    ```
  """
  name: String

  """
  Registration number of the company (for example, Système d'Identification du Répertoire des ENtreprises [SIREN] in France, ...).
  - Length must be from 0 to 50 characters.
  """
  registrationNumber: String

  """Type of the company (Association ...)."""
  companyType: CompanyType

  """Business activity."""
  businessActivity: BusinessActivity

  """
  Description of the business activity.
  - Length must be from 0 to 1024 characters.
  """
  businessActivityDescription: String

  """Estimated monthly payment volume (euro)."""
  monthlyPaymentVolume: MonthlyPaymentVolume

  """
  The ultimate beneficial owner is defined as the natural person (s) who own or control, directly and/or indirectly, the reporting company.
  
  The ultimate beneficial owner is :
  - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
  - either the natural person (s) who exercise, by other means, a power of control of the company;
  """
  individualUltimateBeneficialOwners: [IndividualUltimateBeneficialOwnerInput!]

  """
  Residency address of the head office.
  - Must be in a European country.
  """
  residencyAddress: ResidencyAddressInput

  """
  Email of the legal representative.
  - Length must be from 0 to 255 characters.
  - Valid format (regex):
    ```
    /^[A-Z0-9_+.-]*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9-]*\.)+[A-Z]{2,}$/i
    ```
  - Some email providers are not accepted by our system.
  """
  email: String

  """
  Language of the onboarding process.
  - Accepted languages: `["en", "fr", "nl", "de", "it", "es", "pt", "fi"]`
  """
  language: String

  """
  Is the company registered with their country's national register (for example, Registre du Commerce et des Sociétés [RCS] in France).
  """
  isRegistered: Boolean

  """ID of the onboarding to update."""
  onboardingId: ID!

  """
  VAT number of the company.
  - (AT)?U[0-9]{8} |                              # Austria
  - (BE)?0[0-9]{9} |                              # Belgium
  - (BG)?[0-9]{9,10} |                            # Bulgaria
  - (CY)?[0-9]{8}L |                              # Cyprus
  - (CZ)?[0-9]{8,10} |                            # Czech Republic
  - (DE)?[0-9]{9} |                               # Germany
  - (DK)?[0-9]{8} |                               # Denmark
  - (EE)?[0-9]{9} |                               # Estonia
  - (EL|GR)?[0-9]{9} |                            # Greece
  - (ES)?[0-9A-Z][0-9]{7}[0-9A-Z] |               # Spain
  - (FI)?[0-9]{8} |                               # Finland
  - (FR)?[0-9A-Z]{2}[0-9]{9} |                    # France
  - (GB)?([0-9]{9}([0-9]{3})?|[A-Z]{2}[0-9]{3}) | # United Kingdom
  - (HU)?[0-9]{8} |                               # Hungary
  - (IE)?[0-9]S[0-9]{5}L |                        # Ireland
  - (IT)?[0-9]{11} |                              # Italy
  - (LT)?([0-9]{9}|[0-9]{12}) |                   # Lithuania
  - (LU)?[0-9]{8} |                               # Luxembourg
  - (LV)?[0-9]{11} |                              # Latvia
  - (MT)?[0-9]{8} |                               # Malta
  - (NL)?[0-9]{9}B[0-9]{2} |                      # Netherlands
  - (PL)?[0-9]{10} |                              # Poland
  - (PT)?[0-9]{9} |                               # Portugal
  - (RO)?[0-9]{2,10} |                            # Romania
  - (SE)?[0-9]{12} |                              # Sweden
  - (SI)?[0-9]{8} |                               # Slovenia
  - (SK)?[0-9]{10}                                # Slovakia
  """
  vatNumber: String

  """
    Tax Identification Number.
  - Must be from 0 to 16 characters.
  """
  taxIdentificationNumber: String

  """Legal representative personal address."""
  legalRepresentativePersonalAddress: AddressInformationInput

  """Type of representation (legal representative or power of attorney)."""
  typeOfRepresentation: TypeOfRepresentation
}

"""Possible results for mutation `updateCompanyOnboarding`"""
union UpdateCompanyOnboardingPayload = ForbiddenRejection | InternalErrorRejection | UpdateCompanyOnboardingSuccessPayload | ValidationRejection

"""Result when updateCompanyOnboarding is a success"""
type UpdateCompanyOnboardingSuccessPayload {
  onboarding: OnboardingInfo!
}

"""Input when the account membership is restricted to a verified user"""
input UpdatedRestrictedToInput {
  """Account member first name"""
  firstName: String

  """Account member last name"""
  lastName: String

  """Account member birth date"""
  birthDate: Date

  """Account member phone number"""
  phoneNumber: String
}

input UpdateIndividualOnboardingInput {
  """
  Account name of the individual account holder.
  - Length must be from 0 to 100 characters.
  """
  accountName: String

  """Country of the account created at the end of onboarding."""
  accountCountry: AccountCountry

  """Employment status of the individual account holder."""
  employmentStatus: EmploymentStatus

  """Monthly income of the individual account holder (euro)."""
  monthlyIncome: MonthlyIncome

  """
  Residency address of the individual account holder.
  - Must be in a European country.
  """
  residencyAddress: ResidencyAddressInput

  """
  Email of the legal representative.
  - Length must be from 0 to 255 characters.
  - Valid format (regex):
    ```
    /^[A-Z0-9_+.-]*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9-]*\.)+[A-Z]{2,}$/i
    ```
  - Some email providers are not accepted by our system.
  """
  email: String

  """
  Language of the onboarding process.
  - Accepted languages: `["en", "fr", "nl", "de", "it", "es", "pt", "fi"]`
  """
  language: String

  """ID of the onboarding to update."""
  onboardingId: ID!

  """
    Tax Identification Number.
  - Must be from 0 to 16 characters.
  """
  taxIdentificationNumber: String
}

"""Possible result types for `updateIndividualOnboarding`"""
union UpdateIndividualOnboardingPayload = ForbiddenRejection | InternalErrorRejection | UpdateIndividualOnboardingSuccessPayload | ValidationRejection

"""Type of result when updateIndividualOnboarding is a success"""
type UpdateIndividualOnboardingSuccessPayload {
  onboarding: OnboardingInfo!
}

"""Inputs to update a received sepa direct debit mandate B2b."""
input UpdateReceivedSepaDirectDebitB2bMandateInput {
  """The unique mandate id"""
  receivedDirectDebitMandateId: ID!

  """The unique identifier of the received direct debit mandate"""
  mandateReference: String

  """The Sepa Creditor Identifier of the creditor"""
  creditorIdentifier: String

  """The name of the creditor"""
  creditorName: String

  """The Swan Iban of the debtor"""
  iban: String

  """
  Label that will be displayed along with this received direct debit mandate in the web banking
  """
  name: String

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

"""
Union type returned by the updateReceivedSepaDirectDebitB2bMandate mutation
"""
union UpdateReceivedSepaDirectDebitB2bMandatePayload = UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload | ReceivedDirectDebitMandateNotFoundRejection | ForbiddenRejection | ReceivedDirectDebitMandateAlreadyExistRejection | ReceivedDirectDebitMandateNotB2bRejection | AccountNotFoundRejection

"""
Return type in case of a successful response of the updateReceivedSepaDirectDebitB2bMandate mutation
"""
type UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload {
  """The received direct debit mandate updated"""
  receivedDirectDebitMandate: ReceivedDirectDebitMandate!
}

type UpdateRequestNotPendingReviewRejection implements Rejection {
  requestUpdateId: ID
  message: String!
}

input UpdateSupportingDocumentInput {
  supportingDocumentId: ID!
  supportingDocumentType: SupportingDocumentType
  supportingDocumentPurpose: SupportingDocumentPurposeEnum
}

union UpdateSupportingDocumentPayload = UpdateSupportingDocumentSuccessPayload | ForbiddenRejection | InternalErrorRejection | SupportingDocumentCollectionNotFoundRejection | SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection | SupportingDocumentNotFoundRejection | SupportingDocumentStatusDoesNotAllowUpdateRejection | ValidationRejection

type UpdateSupportingDocumentSuccessPayload {
  supportingDocument: SupportingDocument!
}

input UpdateUserConsentSettingsInput {
  """Swan user id"""
  userId: ID!

  """Preferred consent notification channel, Sms or App"""
  preferredNotificationChannel: PreferredNotificationChannel!
}

union UpdateUserConsentSettingsPayload = UpdateUserConsentSettingsSuccessPayload | UpdateUserConsentSettingsTokenRejection

type UpdateUserConsentSettingsSuccessPayload {
  userConsentSettings: UserConsentSettings!
}

type UpdateUserConsentSettingsTokenRejection implements Rejection {
  message: String!
}

"""Input values needed to update a Webhook Subscription"""
input UpdateWebhookSubscriptionInput {
  """Subscription to update"""
  id: ID!

  """
  A short descriptive label for the subscription
  (max 255 characters)
  """
  label: String!

  """
  The endpoint URL events will be sent to
  (max 255 characters)
  """
  endpoint: String!

  """
  The optional secret to secure incoming webhook calls. We recommend a UUID-4 to be future proof.
  (max 36 characters)
  """
  secret: String

  """
  The types of subscribed events
  A subset of unique IDs from `webhookEventTypes`
  """
  eventTypes: [ID!]!

  """Control if the subscription should be enabled or not"""
  status: WebhookSubscriptionCreationStatus!
}

scalar Upload

"""
URL that follows the WHATWG URL Standard.

[Examples of parsed URLs](https://url.spec.whatwg.org/#example-url-parsing) may be found in the Standard itself.
"""
scalar URL

"""The User is the unique user, natural person, of the Swan app."""
type User {
  """unique identifier of the user"""
  id: ID!

  """
  The list of account memberships
  
  Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
  """
  accountMemberships(
    """the number of elements to load (maximum: 100)"""
    first: Int! = 50

    """
    the index (a unique reference in string form) from which you will load the preceding elements
    """
    before: String

    """
    the index (a unique reference in string form) from which you will load the following elements
    """
    after: String

    """a filtering table you can apply to your list of connections"""
    filters: AccountMembershipsFilterInput
  ): AccountMembershipConnection!

  """
  mobile phone number with the international format (Example: +33689788967)
  """
  mobilePhoneNumber: PhoneNumber

  """first name"""
  firstName: String

  """last name"""
  lastName: String

  """Birth last name"""
  birthLastName: String

  """list of first names"""
  allFirstNames: [String!]

  """
  full name : concatenation of firstName + [ birthLastName | lastName ] depending on preferredLastName setting
  """
  fullName: String

  """birth date"""
  birthDate: Date

  """nationality"""
  nationalityCCA3: CCA3

  """birth city"""
  birthCity: String

  """
  `true` if Swan has verified the user's identity
  @deprecated Use the equivalent identificationLevels.expert field instead
  """
  idVerified: Boolean! @deprecated(reason: "Use the equivalent `identificationLevels.expert` field instead")

  """the methods used to authenticate this user"""
  authenticators: [Authenticator!]

  """
  List of identification levels available for the user.
  
  Whenever TRUE, it means the identification was successful for the associated level.
  """
  identificationLevels: IdentificationLevels

  """
  Preferred notification channel
  
  When it is "null" it means that the preferences have not been updated. Default SMS in use
  """
  preferredNotificationChannel: PreferredNotificationChannel

  """Status of the user"""
  status: UserStatus

  """Creation date of the user"""
  createdAt: DateTime!

  """Last update date of the user"""
  updatedAt: DateTime!

  """The last name that the user prefers to use"""
  preferredLastName: String

  """
  Date on which the user joined the project. Joining the project is done after the first accepted OAuth login.
  """
  joinedAt: DateTime!

  """@deprecated Use verifiedEmails field instead"""
  emailAddresses: [String!]! @deprecated(reason: "Use verifiedEmails field instead")

  """Returns the verified emails"""
  verifiedEmails: [String!]!
  identifications(
    """Maximum number of elements in the list (default value 50)"""
    first: Int! = 50

    """When the list of elements needs to start after an element"""
    after: String

    """When the list of identifications needs to be filtered"""
    filters: IdentificationFiltersInput

    """
    When the list of identifications needs to be ordered, by default the list will be ordered by the latest identification (valid or not)
    """
    orderBy: IdentificationsOrderByInput
  ): IdentificationConnection
}

type UserAlreadyDeactivatedRejection {
  """User id"""
  userId: ID!

  """Message"""
  message: String!
}

type UserBlockedRejection implements Rejection {
  message: String!
}

type UserCannotBeDeactivatedRejection {
  """User id"""
  userId: ID!

  """Reason"""
  message: String!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type UserConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """UserEdge list"""
  edges: [UserEdge!]!
}

type UserConsentSettings {
  """Preferred notification channel"""
  preferredNotificationChannel: PreferredNotificationChannel!

  """User identifier"""
  userId: String!

  """Project identifier"""
  projectId: String!
}

"""Implements the Relay Edge interface"""
type UserEdge implements Edge {
  """
  Opaque identifier pointing to this consent node in the pagination mechanism
  """
  cursor: String!

  """The user"""
  node: User!
}

"""Filters that can be applied when listing users"""
input UserFilterInput {
  """Filter by birth date"""
  birthDate: Date

  """
  Filter by first name
  
  @deprecated(reason: "use `search` instead")
  """
  firstName: String

  """Filter by identification level"""
  identificationLevel: IdentificationLevelInput

  """
  Search by last name
  
  @deprecated(reason: "use `search` instead")
  """
  lastName: String

  """Filter by phone number"""
  mobilePhoneNumber: String

  """Filter by nationality"""
  nationalityCCA3: CCA3

  """Filter by preferred notification channel"""
  preferredNotificationChannel: PreferredNotificationChannel

  """Filter by status"""
  status: [UserStatus!]

  """
  Search string to look for (min length : 3 characters)
  
  Search will be performed in following fields:
   - First name
   - Last name
   - Mobile phone number
   - ID
  """
  search: String
}

input UserInformationInput {
  firstName: String!
  lastName: String!
  birthDate: Date!
}

type UserNotAllowedToDisableItsOwnAccountMembershipRejection implements Rejection {
  accountMembershipId: String!
  message: String!
}

"""
Rejection returned if a identity does not have enough permission to manage account membership
"""
type UserNotAllowedToManageAccountMembershipRejection implements Rejection {
  message: String!
}

type UserNotAllowedToSuspendItsOwnAccountMembershipRejection implements Rejection {
  accountMembershipId: String!
  message: String!
}

"""Rejection returned when the User is not the Card Holder"""
type UserNotCardHolderRejection implements Rejection {
  message: String!
}

type UserNotFoundRejection implements Rejection {
  """User id"""
  id: ID!

  """Message"""
  message: String!
}

"""Field we can use when ordering that can be applied when listing users"""
enum UserOrderByFieldInput {
  createdAt
  updatedAt
}

"""Order that can be applied when listing users"""
input UserOrderByInput {
  field: UserOrderByFieldInput
  direction: OrderByDirection
}

enum UserStatus {
  """Users with Active status are able to login & use Swan."""
  Active

  """
  Users in Deactivated status don't use Swan anymore and won't ever be able to login. Their phone number can be reused as a new number.
  """
  Deactivated

  """
  Users in Blocked status are not able to login for security reason. Their phone number can't be reused.
  """
  Blocked
}

"""A detail of a validation error : what field is errored and why"""
type ValidationError {
  """
  Onboarding property that is not matching requirements to allow a finalization
  """
  field: String!

  """Constraints that are not matched on the Onboarding property"""
  errors: [FieldValidationError!]
}

type ValidationFieldError {
  code: ValidationFieldErrorCode!
  message: String!
  path: [String!]!
}

enum ValidationFieldErrorCode {
  InvalidString
  InvalidType
  TooLong
  TooShort
  UnrecognizedKeys
}

"""Rejection returned if an input contains invalid data"""
type ValidationRejection implements Rejection {
  fields: [ValidationFieldError!]!
  message: String!
}

"""Information extracted from a valid IBAN"""
type ValidIban {
  """Iban from input"""
  iban: IBAN!

  """Account Number extracted from the IBAN"""
  accountNumber: String!

  """Checksum extracted from the IBAN"""
  checksum: String!

  """Bank that owns this IBAN"""
  bank: Bank!

  """Reachability of this IBAN over different payment methods"""
  reachability: Reachability!
}

"""
Describes a valid identification level for the process associated to this identification, and identification documents can be accessed
"""
type ValidIdentificationLevelStatusInfo {
  """Always set to `Valid`"""
  status: SwanIdentificationStatus!
}

"""Verification Flow."""
enum VerificationFlow {
  """
  When you ask the account holder to start the verification process at the beginning of the relationship to get an unlimited account.
  """
  Upfront

  """
  When you ask the account holder the minimum required to comply the law at the beginning of the relationship.
  """
  Progressive
}

type VerificationRenewal {
  verificationRenewalId: ID
}

"""
Account Holder Verification Requirement

It is a sub status for the Account Holder when his verification status is WaitingForInformation
"""
type VerificationRequirement {
  id: ID!
  type: VerificationRequirementType!
}

type VerificationRequirementsNotUpdatableRejection implements Rejection {
  accountHolderId: String!
  accountHolderVerificationStatus: VerificationStatus!
  message: String!
}

enum VerificationRequirementType {
  """Swan is requesting for a 1st transfer"""
  FirstTransferRequired

  """Swan is requesting some Supporting Documents"""
  SupportingDocumentsRequired

  """Swan is requesting some clarification on the UBO"""
  UboDetailsRequired

  """
  Swan is requesting some clarification on the legal representative or on the account member with legal representative permissions
  """
  LegalRepresentativeDetailsRequired

  """Swan is requesting some clarification on the organization"""
  OrganizationDetailsRequired

  """Swan is requesting some tax identifier"""
  TaxIdRequired

  """Swan is requesting more information on the account holders"""
  Other
}

"""Verification status of an account holder"""
enum VerificationStatus {
  """
  When the account holder has not started to answer the verification process.
  """
  NotStarted

  """
  When Swan is waiting for information about the account holder to continue the verification process.
  """
  WaitingForInformation

  """When the verification process is pending."""
  Pending

  """When the account holder is verified."""
  Verified

  """When the account holder is refused."""
  Refused
}

"""Enabled Information"""
type VerifiedStatusInfo implements AccountVerificationStatusInfo {
  """Date at which the verification was verified"""
  verifiedAt: DateTime!

  """Account verification status (Verified)"""
  status: AccountVerificationStatus!
}

input ViewCardNumbersInput {
  """Unique identifier of a card"""
  cardId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ViewCardNumbersPayload = ViewCardNumbersSuccessPayload | UserNotCardHolderRejection | CardNotFoundRejection | ValidationRejection

type ViewCardNumbersSuccessPayload {
  """The consent required to view card numbers"""
  consent: Consent!
}

input ViewCardNumbersWithConsentInput {
  """Unique identifier of an accepted view card number consent"""
  consentId: String!
}

union ViewCardNumbersWithConsentPayload = ViewCardNumbersWithConsentSuccessPayload | ForbiddenRejection | CardSensitiveInfoNoLongerAvailableRejection | CardNotFoundRejection

type ViewCardNumbersWithConsentSuccessPayload {
  panIframeUrl: String!
  expiryDateIframeUrl: String!
  cvvIframeUrl: String!
  cardholderName: String!
}

input ViewPhysicalCardNumbersInput {
  """Unique identifier of a card"""
  cardId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ViewPhysicalCardNumbersPayload = ViewPhysicalCardNumbersSuccessPayload | UserNotCardHolderRejection | CardNotFoundRejection | ValidationRejection

type ViewPhysicalCardNumbersSuccessPayload {
  """The consent required to view card numbers"""
  consent: Consent!
}

input ViewPhysicalCardPinInput {
  """Unique identifier of a card"""
  cardId: ID!

  """URL the user is redirected to after consent has been given"""
  consentRedirectUrl: String!
}

union ViewPhysicalCardPinPayload = ViewPhysicalCardPinSuccessPayload | CardNotFoundRejection | PhysicalCardNotFoundRejection | PINNotReadyRejection | UserNotCardHolderRejection | ValidationRejection

type ViewPhysicalCardPinSuccessPayload {
  """The consent required to view card numbers"""
  consent: Consent!
}

"""
Virtual IBAN can be used by the account holder to receive SCT (Sepa Credit Transfer) or to be debited by SDD (Sepa Direct Debit).
"""
type VirtualIBANEntry {
  """Unique identifier of a Virtual IBAN entry"""
  id: ID!

  """International Bank Account Number"""
  IBAN: IBAN!

  """Bank Identifier Code"""
  BIC: BIC!

  """Label (could be used to identify)"""
  label: String

  """Status of the Iban"""
  status: IBANStatus!

  """`true` if the Virtual IBAN refuses all Sepa Direct Debit received"""
  blockSDD: Boolean!
}

"""
Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
"""
type VirtualIBANEntryConnection implements Connection {
  """Total number of element in the list"""
  totalCount: Int!

  """Information about the current, the previous and the next page"""
  pageInfo: PageInfo!

  """VirtualIBANEntryEdge list"""
  edges: [VirtualIBANEntryEdge!]!
}

"""Implements the Relay Edge interface"""
type VirtualIBANEntryEdge implements Edge {
  """Opaque identifier pointing to this node in the pagination mechanism"""
  cursor: String!

  """The virtual iban entry"""
  node: VirtualIBANEntry!
}

"""Wallet Provider (ApplePay, GooglePay ...)"""
type WalletProvider {
  """name of the Wallet Provider (Apple / Google / Amazon or Unknown)"""
  name: String!

  """id of the Wallet Provider"""
  id: String!
}

"""Wallet Provider"""
enum WalletProviderType {
  ApplePay
  GooglePay
}

scalar WalletToken

type WebBankingSettings {
  canViewAccountDetails: Boolean
  canViewAccountStatement: Boolean
  canManageVirtualIbans: Boolean
  canInitiatePaymentsToNewBeneficiaries: Boolean
  canViewPaymentList: Boolean
  canOrderVirtualCards: Boolean
  canOrderPhysicalCards: Boolean
  canViewMembers: Boolean
  canAddNewMembers: Boolean
  canCreateMerchantProfile: Boolean
  canRequestOnlineCardsPaymentMethod: Boolean
  canRequestSepaDirectDebitCorePaymentMethod: Boolean
  canRequestSepaDirectDebitB2BPaymentMethod: Boolean
  canRequestInternalDirectDebitCorePaymentMethod: Boolean
  canRequestInternalDirectDebitB2BPaymentMethod: Boolean
  canRequestChecksPaymentMethod: Boolean
  canInitiateCheckMerchantPayments: Boolean
  canCreateMerchantPaymentLinks: Boolean
}

"""
A WebhookEvent Log for webhooks service.
It describes the response and call context for webhook endpoints
for a specific event.
"""
type WebhookEventLog {
  """Unique identifier of the EventLog"""
  id: ID!

  """Date the EventLog has been created"""
  createdAt: DateTime!

  """Unique identifier of the event that triggered this eventLog"""
  eventId: ID!

  """Date the Event has been generated"""
  eventDate: DateTime!

  """The type of the triggering event"""
  eventType: String!

  """Unique identifier linked of the resource carried by the Event"""
  resourceId: ID!

  """Duration of the callback in MS"""
  duration: Int!

  """Request payload send to callback in string format, jsonable."""
  requestPayload: String!

  """Response payload get by the callback in string format, jsonable."""
  responsePayload: String

  """The callback response status in number format."""
  statusCode: Int

  """The callback response status in text format."""
  statusText: StatusText

  """The webhook that triggered the event."""
  webhookSubscription: WebhookSubscription

  """Rank of this retry"""
  retryCount: Int

  """
  Label of the associated subscription (inherited)
  This holds the label value of when the log was created, whereas
  webhookSubscription.label holds the current value of the label
  (it may have changed).
  """
  webhookSubscriptionLabel: String

  """
  Endpoint of the associated subscription (inherited)
  This holds the endpoint value of when the log was created, whereas
  webhookSubscription.endpoint holds the current value of the endpoint
  (it may have changed).
  """
  webhookSubscriptionEndpoint: String
}

"""Filters that can be applied when listing eventLogs"""
input WebhookEventLogFiltersInput {
  statusCode: Int
  statusText: StatusText
  startDate: DateTime
  endDate: DateTime
  eventType: String
  eventId: ID
  resourceId: ID
  webhookSubscriptionId: ID
}

"""Rejection returned when Webhook event log id is not found"""
type WebhookEventLogNotFoundRejection implements Rejection {
  message: String!
}

"""Relay Connection for Webhook Eventlog"""
type WebhookEventLogsConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [WebhookEventLogsEdge!]!
}

"""Relay Edge for Webhook Event Logs"""
type WebhookEventLogsEdge implements Edge {
  cursor: String!
  node: WebhookEventLog!
}

"""
A Subscription to the webhooks service.
It describes the registration of a callback url (the endpoint)
and a list of event types the client wants to be notified of.
"""
type WebhookSubscription {
  """Unique identifier of the Subscription"""
  id: ID!

  """A client provided short description of the Subscription"""
  label: String!

  """The callback URL to be used for POSTing events"""
  endpoint: String!

  """
  The optional secret to secure incoming webhook calls. We recommend a UUID-4 to be future proof.
  (max 36 characters)
  """
  secret: String

  """
  The types of subscribed events
  A simple list of event names as strings
  """
  eventTypes: [String!]!

  """Date the Subscription has been created"""
  createdAt: DateTime!

  """
    Last date the Subscription has been updated,
  except for state changes
  """
  updatedAt: DateTime!

  """The current state of the Subscription"""
  statusInfo: WebhookSubscriptionStatusInfo!

  """KPI data about the subscription (7 last days)"""
  kpi: WebhookSubscriptionKpi

  """Array of webhook event logs related to the subscription"""
  webhookEventLogs(first: Int! = 50, after: String, filters: NestedWebhookEventLogFiltersInput): WebhookEventLogsConnection
}

type WebhookSubscriptionBrokenStatusInfo implements WebhookSubscriptionStatusInfo {
  status: WebhookSubscriptionStatus!
  brokenAt: DateTime!
}

enum WebhookSubscriptionCreationStatus {
  Enabled
  Disabled
}

type WebhookSubscriptionDisabledStatusInfo implements WebhookSubscriptionStatusInfo {
  status: WebhookSubscriptionStatus!
  disabledAt: DateTime!
}

type WebhookSubscriptionEnabledStatusInfo implements WebhookSubscriptionStatusInfo {
  status: WebhookSubscriptionStatus!
  enabledAt: DateTime!
}

"""Input values needed to delete or modify a webhook subscription"""
input WebhookSubscriptionIdInput {
  """The webhook subscription id"""
  webhookSubscriptionId: ID!
}

type WebhookSubscriptionKpi {
  """Total number of eventLogs associated to this subscription"""
  totalHits: Int!

  """
  Total number of eventLogs that failed associated to this subscription
  errorRate = (errorRate/totalHits) * 100, rounded
  """
  errorRate: Float!
}

"""Rejection returned when Webhook Subscription is not found"""
type WebhookSubscriptionNotFoundRejection implements Rejection {
  message: String!
}

union WebhookSubscriptionPayload = WebhookSubscriptionSuccessPayload | WebhookSubscriptionNotFoundRejection | InternalErrorRejection | InvalidArgumentRejection | SubscriptionLimitsRejection

"""Relay Connection for Webhook Subscriptions"""
type WebhookSubscriptionsConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [WebhookSubscriptionsEdge!]!
}

"""Relay Edge for Webhook Subscriptions"""
type WebhookSubscriptionsEdge implements Edge {
  cursor: String!
  node: WebhookSubscription!
}

"""
State of a Webhook Subscription
It is either Enabled or Disabled by the owner,
ot set to Broken when delivery fails repeatedly.
"""
enum WebhookSubscriptionStatus {
  Enabled
  Disabled
  Broken
}

interface WebhookSubscriptionStatusInfo {
  status: WebhookSubscriptionStatus!
}

type WebhookSubscriptionSuccessPayload {
  webhookSubscription: WebhookSubscription!
}

type WrongCodeRejection implements Rejection {
  message: String!
}

"""Rejection returned when a parameter has a wrong value"""
type WrongValueProvidedRejection implements Rejection {
  message: String!
  valueProvided: String!
  parameterName: String!
}